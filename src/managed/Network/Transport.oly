namespace Evergreen.Network.Transport

open System
open System.IO
open System.IO.Compression
open System.Buffers
open System.Net
open System.Net.Sockets
open System.Collections.Generic

open Evergreen.Steam
open Evergreen.Utilities

interface INetworkIdentity =
    inherits IEquatable<INetworkIdentity>

    Port: int32 get
    AsString(): string
    
class NetworkIdentityComparer =
    implements IEqualityComparer<INetworkIdentity>

    GetHashCode(obj: INetworkIdentity): int32 = obj.Port
    Equals(x: INetworkIdentity, y: INetworkIdentity): bool =
        x.Equals(y)

interface INetworkTransport =
    inherits IDisposable

interface INetworkServerTransport =
    inherits INetworkTransport

    StartHost(port: int32): bool
    StopHost(): bool

    SendTo(buffer: ReadOnlySpan<byte>, identity: INetworkIdentity): int32
    ReceiveFrom(buffer: Span<byte>): (int32, INetworkIdentity)

    LocalIdentity: INetworkIdentity get

interface INetworkClientTransport =
    inherits INetworkTransport

    Send(buffer: ReadOnlySpan<byte>): int32
    Receive(buffer: Span<byte>): int32

    RemoteIdentity: INetworkIdentity get

private module Helpers =

    BindSocket(socket: Socket, port: int32): bool =
        let bind(port) =
            try
                // This prevents the server from receiving a socket exception when a client disconnects.
                // This is windows specific.
                let _ = socket.IOControl(/* SIO_UDP_CONNRESET */ -1744830452, mutable [0: byte;0;0;0], unchecked default)
               // socket.Bind(IPEndPoint(IPAddress.Any, port))
                socket.Bind(IPEndPoint(IPAddress.Parse("::1"), port))
                true
            catch (ex: Exception) =>
                false

        if (!bind(port))
            if (!bind(port + 1))
                if (!bind(port + 2))
                    false
                else
                    true
            else
                true
        else
            true

// Simple UDP transport implementation.

internal class UdpIdentity =
    implements INetworkIdentity

    public field endPoint: EndPoint

    new(endPoint: EndPoint) = this { endPoint = endPoint }

    Port: int32 
        get() = 
            if (DotNet.IsSubtypeOf<IPEndPoint>(this.endPoint))
                let endPoint: IPEndPoint = Unsafe.Cast(this.endPoint)
                endPoint.Port
            else
                0

    AsString(): string = this.endPoint.ToString()

    overrides Equals(other: object): bool =
        if (DotNet.IsSubtypeOf<UdpIdentity>(other))
            let other: UdpIdentity = Unsafe.Cast(other)
            if (DotNet.IsSubtypeOf<IPEndPoint>(this.endPoint) && DotNet.IsSubtypeOf<IPEndPoint>(other.endPoint))
                let x: IPEndPoint = Unsafe.Cast(this.endPoint)
                let y: IPEndPoint = Unsafe.Cast(other.endPoint)
                let result = x.Equals(y)
                result
            else
                false
        else
            false

    Equals(other: INetworkIdentity): bool =
        this.Equals(other: object)

class UdpServerTransport =
    implements INetworkServerTransport

    field mutable isDisposed: bool = false
    field mutable socket: Option<Socket> = None

    private CheckDisposed(): () =
        if (this.isDisposed)
            fail("Object disposed")

    private CheckSocket(): Socket =
        match (this.socket)
        | Some(socket) => socket
        | _ => fail("Socket not started")

    StartHost(port: int32): bool =
        this.CheckDisposed()
        if (this.socket.IsSome)
            false
        else
            let socket = Socket(AddressFamily.InterNetworkV6, SocketType.Dgram, ProtocolType.Udp)
            socket.Blocking <- false
            socket.ReceiveBufferSize <- Int32.MaxValue
            if (Helpers.BindSocket(socket, port))
                this.socket <- Some(socket)
                true
            else
                socket.Dispose()
                false

    StopHost(): bool =
        this.CheckDisposed()
        match (this.socket)
        | Some(socket) =>
            socket.Dispose()
            this.socket <- None
            true
        | _ =>
            false

    SendTo(buffer: ReadOnlySpan<byte>, identity: INetworkIdentity): int32 =
        this.CheckDisposed()
        let socket = this.CheckSocket()
        if (DotNet.IsSubtypeOf<UdpIdentity>(identity))
            let identity: UdpIdentity = Unsafe.Cast(identity)
            socket.SendTo(buffer, SocketFlags.None, identity.endPoint)
        else
            fail("invalid identity")

    ReceiveFrom(buffer: Span<byte>): (int32, INetworkIdentity) =
        this.CheckDisposed()
        let socket = this.CheckSocket()
        if (socket.Available == 0)
            (0, unchecked default)
        else
            let port =
                if (DotNet.IsSubtypeOf<IPEndPoint>(socket.LocalEndPoint))
                    let endPoint: IPEndPoint = Unsafe.Cast(socket.LocalEndPoint)
                    endPoint.Port
                else
                    fail("invalid end point")
            let mutable endPoint = IPEndPoint(IPAddress.IPv6Any, port): EndPoint
            (socket.ReceiveFrom(buffer, SocketFlags.None, &endPoint), UdpIdentity(endPoint))

    LocalIdentity: INetworkIdentity 
        get() = 
            this.CheckDisposed()
            let socket = this.CheckSocket()
            UdpIdentity(socket.LocalEndPoint)

    Dispose(): () =
        this.CheckDisposed() // TODO-language-bug: 'this.CheckDisposded' should show the correct diagnostic text range
        this.isDisposed <- true
        let _ = this.StopHost()

class UdpClientTransport =
    implements INetworkClientTransport

    field socket: Socket
    field port: int32
    field remoteIdentity: UdpIdentity
    field remoteEndPoint: IPEndPoint

    private new(socket: Socket, port: int32, remoteIdentity: UdpIdentity, remoteEndPoint: IPEndPoint) =
        this { socket = socket; port = port; remoteIdentity = remoteIdentity; remoteEndPoint = remoteEndPoint }

    static Connect(ipOrHostName: string, port: int32): UdpClientTransport =
        let ipEndPoint = System.Net.IPEndPoint(System.Net.IPAddress.Parse(ipOrHostName), port)
        let serverIdentity = UdpIdentity(ipEndPoint)
        let port = serverIdentity.Port
        let socket = Socket(AddressFamily.InterNetworkV6, SocketType.Dgram, ProtocolType.Udp)
        socket.Blocking <- false
        socket.ReceiveBufferSize <- Int32.MaxValue
        UdpClientTransport(socket, port, serverIdentity, ipEndPoint)

    Send(buffer: ReadOnlySpan<byte>): int32 =
        let remoteIdentity = this.remoteIdentity
        if (DotNet.IsSubtypeOf<UdpIdentity>(remoteIdentity))
            let identity: UdpIdentity = Unsafe.Cast(remoteIdentity)
            this.socket.SendTo(buffer, SocketFlags.None, identity.endPoint)
        else
            fail("invalid identity")

    Receive(buffer: Span<byte>): int32 =
        if (this.socket.Available == 0)
            0
        else
            let mutable endPoint = this.remoteEndPoint: EndPoint
            let numberOfBytesRead = this.socket.ReceiveFrom(buffer, SocketFlags.None, &endPoint)
            if (endPoint.Equals(this.remoteEndPoint))
                numberOfBytesRead
            else
                0

    RemoteIdentity: INetworkIdentity get() = this.remoteIdentity

    Dispose(): () =
        this.socket.Dispose()