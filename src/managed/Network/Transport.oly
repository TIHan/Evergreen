namespace Evergreen.Network.Transport

open System
open System.IO
open System.IO.Compression
open System.Buffers
open System.Net
open System.Net.Sockets
open System.Collections.Generic

open Evergreen.Steam
open Evergreen.Utilities

interface INetworkIdentity =
    inherits IEquatable<INetworkIdentity>

    Port: int32 get
    AsString(): string
    
class NetworkIdentityComparer =
    implements IEqualityComparer<INetworkIdentity>

    GetHashCode(obj: INetworkIdentity): int32 = obj.Port
    Equals(x: INetworkIdentity, y: INetworkIdentity): bool =
        x.Equals(y)

interface INetworkTransport =
    inherits IDisposable

interface INetworkServerTransport =
    inherits INetworkTransport

    StartHost(port: int32): bool
    StopHost(): bool

    SendTo(buffer: ReadOnlySpan<byte>, identity: INetworkIdentity): bool
    ReceiveFrom(buffer: Span<byte>): (int32, INetworkIdentity)

    LocalIdentity: INetworkIdentity get

interface INetworkClientTransport =
    inherits INetworkTransport

    Connect(serverIdentity: string, port: int32): bool
    Disconnect(): ()

    Send(buffer: ReadOnlySpan<byte>): bool
    Receive(buffer: Span<byte>): int32

    RemoteIdentity: INetworkIdentity get

private module Helpers =

    BindSocket(socket: Socket, port: int32): bool =
        let bind(port) =
            try
                // This prevents the server from receiving a socket exception when a client disconnects.
                // This is windows specific.
                let _ = socket.IOControl(/* SIO_UDP_CONNRESET */ -1744830452, mutable [0: byte;0;0;0], unchecked default)
               // socket.Bind(IPEndPoint(IPAddress.Any, port))
                socket.Bind(IPEndPoint(IPAddress.Parse("::1"), port))
                true
            catch (ex: Exception) =>
                false

        if (!bind(port))
            if (!bind(port + 1))
                if (!bind(port + 2))
                    false
                else
                    true
            else
                true
        else
            true

// Simple UDP transport implementation.

private class UdpIdentity =
    implements INetworkIdentity

    public field endPoint: EndPoint

    new(endPoint: EndPoint) = this { endPoint = endPoint }

    Port: int32 
        get() = 
            if (DotNet.IsSubtypeOf<IPEndPoint>(this.endPoint))
                let endPoint: IPEndPoint = Unsafe.Cast(this.endPoint)
                endPoint.Port
            else
                0

    AsString(): string = this.endPoint.ToString()

    overrides Equals(other: object): bool =
        if (DotNet.IsSubtypeOf<UdpIdentity>(other))
            let other: UdpIdentity = Unsafe.Cast(other)
            if (DotNet.IsSubtypeOf<IPEndPoint>(this.endPoint) && DotNet.IsSubtypeOf<IPEndPoint>(other.endPoint))
                let x: IPEndPoint = Unsafe.Cast(this.endPoint)
                let y: IPEndPoint = Unsafe.Cast(other.endPoint)
                let result = x.Equals(y)
                result
            else
                false
        else
            false

    Equals(other: INetworkIdentity): bool =
        this.Equals(other: object)

class UdpServerTransport =
    implements INetworkServerTransport

    field mutable isDisposed: bool = false
    field mutable socket: Option<Socket> = None

    private CheckDisposed(): () =
        if (this.isDisposed)
            fail("Object disposed")

    private CheckSocket(): Socket =
        match (this.socket)
        | Some(socket) => socket
        | _ => fail("Socket not started")

    StartHost(port: int32): bool =
        this.CheckDisposed()
        if (this.socket.IsSome)
            false
        else
            let socket = Socket(AddressFamily.InterNetworkV6, SocketType.Dgram, ProtocolType.Udp)
            socket.Blocking <- false
            socket.ReceiveBufferSize <- Int32.MaxValue
            if (Helpers.BindSocket(socket, port))
                this.socket <- Some(socket)
                true
            else
                socket.Dispose()
                false

    StopHost(): bool =
        this.CheckDisposed() // TODO-language-bug: 'this.CheckDisposed' as a partial call should show the correct diagnostic text range
        match (this.socket)
        | Some(socket) =>
            socket.Dispose()
            this.socket <- None
            true
        | _ =>
            false

    SendTo(mutable buffer: ReadOnlySpan<byte>, identity: INetworkIdentity): bool =
        this.CheckDisposed()
        let socket = this.CheckSocket()
        if (DotNet.IsSubtypeOf<UdpIdentity>(identity))
            let identity: UdpIdentity = Unsafe.Cast(identity)
            let bytesSent = socket.SendTo(buffer, SocketFlags.None, identity.endPoint)
            bytesSent == buffer.Length
        else
            fail("invalid identity")

    ReceiveFrom(buffer: Span<byte>): (int32, INetworkIdentity) =
        this.CheckDisposed()
        let socket = this.CheckSocket()
        if (socket.Available == 0)
            (0, unchecked default)
        else
            let port =
                if (DotNet.IsSubtypeOf<IPEndPoint>(socket.LocalEndPoint))
                    let endPoint: IPEndPoint = Unsafe.Cast(socket.LocalEndPoint)
                    endPoint.Port
                else
                    fail("invalid end point")
            let mutable endPoint = IPEndPoint(IPAddress.IPv6Any, port): EndPoint
            (socket.ReceiveFrom(buffer, SocketFlags.None, &endPoint), UdpIdentity(endPoint))

    LocalIdentity: INetworkIdentity 
        get() = 
            this.CheckDisposed()
            let socket = this.CheckSocket()
            UdpIdentity(socket.LocalEndPoint)

    Dispose(): () =
        let _ = this.StopHost()
        this.isDisposed <- true

private class UdpClientInfo =
    public field socket: Socket
    public field port: int32
    public field remoteIdentity: UdpIdentity
    public field remoteEndPoint: IPEndPoint

    new(socket: Socket, port: int32, remoteIdentity: UdpIdentity, remoteEndPoint: IPEndPoint) =
        this { socket = socket; port = port; remoteIdentity = remoteIdentity; remoteEndPoint = remoteEndPoint }

class UdpClientTransport =
    implements INetworkClientTransport

    field mutable isDisposed: bool = false
    field mutable info: Option<UdpClientInfo> = None

    private CheckDisposed(): () =
        if (this.isDisposed)
            fail("Object disposed")

    private CheckInfo(): UdpClientInfo =
        match (this.info)
        | Some(info) => info
        | _ => fail("Client not connected")

    Connect(serverIdentity: string, port: int32): bool =
        this.CheckDisposed()
        if (this.info.IsSome)
            fail("Client already connected")

        let ip =
            if (serverIdentity == "localhost")
                "::1"
            else
                serverIdentity

        let ipEndPoint = System.Net.IPEndPoint(System.Net.IPAddress.Parse(ip), port)
        let serverIdentity = UdpIdentity(ipEndPoint)
        let port = serverIdentity.Port
        let socket = Socket(AddressFamily.InterNetworkV6, SocketType.Dgram, ProtocolType.Udp)
        socket.Blocking <- false
        socket.ReceiveBufferSize <- Int32.MaxValue
        this.info <- Some(UdpClientInfo(socket, port, serverIdentity, ipEndPoint))
        true

    Disconnect(): () =
        this.CheckDisposed()
        let info = this.CheckInfo()
        info.socket.Dispose()
        this.info <- None    

    Send(mutable buffer: ReadOnlySpan<byte>): bool =
        this.CheckDisposed()
        let info = this.CheckInfo()

        let socket = info.socket
        let remoteEndPoint = info.remoteEndPoint

        let bytesSent = socket.SendTo(buffer, SocketFlags.None, remoteEndPoint)
        if (bytesSent == buffer.Length)
            true
        else
            false

    Receive(buffer: Span<byte>): int32 =
        this.CheckDisposed()
        let info = this.CheckInfo()

        let socket = info.socket
        let remoteEndPoint = info.remoteEndPoint

        if (socket.Available == 0)
            0
        else
            let mutable endPoint = remoteEndPoint: EndPoint
            let numberOfBytesRead = socket.ReceiveFrom(buffer, SocketFlags.None, &endPoint)
            if (endPoint.Equals(remoteEndPoint))
                numberOfBytesRead
            else
                0

    RemoteIdentity: INetworkIdentity 
        get() = 
            this.CheckDisposed()
            let info = this.CheckInfo()
            info.remoteIdentity

    Dispose(): () =
        this.CheckDisposed()
        this.isDisposed <- true
        match (this.info)
        | Some(info) =>
            info.socket.Dispose()
            this.info <- None
        | _ =>
            ()

// Steam transport implementation.

private class SteamServerIdentity =
    implements INetworkIdentity

    public field port: int32

    new(port: int32) = this { port = port }

    Port: int32 
        get() = this.port

    AsString(): string = 
        let mutable port = this.port
        "SteamServerPort: " + port.ToString()

    overrides Equals(other: object): bool =
        if (DotNet.IsSubtypeOf<SteamServerIdentity>(other))
            let other: SteamServerIdentity = Unsafe.Cast(other)
            this.port == other.port
        else
            false

    Equals(other: INetworkIdentity): bool =
        this.Equals(other: object)

private class SteamConnectionIdentity =
    implements INetworkIdentity

    public field connection: Steam.SteamNetworkClientConnection

    new(connection: Steam.SteamNetworkClientConnection) = this { connection = connection }

    Port: int32 
        get() = 0

    AsString(): string = 
        match (Steam.GetSteamIdFromConnection(this.connection))
        | SomeStruct(steamId) =>
            let name = Steam.GetPersonaName(steamId)
            "Steam: " + name + " (" + steamId.ToString() + ")"
        | _ =>
            "Steam: UNKNOWN"

    overrides Equals(other: object): bool =
        if (DotNet.IsSubtypeOf<SteamConnectionIdentity>(other))
            let other: SteamConnectionIdentity = Unsafe.Cast(other)
            this.connection == other.connection
        else
            false

    Equals(other: INetworkIdentity): bool =
        this.Equals(other: object)

class SteamServerTransport =
    implements INetworkServerTransport

    field mutable isDisposed: bool = false
    field mutable server: OptionStruct<Steam.SteamNetworkServer> = NoneStruct
    field mutable port: int32 = 0

    private CheckDisposed(): () =
        if (this.isDisposed)
            fail("Object disposed")

    private CheckServer(): Steam.SteamNetworkServer =
        match (this.server)
        | SomeStruct(server) => server
        | _ => fail("Server not started")

    StartHost(port: int32): bool =
        this.CheckDisposed()
        if (this.server.IsSome)
            false
        else
            let server = Steam.CreateNetworkServer(port)
            this.port <- port
            this.server <- SomeStruct(server)
            true

    StopHost(): bool =
        this.CheckDisposed()
        match (this.server)
        | SomeStruct(server) =>
            this.port <- 0
            this.server <- NoneStruct
            Steam.DestroyNetworkServer(server)
            true
        | _ =>
            false

    SendTo(buffer: ReadOnlySpan<byte>, identity: INetworkIdentity): bool =
        this.CheckDisposed()
        let server = this.CheckServer()
        if (DotNet.IsSubtypeOf<SteamConnectionIdentity>(identity))
            let identity: SteamConnectionIdentity = Unsafe.Cast(identity)
            server.SendMessage(buffer, identity.connection)
            true
        else
            fail("invalid identity")

    ReceiveFrom(buffer: Span<byte>): (int32, INetworkIdentity) =
        this.CheckDisposed()
        let server = this.CheckServer()
        let (connection, bytesRead) = server.ReceiveMessage(buffer) // TODO-language-bug: 'let (connection, bytesRead) = server.ReceiveMessage(buffer)' being the last expression should error.
        if (bytesRead > 0)
            let identity = SteamConnectionIdentity(connection)
            (bytesRead, identity)
        else
            (0, unchecked default)

    LocalIdentity: INetworkIdentity 
        get() = 
            this.CheckDisposed()
            let _ = this.CheckServer()
            SteamServerIdentity(this.port)

    Dispose(): () =
        let _ = this.StopHost()
        this.isDisposed <- true

class SteamClientTransport =
    implements INetworkClientTransport

    field mutable isDisposed: bool = false
    field mutable client: OptionStruct<Steam.SteamNetworkClient> = NoneStruct

    private CheckDisposed(): () =
        if (this.isDisposed)
            fail("Object disposed")

    private CheckClient(): Steam.SteamNetworkClient =
        match (this.client)
        | SomeStruct(client) => client
        | _ => fail("Client not connected")

    Connect(serverIdentity: string, port: int32): bool =
        this.CheckDisposed()
        if (this.client.IsSome)
            fail("Client already connected")

        let steamId =
            if (serverIdentity == "localhost")
                Steam.GetSteamId()
            else
                let mutable steamId = default
                match (Steam.SteamId.TryParse(serverIdentity, &steamId))
                | true => steamId
                | _ => Steam.SteamId(0)

        if (steamId.IsInvalid)
            false
        else    
            let client = Steam.CreateNetworkClient(steamId, port)
            this.client <- SomeStruct(client)
            true

    Disconnect(): () =
        this.CheckDisposed()
        let client = this.CheckClient()
        Steam.DestroyNetworkClient(client)
        this.client <- NoneStruct

    Send(buffer: ReadOnlySpan<byte>): bool =
        this.CheckDisposed()
        let client = this.CheckClient()
        client.SendMessage(buffer)
        true

    Receive(buffer: Span<byte>): int32 =
        this.CheckDisposed()
        let client = this.CheckClient()
        client.ReceiveMessage(buffer)

    RemoteIdentity: INetworkIdentity 
        get() = 
            this.CheckDisposed()
            let client = this.CheckClient()
            SteamConnectionIdentity(client.GetConnection()) // TODO-language-bug: 'SteamConnectionIdentity(client.GetConnection)' partial call should give error with correct text range.

    Dispose(): () =
        let _ = this.Disconnect()
        this.isDisposed <- true