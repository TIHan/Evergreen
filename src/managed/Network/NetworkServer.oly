namespace Evergreen.Network

open System
open System.IO
open System.IO.Compression
open System.Buffers
open System.Collections.Generic
open System.Collections.Concurrent
open System.Runtime.InteropServices
open System.Security.Cryptography

open Evergreen.Utilities
open Evergreen.Network.Transport

struct NetworkServerStatistics =
    public field mutable LastSentByteCount: uint64 = 0
    public field mutable PacketCountSinceHeartbeat: int32 = 0

class NetworkServer =
    implements IDisposable

    field identitiesToDisconnect: HashSet<INetworkIdentity>
    field desiredPort: int32
    field transport: INetworkServerTransport
    field connections: ConcurrentDictionary<INetworkIdentity, Connection>
    field onConnectionRequested: INetworkIdentity -> bool
    field onConnectionRefused: (INetworkIdentity, ClientDisconnectReason) -> ()
    field onClientConnected: INetworkIdentity -> ()
    field onClientDisconnected: (INetworkIdentity, ClientDisconnectReason) -> ()
    field onMessageReceived: (INetworkIdentity, ByteStream, channel: byte) -> ()
    field mutable connectionKey: string 
    field mutable isStarted: bool
    field mutable timeSinceStart: float32
    field clientTimeout: float32

    field mutable stats: NetworkServerStatistics

    field lagRandom: Random
    field mutable lagQueue: Queue<LagSimulatedPacket>
    LatencySimulationRange: (uint16, uint16) get, set
    PacketLossSimulationRate: byte get, set

    private DisconnectQueue: ConcurrentQueue<INetworkIdentity> get
    private ReceivePacketPool: PacketPool get

    new(desiredPort: int32,
        onConnectionRequested: INetworkIdentity -> bool,
        onConnectionRefused: (INetworkIdentity, ClientDisconnectReason) -> (),
        onClientConnected: INetworkIdentity -> (),
        onClientDisconnected: (INetworkIdentity, ClientDisconnectReason) -> (),
        onMessageReceived: (INetworkIdentity, ByteStream, channel: byte) -> ()) = 
        if (desiredPort <= 0)
            throw ArgumentOutOfRangeException("desiredPort")
        this { 
            identitiesToDisconnect = HashSet()
            transport = SteamServerTransport()//UdpServerTransport()
            desiredPort = desiredPort
            connections = ConcurrentDictionary(NetworkIdentityComparer())
            onConnectionRequested = onConnectionRequested
            onConnectionRefused = onConnectionRefused
            onClientConnected = onClientConnected
            onClientDisconnected = onClientDisconnected
            onMessageReceived = onMessageReceived
            connectionKey = ""
            isStarted = false
            timeSinceStart = 0
            clientTimeout = 6 // seconds
            stats = NetworkServerStatistics()

            lagRandom = Random()
            lagQueue = Queue()
            LatencySimulationRange = (0, 0)
            PacketLossSimulationRate = 0

            DisconnectQueue = ConcurrentQueue()
            ReceivePacketPool = PacketPool(1024)
        }

    Port: int32 
        get() = 
            if (this.isStarted)
                this.transport.LocalIdentity.Port
            else
                0
    Statistics: NetworkServerStatistics get() = this.stats
    IsStarted: bool get() = this.isStarted

    private SendPacket(packet: Packet): () =
        if (packet.IsInPool)
            throw InvalidOperationException("Cannot send packet that is in the packet pool")
        let byteCount =
            if (this.transport.SendTo(packet.SendingSpan, packet.Identity))
                packet.SendingSpan.Length
            else
                0
        this.stats.LastSentByteCount <- uint64(byteCount) + this.stats.LastSentByteCount
        this.stats.PacketCountSinceHeartbeat <- this.stats.PacketCountSinceHeartbeat + 1

    private SendConnectionAccepted(identity: INetworkIdentity): () =
        let packet = Packet.CreateConnectionAccepted(identity)
        this.SendPacket(packet)

    private SendHeartbeat(identity: INetworkIdentity): () =
        let packet = Packet.CreateHeartbeat(identity)
        this.SendPacket(packet)

    Disconnect(identity: INetworkIdentity, reason: ClientDisconnectReason): () =
        let mutable connection = unchecked default
        if (this.connections.TryRemove(identity, &connection))
            let packet = Packet.CreateDisconnect(Unsafe.Cast(identity))
            // TODO: Should we send this multiple times?
            try
                this.SendPacket(packet)
            catch (ex: Exception) =>
                ()
            if (connection.PacketFactory !== null)
                this.onClientDisconnected(identity, reason)
            else
                let packet = Packet.CreateServerConnectionRefused(identity, reason)
                // TODO: Should we send this multiple times?
                try
                    this.SendPacket(packet)
                catch (ex: Exception) =>
                    ()
                this.onConnectionRefused(identity, reason)
        else
            let packet = Packet.CreateServerConnectionRefused(identity, reason)
            // TODO: Should we send this multiple times?
            try
                this.SendPacket(packet)
            catch (ex: Exception) =>
                ()
            this.onConnectionRefused(identity, reason)

    private ReceivePacket(): (Packet, numberOfBytesRead: int32) =
        let mutable packet = this.ReceivePacketPool.Rent()
        let numberOfBytesRead = 
            try
                let (numberOfBytesRead, identity) = this.transport.ReceiveFrom(packet.ReceivingSpan)
                packet.Identity <- identity
                if (numberOfBytesRead > 0)
                    packet.DataSize <- numberOfBytesRead - packet.HeaderSize
                    numberOfBytesRead
                else
                    0
            catch (ex: System.Net.Sockets.SocketException) =>
                if (ex.SocketErrorCode != System.Net.Sockets.SocketError.WouldBlock)
                    this.ReceivePacketPool.Return(packet)
                    throw ex
                else
                    0
            catch (ex: Exception) =>
                this.ReceivePacketPool.Return(packet)
                throw ex

        (packet, numberOfBytesRead)

    private FreeReceivedPacket(packet: Packet): () =
        this.ReceivePacketPool.Return(packet)

    private ProcessLagSimulatedPackets(): () =
        let mutable maxCountToProcess = this.lagQueue.Count
        let mutable count = 0
        while (count < maxCountToProcess)
            count <- count + 1
            let state = this.lagQueue.Dequeue()
            match (this.PacketLossSimulationRate)
            | packetLossRate when (packetLossRate > 0 && this.lagRandom.Next(0, 100) <= int32(packetLossRate)) =>
                this.FreeReceivedPacket(state.Packet)
            | _ =>
                match (this.LatencySimulationRange)
                | (start, end) when ((end > 0) && (end >= start)) =>
                    let artificialLag = float32(this.lagRandom.Next(int32(start), int32(end)))
                    if ((state.Time + (artificialLag / 1000: float32)) < this.timeSinceStart)
                        this.HandleReceivedPacket(state.Packet)
                        this.FreeReceivedPacket(state.Packet)
                    else
                        this.lagQueue.Enqueue(state)
                | _ =>
                    this.HandleReceivedPacket(state.Packet)
                    this.FreeReceivedPacket(state.Packet)

    private HandleReceivedPacket(packet: Packet): () =
        try
            this.HandlePacketAux(packet)
        catch (ex: Exception) =>
            this.Disconnect(packet.Identity, ClientDisconnectReason.MalformedPacketOrException)

    private HandlePacketAux(packet: Packet): () =
        let identity = packet.Identity
                    
        let mutable connection = unchecked default
        if (this.connections.TryGetValue(identity, &connection))
            let packetFactory = connection.PacketFactory
            if (packetFactory !== null)
                match (packet.Kind)
                | PacketKind.ConnectionRequested =>
                    ()

                | PacketKind.Heartbeat =>
                    connection.Time <- 0

                | PacketKind.Disconnect =>
                    this.Disconnect(identity, ClientDisconnectReason.ClientInitiated)

                | PacketKind.SmallUnreliable =>
                    let channel = packet.Channel
                    let bstream = ByteStream()
                    bstream.Write(packet.DataSpan)
                    bstream.ResetPosition()
                    this.onMessageReceived(identity, bstream, channel)

                | PacketKind.Unreliable 
                | PacketKind.UnreliableSequenced =>
                    let channel = packet.Channel
                    connection.Channels.GetDefragmenter(packet.Kind, channel).HandlePacket(packet.Stream,
                        (bstream, channel) ->
                            this.onMessageReceived(identity, bstream, channel)
                    )

                | PacketKind.ReliableSequenced =>
                    let channel = packet.Channel

                    let header = packet.Stream.Read<PacketMessageHeader>()
                    let seqId = header.SequenceId
                    let fragIndex = header.FragmentIndex

                    let ackPacket = Packet.CreateReliableSequencedAck(seqId, fragIndex, channel, Unsafe.Cast(identity))
                    this.SendPacket(ackPacket)

                    packet.Stream.ResetPosition()
                    connection.Channels.GetDefragmenter(PacketKind.ReliableSequenced, channel).HandlePacket(packet.Stream,
                        (bstream, channel) -> this.onMessageReceived(identity, bstream, channel)
                    )

                | PacketKind.ReliableSequencedAck =>
                    let channel = packet.Channel
                    let header = packet.Stream.Read<PacketMessageHeader>()                   
                    let acks = connection.Channels.GetAck(PacketKind.ReliableSequenced, channel)
                    if (!acks.IsAcked(header.SequenceId, header.FragmentIndex))
                        acks.Ack(header.SequenceId, header.FragmentIndex)

                | _ =>
                    ()
                    // TODO: Client message
            else
                match (packet.Kind)
                | PacketKind.ConnectionRequested =>
                    ()

                | PacketKind.Heartbeat =>
                    connection.PacketFactory <- PacketFactory()
                    connection.Time <- 0

                    this.SendHeartbeat(identity)
                    this.onClientConnected(identity)

                | _ =>
                    this.Disconnect(identity, ClientDisconnectReason.MalformedPacketOrException)
        else
            match (packet.Kind)
            | PacketKind.ConnectionRequested =>
                let connectionKey = packet.DataString
                if (connectionKey == this.connectionKey && this.onConnectionRequested(identity))
                    if (this.connections.TryAdd(identity, Connection()))
                        this.SendConnectionAccepted(identity)
                else
                    this.Disconnect(identity, ClientDisconnectReason.BadConnectionKey)
            | _ =>
                this.Disconnect(identity, ClientDisconnectReason.InvalidPacket)

    Start(
            connectionKey: string
        ): bool =
        if (this.isStarted)
            throw InvalidOperationException("Server already started.")

        this.connectionKey <- connectionKey
        this.timeSinceStart <- 0

        if (!this.transport.StartHost(this.desiredPort))
            fail("Failed to start transport")

        this.isStarted <- true
        true

    Stop(): () =
        if (!this.isStarted)
            throw InvalidOperationException("Server not started.")

        this.ForEachConnection(
            identity ->
                this.Disconnect(identity, ClientDisconnectReason.ServerInitiated)
        )
        assert(this.connections.Count == 0)
        this.isStarted <- false

        if (!this.transport.StopHost())
            fail("Failed to stop transport")

        this.lagQueue.Clear()

    ForEachConnection(f: INetworkIdentity -> ()): () =
        ForEach(this.connections,
            (mutable pair) ->
                if (pair.Value.PacketFactory !== null)
                    f(pair.Key)
        )

    private SendCore(bytes: ReadOnlySpan<byte>, channel: byte, identity: INetworkIdentity, kind: PacketKind): () =
        if (!this.isStarted)
            throw InvalidOperationException("Server not started.")

        // TODO: We need to add a limiter here so we do not send huge bursts of packets.

        let mutable connection = unchecked default
        if (this.connections.TryGetValue(identity, &connection))
            let packetFactory = connection.PacketFactory
            if (packetFactory !== null)
                let packets = packetFactory.CreatePackets(kind, channel, bytes, Unsafe.Cast(identity))

                if (kind == PacketKind.ReliableSequenced)
                    let mutable i = 0
                    while (i < packets.Length)
                        let packet = packets[i]
                        packet.Identity <- identity
                        let acks = connection.Channels.GetAck(kind, channel)
                        acks.MarkAck(packet)
                        this.SendPacket(packet)
                        i <- i + 1
                else
                    let mutable i = 0
                    while (i < packets.Length)
                        let packet = packets[i]
                        packet.Identity <- identity
                        this.SendPacket(packet)
                        i <- i + 1

    Send(bytes: ReadOnlySpan<byte>, channel: byte, identity: INetworkIdentity): () =
        this.SendCore(bytes, channel, identity, PacketKind.Unreliable)

    SendSequenced(bytes: ReadOnlySpan<byte>, channel: byte, identity: INetworkIdentity): () =
        this.SendCore(bytes, channel, identity, PacketKind.UnreliableSequenced)

    SendReliableSequenced(bytes: ReadOnlySpan<byte>, channel: byte, identity: INetworkIdentity): () =
        this.SendCore(bytes, channel, identity, PacketKind.ReliableSequenced)
        
    Heartbeat(deltaTime: float32): () =
        if (!this.isStarted)
            throw InvalidOperationException("Server not started.")

        this.stats.LastSentByteCount <- 0
        this.stats.PacketCountSinceHeartbeat <- 0

        this.identitiesToDisconnect.Clear()

        ForEach(this.connections,
            (mutable pair) ->
                let identity = pair.Key
                let connection = pair.Value
                if (connection.Time >= this.clientTimeout)
                    this.Disconnect(identity, ClientDisconnectReason.TimedOut)
                else
                    connection.Time <- connection.Time + deltaTime
                    if (connection.PacketFactory !== null)

                        ForEach(connection.Channels.AckChannels,
                            (mutable pair) ->
                                let acks = pair.Value
                                acks.Heartbeat(deltaTime,
                                    packet ->
                                        this.SendPacket(packet),
                                    identity ->
                                        let _ = this.identitiesToDisconnect.Add(identity)
                                )
                        )

                        this.SendHeartbeat(identity)
                    else
                        this.SendConnectionAccepted(identity)
        )

        ForEach(this.identitiesToDisconnect,
            identity ->
                this.Disconnect(identity, ClientDisconnectReason.AckTimedOut)
        )

        this.ProcessLagSimulatedPackets()

        let maxPacketsToRead = 1000
        let mutable packetCount = 0
        while (packetCount < maxPacketsToRead)
            let (packet, numberOfBytesRead) = this.ReceivePacket()
            if (numberOfBytesRead == 0)
                packetCount <- maxPacketsToRead
            else
                packetCount <- packetCount + 1
                if (packet.Identity !== unchecked default)
                    let mutable willFree = true

                    match (this.LatencySimulationRange)
                    | (start, end) when ((end > 0) && (end >= start)) =>
                        willFree <- false
                    | _ =>
                        ()

                    match (this.PacketLossSimulationRate)
                    | packetLossRate when (packetLossRate > 0) =>
                        willFree <- false
                    | _ =>
                        ()

                    if (willFree)
                        this.HandleReceivedPacket(packet)
                        this.FreeReceivedPacket(packet)
                    else
                        this.lagQueue.Enqueue(LagSimulatedPacket(packet, this.timeSinceStart))
                else
                    this.FreeReceivedPacket(packet)

        this.timeSinceStart <- this.timeSinceStart + deltaTime

    Dispose(): () =
        if (this.isStarted)
            this.Stop()

private class Connection =
    Time: float32 get, set = 0
    PacketFactory: PacketFactory get, set = null
    Channels: Channels get = Channels()