namespace Evergreen.Network

open System
open System.IO
open System.IO.Compression
open System.Buffers
open System.Collections.Generic
open System.Collections.Concurrent
open System.Runtime.InteropServices
open System.Security.Cryptography

open Evergreen.Utilities
open Evergreen.Network.Transport

private enum ClientConnectionStatus =
    | Disconnected = 0
    | Connecting = 1
    | Connected = 2

class NetworkClient =
    implements IDisposable

    field lockObj: object
    field mutable transport: INetworkClientTransport
    field packetFactory: PacketFactory
    field channels: Channels
    field onConnectionRequested: NetworkClient -> ()
    field onConnectionFailed: (NetworkClient, ClientDisconnectReason) -> ()
    field onConnected: NetworkClient -> ()
    field onDisconnected: (NetworkClient, ClientDisconnectReason) -> ()
    field onMessageReceived: (NetworkClient, ByteStream, channel: byte) -> ()
    field mutable connectionKey: string 
    field mutable port: int32
    field mutable connectionStatus: ClientConnectionStatus
    field mutable timeout: float32
    field mutable timeSinceHeartbeat: float32
    field mutable timeSinceConnect: float32

    field lagRandom: Random
    field mutable lagQueue: Queue<LagSimulatedPacket>
    LatencySimulationRange: (uint16, uint16) get, set
    PacketLossSimulationRate: byte get, set

    private ReceivePacketPool: PacketPool get

    new(
            onConnectionRequested: NetworkClient -> (),
            onConnectionFailed: (NetworkClient, ClientDisconnectReason) -> (),
            onConnected: NetworkClient -> (),
            onDisconnected: (NetworkClient, ClientDisconnectReason) -> (),
            onMessageReceived: (NetworkClient, ByteStream, channel: byte) -> ()) = 
        this { 
            lockObj = System.Object()
            transport = SteamClientTransport()//UdpClientTransport()
            packetFactory = PacketFactory()
            channels = Channels()
            onConnectionRequested = onConnectionRequested
            onConnectionFailed = onConnectionFailed
            onConnected = onConnected
            onDisconnected = onDisconnected
            onMessageReceived = onMessageReceived
            connectionKey = ""
            port = 0
            connectionStatus = ClientConnectionStatus.Disconnected
            timeout = 5
            timeSinceHeartbeat = 0
            timeSinceConnect = 0

            lagRandom = Random()
            lagQueue = Queue()
            LatencySimulationRange = (0, 0)
            PacketLossSimulationRate = 0
            ReceivePacketPool = PacketPool(1024)
        }

    Port: int32 get() = this.port
    IsConnecting: bool get() = this.connectionStatus == ClientConnectionStatus.Connecting
    IsConnected: bool get() = this.connectionStatus == ClientConnectionStatus.Connected

    private Close(): () =
        if (this.connectionStatus != ClientConnectionStatus.Disconnected)
            this.transport.Disconnect()

        this.connectionStatus <- ClientConnectionStatus.Disconnected
        this.port <- 0
        this.channels.Clear()
        this.packetFactory.Clear()
        this.lagQueue.Clear()

    private SendPacket(packet: Packet): () =
        let transport = this.transport

        if (packet.IsInPool)
            throw InvalidOperationException("Cannot send packet that is in the packet pool")

        // TODO: Check Packet.Identity for null as it does not need to be set as it's always the remote identity.
        // if ((packet.Identity: INetworkIdentity) !== transport.RemoteIdentity)
        //     throw InvalidOperationException("Remote end point does not match the packet's end point.")

        try
            let _ = transport.Send(packet.SendingSpan)
        catch (ex: Exception) =>
            if (this.IsConnected)
                this.DisconnectIfPossible(ClientDisconnectReason.MalformedPacketOrException)
            else
                this.OnConnectionFailed(ClientDisconnectReason.MalformedPacketOrException)

    private ReceivePacket(): (Packet, numberOfBytesRead: int32) =
        let transport = this.transport
        
        let mutable packet = this.ReceivePacketPool.Rent()
        let numberOfBytesRead = 
            try
                transport.Receive(packet.ReceivingSpan)
            catch (ex: System.Net.Sockets.SocketException) =>
                if (ex.SocketErrorCode != System.Net.Sockets.SocketError.WouldBlock)
                    this.ReceivePacketPool.Return(packet)
                    throw ex
                else
                    0
            catch (ex: Exception) =>
                this.ReceivePacketPool.Return(packet)
                throw ex

        packet.Identity <- transport.RemoteIdentity
        if (numberOfBytesRead > 0)
            let headerSize = packet.HeaderSize
            packet.DataSize <- numberOfBytesRead - headerSize
        else
            packet.DataSize <- 0
        (packet, numberOfBytesRead)

    private OnConnectionFailed(reason: ClientDisconnectReason): () =
        this.onConnectionFailed(this, reason)
        this.Close()

    private OnDisconnected(reason: ClientDisconnectReason): () =
        this.onDisconnected(this, reason)
        this.Close()

    private SendConnectionRequested(): () =
        let transport = this.transport

        let packet = Packet.CreateConnectionRequested(this.connectionKey, transport.RemoteIdentity)
        this.SendPacket(packet)

    private TrySendHeartbeat(): () =
        if (this.IsConnected || this.IsConnecting)
            let transport = this.transport

            let packet = Packet.CreateHeartbeat(transport.RemoteIdentity)
            this.SendPacket(packet)

    private SendDisconnect(): () =
        let transport = this.transport

        let packet = Packet.CreateDisconnect(transport.RemoteIdentity)
        this.SendPacket(packet)

    private SendCore(mutable bytes: ReadOnlySpan<byte>, channel: byte, kind: PacketKind): () =
        let transport = this.transport

        if (bytes.Length > NetworkPacket.MaxDataSize)
            fail("Message too large to send.")

        let packets = this.packetFactory.CreatePackets(kind, channel, bytes, transport.RemoteIdentity)
        if (packets.Length > 1)
            fail("Too many packets to send.")

        if (kind == PacketKind.ReliableSequenced)
            let acks = this.channels.GetAck(kind, channel)
            acks.MarkAck(packets[0])

        this.SendPacket(packets[0])

    Send(bytes: ReadOnlySpan<byte>, channel: byte): () =
        if (!this.IsConnected)
            throw InvalidOperationException("Client not connected.")

        this.SendCore(bytes, channel, PacketKind.Unreliable)

    SendReliableSequenced(bytes: ReadOnlySpan<byte>, channel: byte): () =
        if (!this.IsConnected)
            throw InvalidOperationException("Client not connected.")

        this.SendCore(bytes, channel, PacketKind.ReliableSequenced)

    private FreeReceivedPacket(packet: Packet): () =
        this.ReceivePacketPool.Return(packet)

    private ProcessLagSimulatedPackets(gotHeartbeat: byref<bool>): () =
        let mutable maxCountToProcess = this.lagQueue.Count
        let mutable count = 0
        while (count < maxCountToProcess)
            count <- count + 1
            let state = this.lagQueue.Dequeue()
            match (this.PacketLossSimulationRate)
            | packetLossRate when (packetLossRate > 0 && this.lagRandom.Next(0, 100) <= int32(packetLossRate)) =>
                this.FreeReceivedPacket(state.Packet)
            | _ =>
                match (this.LatencySimulationRange)
                | (start, end) when ((end > 0) && (end >= start)) =>
                    let artificialLag = float32(this.lagRandom.Next(int32(start), int32(end)))
                    if ((state.Time + (artificialLag / 1000: float32)) < this.timeSinceConnect)
                        this.HandleReceivedPacket(state.Packet, &gotHeartbeat)
                        this.FreeReceivedPacket(state.Packet)
                    else
                        this.lagQueue.Enqueue(state)
                | _ =>
                    this.HandleReceivedPacket(state.Packet, &gotHeartbeat)
                    this.FreeReceivedPacket(state.Packet)

    private HandleReceivedPacket(packet: Packet, gotHeartbeat: byref<bool>): () =
        let transport = this.transport

        if (packet.Stream.Position.Index != 0)
            fail("invalid packet stream")
        
        if (this.connectionStatus == ClientConnectionStatus.Connected)
            match (packet.Kind)
            | PacketKind.ConnectionAccepted =>
                ()

            | PacketKind.Heartbeat =>
                gotHeartbeat <- true

            | PacketKind.SmallUnreliable =>
                let channel = packet.Channel
                let bstream = ByteStream()
                bstream.Write(packet.DataSpan)
                bstream.ResetPosition()
                this.onMessageReceived(this, bstream, channel)

            | PacketKind.Unreliable =>
                let channel = packet.Channel
                this.channels.GetDefragmenter(PacketKind.Unreliable, channel).HandlePacket(packet.Stream,
                    (bstream, channel) -> this.onMessageReceived(this, bstream, channel)
                )

            | PacketKind.UnreliableSequenced =>
                let channel = packet.Channel
                this.channels.GetDefragmenter(PacketKind.UnreliableSequenced, channel).HandlePacket(packet.Stream, 
                    (bstream, channel) -> this.onMessageReceived(this, bstream, channel)
                )

            | PacketKind.ReliableSequenced =>
                let channel = packet.Channel

                let header = packet.Stream.Read<PacketMessageHeader>()
                let seqId = header.SequenceId
                let fragIndex = header.FragmentIndex

                let ackPacket = Packet.CreateReliableSequencedAck(seqId, fragIndex, channel, transport.RemoteIdentity)
                this.SendPacket(ackPacket)

                packet.Stream.ResetPosition()
                this.channels.GetDefragmenter(PacketKind.ReliableSequenced, channel).HandlePacket(packet.Stream, 
                    (bstream, channel) -> this.onMessageReceived(this, bstream, channel)
                )

            | PacketKind.ReliableSequencedAck =>
                let channel = packet.Channel

                let header = packet.Stream.Read<PacketMessageHeader>()
                let seqId = header.SequenceId
                let fragIndex = header.FragmentIndex

                let acks = this.channels.GetAck(PacketKind.ReliableSequenced, channel)
                if (!acks.IsAcked(seqId, fragIndex))
                    acks.Ack(seqId, fragIndex)

            | PacketKind.Disconnect =>
                this.DisconnectIfPossible(ClientDisconnectReason.ServerInitiated)

            | PacketKind.ServerConnectionRefused =>
                let reason = Packet.ReadServerConnectionRefused(packet)
                this.DisconnectIfPossible(reason)

            | _ =>
                LogClientError("Bad packet kind with a connection: " + packet.Kind.ToString())
                this.DisconnectIfPossible(ClientDisconnectReason.MalformedPacketOrException)
        else
            match (packet.Kind)
            | PacketKind.ConnectionAccepted =>
                this.TrySendHeartbeat()

            | PacketKind.Heartbeat =>
                if (this.connectionStatus == ClientConnectionStatus.Connecting)
                    this.connectionStatus <- ClientConnectionStatus.Connected
                    this.onConnected(this)

            | PacketKind.ServerConnectionRefused =>
                let reason = Packet.ReadServerConnectionRefused(packet)
                this.DisconnectIfPossible(reason)

            | _ =>
                LogClientError("Bad packet kind: " + packet.Kind.ToString())
                this.DisconnectIfPossible(ClientDisconnectReason.MalformedPacketOrException)

    Connect(serverIdentity: string, port: int32, connectionKey: string): () =
        if (this.connectionStatus != ClientConnectionStatus.Disconnected)
            fail("Client already connected or awaiting connection.")

        this.timeSinceConnect <- 0

        try
            this.connectionKey <- connectionKey
            this.port <- port
            this.timeSinceHeartbeat <- 0
            if (!this.transport.Connect(serverIdentity, port))
                fail("Failed to connect to server.")
            this.connectionStatus <- ClientConnectionStatus.Connecting
            this.SendConnectionRequested()
            this.onConnectionRequested(this)
        catch (ex: Exception) =>
            LogClientError("Connection failure: " + ex.Message)
            this.OnConnectionFailed(ClientDisconnectReason.MalformedPacketOrException)

    Heartbeat(deltaTime: float32): () =
        let transport = this.transport

        if (transport.RemoteIdentity === null)
            throw InvalidOperationException("Client has not attempted connection.")   
        try
            this.HeartbeatAux(deltaTime)
        catch (ex: Exception) =>
            LogClientError("Heartbeat: " + ex.Message)
            // 'this.transport' can be null if Close() was called.
            if (this.transport !== null)
                if (this.IsConnected)
                    this.DisconnectIfPossible(ClientDisconnectReason.MalformedPacketOrException)
                else
                    this.OnConnectionFailed(ClientDisconnectReason.MalformedPacketOrException)

    private HeartbeatAux(deltaTime: float32): () =
        if (this.IsConnected)
            this.TrySendHeartbeat()
            ForEach(this.channels.AckChannels.Values,
                acks ->
                    acks.Heartbeat(deltaTime,
                        packet ->
                            this.SendPacket(packet),
                        (_) ->
                            this.DisconnectIfPossible(ClientDisconnectReason.AckTimedOut)
                    )
            )
        else
            this.SendConnectionRequested()

        if (this.IsConnected || this.IsConnecting)
            let mutable gotHeartbeat = false
            this.ProcessLagSimulatedPackets(&gotHeartbeat) 

            let maxPacketsToRead = 1000
            let mutable packetCount = 0
            while (packetCount < maxPacketsToRead)
                let (packet, numberOfBytesRead) = this.ReceivePacket()
                if (numberOfBytesRead == 0)
                    packetCount <- maxPacketsToRead
                else
                    packetCount <- packetCount + 1
                    if (packet.Identity !== unchecked default)
                        let mutable willFree = true

                        match (this.LatencySimulationRange)
                        | (start, end) when ((end > 0) && (end >= start)) =>
                            willFree <- false
                        | _ =>
                            ()

                        match (this.PacketLossSimulationRate)
                        | packetLossRate when (packetLossRate > 0) =>
                            willFree <- false
                        | _ =>
                            ()

                        if (willFree)
                            this.HandleReceivedPacket(packet, &gotHeartbeat)
                            this.FreeReceivedPacket(packet)
                        else
                            this.lagQueue.Enqueue(LagSimulatedPacket(packet, this.timeSinceConnect))
                    else
                        this.FreeReceivedPacket(packet)

                if (gotHeartbeat)
                    this.timeSinceHeartbeat <- 0
                else
                    this.timeSinceHeartbeat <- this.timeSinceHeartbeat + deltaTime

                if (this.timeSinceHeartbeat >= this.timeout)
                    if (this.IsConnected)
                        this.DisconnectIfPossible(ClientDisconnectReason.TimedOut)
                    else
                        this.OnConnectionFailed(ClientDisconnectReason.TimedOut)
                    throw NetworkTimedOutException()

                this.timeSinceConnect <- this.timeSinceConnect + deltaTime

    DisconnectIfPossible(reason: ClientDisconnectReason): () =
        if (this.IsConnected || this.IsConnecting)
            if (this.IsConnected)
                this.SendDisconnect()
                this.OnDisconnected(reason)
            else
                this.OnConnectionFailed(reason)

    RemoteIdentity: string
        get() =
            if (this.connectionStatus == ClientConnectionStatus.Disconnected)
                String.Empty
            else
                this.transport.RemoteIdentity.AsString()

    Dispose(): () =
        this.DisconnectIfPossible(ClientDisconnectReason.ClientInitiated)
        this.Close()
