namespace Evergreen.Collections

open System
open System.IO
open System.Text
open System.Text.Json
open System.Numerics
open System.Diagnostics
open System.Collections.Generic
open System.Collections.Concurrent
open System.Runtime.InteropServices

open Evergreen.Utilities

struct EntityId =
    public field mutable Index: int32 = 0
    public field mutable Version: uint32 = 0

    IsNil: bool get() = this.Version == 0

    overrides mutable ToString(): string = 
        "<" + this.Index.ToString() + ", " + this.Version.ToString() + ">"

    Encode(): uint64 =
        let mutable value = uint64(this.Index)
        value <- value | (uint64(this.Version) << 32)
        value

    static Decode(value: uint64): EntityId =
        let index = int32((value << 32) >> 32)
        let version = uint32(value >> 32)
        let mutable entId = EntityId()
        entId.Index <- index
        entId.Version <- version
        entId

    static Nil: EntityId get = EntityId()

    static op_Equality(entId1: EntityId, entId2: EntityId): bool =
        entId1.Index == entId2.Index && entId1.Version == entId2.Version

    static op_Inequality(entId1: EntityId, entId2: EntityId): bool =
        entId1.Index != entId2.Index || entId1.Version != entId2.Version

    static Comparer: IEqualityComparer<EntityId> get =
        class Impl =
            implements IEqualityComparer<EntityId>

            GetHashCode(entityId: EntityId): int32 = entityId.Index

            Equals(entityId1: EntityId, entityId2: EntityId): bool =
                entityId1.Version == entityId2.Version
        Impl()

    static Write(stream: ByteStream, entId: EntityId): () =
        stream.Write<uint16>(uint16(entId.Index))
        stream.Write<uint32>(entId.Version)

    static Read(stream: ByteStream): EntityId =
        let mutable entId = EntityId()
        entId.Index <- int32(stream.Read<uint16>())
        entId.Version <- stream.Read<uint32>()
        entId

alias ComponentId = BitSet512

alias JsonFieldWriteMappings = Dictionary<string, (fieldName: string, fieldType: Type, src: ReadOnlySpan<byte>, Utf8JsonWriter) -> ()>

alias JsonFieldReadMappings = Dictionary<string, (mappedFieldName: string, componentType: Type, dst: Span<byte>, byref<Utf8JsonReader>) -> string>

interface IComponent =

    static abstract GetName(): string

    static abstract GetIndex(): int32

    static abstract GetId(): ComponentId

    static abstract GetSize(): int32

    static abstract GetType(): Type

    static abstract SerializeDeltaForNetwork(prevSrc: ReadOnlySpan<byte>, src: ReadOnlySpan<byte>, bstream: ByteStream): ()

    static abstract DeserializeDeltaForNetwork(bstream: ByteStream, dst: Span<byte>): ()

interface IComponent<N, T> where N: constant int32 where T: blittable, struct, ValueType, { new() } =
    inherits IComponent

    static overrides GetIndex(): int32 = N

    static overrides GetId(): ComponentId = BitSet512.FromIndex(N)

    static overrides GetType(): Type = DotNet.TypeOf<T>

    static overrides GetSize(): int32 = DotNet.SizeOf<T>

    static overrides GetName(): string = (DotNet.TypeOf<T>).Name

    static overrides SerializeDeltaForNetwork(prevSrc: ReadOnlySpan<byte>, src: ReadOnlySpan<byte>, bstream: ByteStream): () =
        bstream.Write(src)

    static overrides DeserializeDeltaForNetwork(bstream: ByteStream, dst: Span<byte>): () =
        bstream.Read(dst)

newtype EntityDatabaseNetworkAdapterState =
    internal field Value: Dictionary<int32, int32>

    static Create(): EntityDatabaseNetworkAdapterState = EntityDatabaseNetworkAdapterState(Dictionary())

    Reset(): () =
        this.Value.Clear()

module BuiltInComponents =

    struct ServerSide =
        implements IComponent<0, ServerSide>

    struct ClientSide =
        implements IComponent<1, ClientSide>

enum EntityDatabaseKind =
    | Server
    | Client

internal module TypeHelpers =

    field Vector2: Type = DotNet.TypeOf<Vector2>
    field Vector3: Type = DotNet.TypeOf<Vector3>
    field Vector4: Type = DotNet.TypeOf<Vector4>
    field Quaternion: Type = DotNet.TypeOf<Quaternion>
    field Matrix4x4: Type = DotNet.TypeOf<Matrix4x4>
    field Byte: Type = DotNet.TypeOf<byte>
    field SByte: Type = DotNet.TypeOf<int8>
    field UShort: Type = DotNet.TypeOf<uint16>
    field Short: Type = DotNet.TypeOf<int16>
    field UInt: Type = DotNet.TypeOf<uint32>
    field Int: Type = DotNet.TypeOf<int32>
    field ULong: Type = DotNet.TypeOf<uint64>
    field Long: Type = DotNet.TypeOf<int64>
    field Float: Type = DotNet.TypeOf<float32>
    field Double: Type = DotNet.TypeOf<float64>
    field EntityIdType: Type = DotNet.TypeOf<EntityId>

    private GetEnumValue(enumTy: Type, span: ReadOnlySpan<byte>): object =
        let ty = enumTy.GetEnumUnderlyingType()
        if (ty == TypeHelpers.Byte)
            let value = MemoryMarshal.Cast<byte, byte>(span)[0]
            Enum.ToObject(enumTy, value)
        else if (ty == TypeHelpers.SByte)
            let value = MemoryMarshal.Cast<byte, int8>(span)[0]
            Enum.ToObject(enumTy, value)
        else if (ty == TypeHelpers.UShort)
            let value = MemoryMarshal.Cast<byte, uint16>(span)[0]
            Enum.ToObject(enumTy, value)
        else if (ty == TypeHelpers.Short)
            let value = MemoryMarshal.Cast<byte, int16>(span)[0]
            Enum.ToObject(enumTy, value)
        else if (ty == TypeHelpers.UInt)
            let value = MemoryMarshal.Cast<byte, uint32>(span)[0]
            Enum.ToObject(enumTy, value)
        else if (ty == TypeHelpers.Int)
            let value = MemoryMarshal.Cast<byte, int32>(span)[0]
            Enum.ToObject(enumTy, value)
        else if (ty == TypeHelpers.ULong)
            let value = MemoryMarshal.Cast<byte, uint64>(span)[0]
            Enum.ToObject(enumTy, value)
        else if (ty == TypeHelpers.Long)
            let mutable value = MemoryMarshal.Cast<byte, int64>(span)[0]
            Enum.ToObject(enumTy, value)
        else
            fail("Invalid underlying enum type")

    ReadStartObject(reader: byref<Utf8JsonReader>): () =
        if (reader.TokenType != JsonTokenType.StartObject)
            fail("Expected start object")
        let _ = reader.Read()

    ReadEndObject(reader: byref<Utf8JsonReader>): () =
        if (reader.TokenType != JsonTokenType.EndObject)
            fail("Expected start object")
        let _ = reader.Read()

    IsNextObjectQuaternion(reader: byref<Utf8JsonReader>): bool =
        let prevReader = reader
        ReadStartObject(&reader)
        match (reader.TokenType)
        | JsonTokenType.PropertyName =>
            let propName = reader.GetString()
            reader <- prevReader
            propName == "W"
        | _ =>
            reader <- prevReader
            false

    Read<T>(isStrict: bool, mutable span: Span<byte>, reader: byref<Utf8JsonReader>, f: scoped (propName: string, byref<T>, byref<Utf8JsonReader>) -> ()): () where T: blittable, struct, ValueType, { new() } =
        let expectedProps = HashSet<string>()
        let ty = DotNet.TypeOf<T>
        ForEach(ty.GetFields(),
            fieldInfo ->
                let _ = expectedProps.Add(fieldInfo.Name)
        )
        
        let actualProps = HashSet<string>()

        ReadStartObject(&reader)

        let value = &MemoryMarshal.Cast<byte, T>(span)[0]
        while (reader.TokenType != JsonTokenType.EndObject)
            match (reader.TokenType)
            | JsonTokenType.PropertyName =>
                let propName = reader.GetString()
                let _ = actualProps.Add(propName)
                //if (actualProps.Add(propName))
                  //  fail("Duplicate property defined: " + propName)
                let _ = reader.Read()
                f(propName, &value, &reader)
                let _ = reader.Read()
            | _ =>
                fail("Invalid json token type")
        
        ReadEndObject(&reader)

        if (isStrict)
            expectedProps.ExceptWith(actualProps)
            if (expectedProps.Count > 0)
                let strBuilder = StringBuilder()
                ForEach(expectedProps,
                    propName ->
                        let _ = strBuilder.Append(propName + "\n")
                )
                fail("Missing properties for type '" + ty.Name + "':\n" + strBuilder.ToString())

    Read(isStrict: bool, nameToIndex: Dictionary<string, int32>, lookup: JsonFieldReadMappings, ty: Type, mutable span: Span<byte>, reader: byref<Utf8JsonReader>): () =
        if (ty == TypeHelpers.EntityIdType && nameToIndex.Count > 0)
            fail("not ready yet")
        else if (ty == TypeHelpers.Vector2)
            Read<Vector2>(isStrict, span, &reader,
                (propName, value, reader) ->
                    match (propName)
                    | "X" => value.X <- reader.GetSingle()
                    | "Y" => value.Y <- reader.GetSingle()
                    | _ => fail("Unexpected property")
            )
        else if (ty == TypeHelpers.Vector3)
            Read<Vector3>(isStrict, span, &reader,
                (propName, value, reader) ->
                    match (propName)
                    | "X" => value.X <- reader.GetSingle()
                    | "Y" => value.Y <- reader.GetSingle()
                    | "Z" => value.Z <- reader.GetSingle()
                    | _ => fail("Unexpected property")
            )
        else if (ty == TypeHelpers.Vector4)
            Read<Vector4>(isStrict, span, &reader,
                (propName, value, reader) ->
                    match (propName)
                    | "X" => value.X <- reader.GetSingle()
                    | "Y" => value.Y <- reader.GetSingle()
                    | "Z" => value.Z <- reader.GetSingle()
                    | "W" => value.W <- reader.GetSingle()
                    | _ => fail("Unexpected property")
            )
        else if (ty == TypeHelpers.Quaternion)
            if (IsNextObjectQuaternion(&reader))
                Read<Quaternion>(isStrict, span, &reader,
                    (propName, value, reader) ->
                        match (propName)
                        | "X" => value.X <- reader.GetSingle()
                        | "Y" => value.Y <- reader.GetSingle()
                        | "Z" => value.Z <- reader.GetSingle()
                        | "W" => value.W <- reader.GetSingle()
                        | _ => fail("Unexpected property")
                )
            else
                Read<Vector3>(isStrict, span, &reader,
                    (propName, value, reader) ->
                        match (propName)
                        | "X" => value.X <- reader.GetSingle()
                        | "Y" => value.Y <- reader.GetSingle()
                        | "Z" => value.Z <- reader.GetSingle()
                        | _ => fail("Unexpected property")
                )
                let value = MemoryMarshal.Cast<byte, Vector3>(span)[0]
                let realValue = &MemoryMarshal.Cast<byte, Quaternion>(span)[0]
                let mX = System.Numerics.Matrix4x4.CreateRotationX(radians(value.X))
                let mY = System.Numerics.Matrix4x4.CreateRotationY(radians(value.Y))
                let mZ = System.Numerics.Matrix4x4.CreateRotationZ(radians(value.Z))
                realValue <- System.Numerics.Quaternion.CreateFromRotationMatrix(mX * mY * mZ)
        else if (ty == TypeHelpers.Matrix4x4)
            Read<Matrix4x4>(isStrict, span, &reader,
                (propName, value, reader) ->
                    match (propName)
                    | "M11" => value.M11 <- reader.GetSingle()
                    | "M12" => value.M12 <- reader.GetSingle()
                    | "M13" => value.M13 <- reader.GetSingle()
                    | "M14" => value.M14 <- reader.GetSingle()
                    | "M21" => value.M21 <- reader.GetSingle()
                    | "M22" => value.M22 <- reader.GetSingle()
                    | "M23" => value.M23 <- reader.GetSingle()
                    | "M24" => value.M24 <- reader.GetSingle()
                    | "M31" => value.M31 <- reader.GetSingle()
                    | "M32" => value.M32 <- reader.GetSingle()
                    | "M33" => value.M33 <- reader.GetSingle()
                    | "M34" => value.M34 <- reader.GetSingle()
                    | "M41" => value.M41 <- reader.GetSingle()
                    | "M42" => value.M42 <- reader.GetSingle()
                    | "M43" => value.M43 <- reader.GetSingle()
                    | "M44" => value.M44 <- reader.GetSingle()
                    | _ => fail("Unexpected property")
            )
        else if (ty == TypeHelpers.Byte)            
            let value = &MemoryMarshal.Cast<byte, byte>(span)[0]
            value <- reader.GetByte()
            let _ = reader.Read()
        else if (ty == TypeHelpers.SByte)
            let value = &MemoryMarshal.Cast<byte, int8>(span)[0]
            value <- reader.GetSByte()
            let _ = reader.Read()
        else if (ty == TypeHelpers.UShort)
            let value = &MemoryMarshal.Cast<byte, uint16>(span)[0]
            value <- reader.GetUInt16()
            let _ = reader.Read()
        else if (ty == TypeHelpers.Short)
            let value = &MemoryMarshal.Cast<byte, int16>(span)[0]
            value <- reader.GetInt16()
            let _ = reader.Read()
        else if (ty == TypeHelpers.UInt)
            let value = &MemoryMarshal.Cast<byte, uint32>(span)[0]
            value <- reader.GetUInt32()
            let _ = reader.Read()
        else if (ty == TypeHelpers.Int)
            let value = &MemoryMarshal.Cast<byte, int32>(span)[0]
            value <- reader.GetInt32()
            let _ = reader.Read()
        else if (ty == TypeHelpers.ULong)
            let value = &MemoryMarshal.Cast<byte, uint64>(span)[0]
            value <- reader.GetUInt64()
            let _ = reader.Read()
        else if (ty == TypeHelpers.Long)
            let value = &MemoryMarshal.Cast<byte, int64>(span)[0]
            value <- reader.GetInt64()
            let _ = reader.Read()
        else if (ty == TypeHelpers.Float)
            let value = &MemoryMarshal.Cast<byte, float32>(span)[0]
            value <- reader.GetSingle()
            let _ = reader.Read()
        else if (ty == TypeHelpers.Double)
            let value = &MemoryMarshal.Cast<byte, float64>(span)[0]
            value <- reader.GetDouble()
            let _ = reader.Read()
        else if (ty.IsEnum)
            let name = reader.GetString()
            let valueObj = Enum.Parse(ty, name)
            let ty = ty.GetEnumUnderlyingType()
            if (ty == TypeHelpers.Byte)
                let value = &MemoryMarshal.Cast<byte, byte>(span)[0]
                value <- Convert.ToByte(valueObj)
            else if (ty == TypeHelpers.SByte)
                let value = &MemoryMarshal.Cast<byte, int8>(span)[0]
                value <- Convert.ToSByte(valueObj)
            else if (ty == TypeHelpers.UShort)
                let value = &MemoryMarshal.Cast<byte, uint16>(span)[0]
                value <- Convert.ToUInt16(valueObj)
            else if (ty == TypeHelpers.Short)
                let value = &MemoryMarshal.Cast<byte, int16>(span)[0]
                value <- Convert.ToInt16(valueObj)
            else if (ty == TypeHelpers.UInt)
                let value = &MemoryMarshal.Cast<byte, uint32>(span)[0]
                value <- Convert.ToUInt32(valueObj)
            else if (ty == TypeHelpers.Int)
                let value = &MemoryMarshal.Cast<byte, int32>(span)[0]
                value <- Convert.ToInt32(valueObj)
            else if (ty == TypeHelpers.ULong)
                let value = &MemoryMarshal.Cast<byte, uint64>(span)[0]
                value <- Convert.ToUInt64(valueObj)
            else if (ty == TypeHelpers.Long)
                let mutable value = &MemoryMarshal.Cast<byte, int64>(span)[0]
                value <- Convert.ToInt64(valueObj)
            else
                fail("Invalid underlying enum type")
            let _ = reader.Read()
        else
            let expectedProps = HashSet<string>()
            ForEach(ty.GetFields(),
                fieldInfo ->
                    let _ = expectedProps.Add(fieldInfo.Name)
            )
            
            let actualProps = HashSet<string>()

            ReadStartObject(&reader)
            while (reader.TokenType != JsonTokenType.EndObject)
                match (reader.TokenType)
                | JsonTokenType.PropertyName =>
                    let fldName = reader.GetString()
                    let _ = reader.Read()

                    let mutable read = unchecked default
                    if (lookup.TryGetValue(fldName, &read))
                        let realFldName = read(fldName, ty, span, &reader)
                        let _ = actualProps.Add(realFldName)
                        let _ = reader.Read()
                    else
                        let fld = ty.GetField(fldName)
                        if (fld !== null)
                            let fldTy = fld.FieldType
                
                            let size =
                                if (fldTy.IsEnum)
                                    Marshal.SizeOf(Enum.GetUnderlyingType(fldTy))
                                else
                                    Marshal.SizeOf(fldTy)

                            let offset = int32(Marshal.OffsetOf(ty, fldName))

                            let span = span.Slice(offset, size)
                            TypeHelpers.Read(isStrict, nameToIndex, lookup, fldTy, span, &reader)
                            let _ = actualProps.Add(fldName)
                        else
                            LogError("Unable to deserialize field '" + fldName + "'")
                            reader.Skip()
                            let _ = reader.Read()
                | _ =>
                    fail("Invalid json token type")
            ReadEndObject(&reader)

            if (isStrict)
                expectedProps.ExceptWith(actualProps)
                if (expectedProps.Count > 0)
                    let strBuilder = StringBuilder()
                    ForEach(expectedProps,
                        propName ->
                            // TODO: 'propName' is the actual field on the type, but not what is presented in JSON.
                            //       Ex: ImageId => Texture
                            //       We display "ImageId" if there is an error. Consider printing "Texture" instead.
                            let _ = strBuilder.Append(propName + "\n")
                    )
                    fail("Missing properties for type '" + ty.Name + "':\n" + strBuilder.ToString())

    Write(lookup: JsonFieldWriteMappings, ty: Type, mutable span: ReadOnlySpan<byte>, writer: Utf8JsonWriter): () =
        if (ty == TypeHelpers.Vector2) 
            let value = MemoryMarshal.Cast<byte, Vector2>(span)[0]
            writer.WriteStartObject()
            writer.WritePropertyName("X")
            writer.WriteNumberValue(value.X)
            writer.WritePropertyName("Y")
            writer.WriteNumberValue(value.Y)
            writer.WriteEndObject()
        else if (ty == TypeHelpers.Vector3)
            let value = MemoryMarshal.Cast<byte, Vector3>(span)[0]
            writer.WriteStartObject()
            writer.WritePropertyName("X")
            writer.WriteNumberValue(value.X)
            writer.WritePropertyName("Y")
            writer.WriteNumberValue(value.Y)
            writer.WritePropertyName("Z")
            writer.WriteNumberValue(value.Z)
            writer.WriteEndObject()
        else if (ty == TypeHelpers.Vector4)
            let value = MemoryMarshal.Cast<byte, Vector4>(span)[0]
            writer.WriteStartObject()
            writer.WritePropertyName("X")
            writer.WriteNumberValue(value.X)
            writer.WritePropertyName("Y")
            writer.WriteNumberValue(value.Y)
            writer.WritePropertyName("Z")
            writer.WriteNumberValue(value.Z)
            writer.WritePropertyName("W")
            writer.WriteNumberValue(value.W)
            writer.WriteEndObject()
        else if (ty == TypeHelpers.Quaternion)
            let value = MemoryMarshal.Cast<byte, Quaternion>(span)[0]
            //let value = value.ToEulerAngles()
            writer.WriteStartObject()
            // writer.WritePropertyName("X")
            // writer.WriteNumberValue(snapWithinThreeDigits(degrees(value.X)))
            // writer.WritePropertyName("Y")
            // writer.WriteNumberValue(snapWithinThreeDigits(degrees(value.Y)))
            // writer.WritePropertyName("Z")
            // writer.WriteNumberValue(snapWithinThreeDigits(degrees(value.Z)))
            writer.WritePropertyName("W")
            writer.WriteNumberValue(value.W)
            writer.WritePropertyName("X")
            writer.WriteNumberValue(value.X)
            writer.WritePropertyName("Y")
            writer.WriteNumberValue(value.Y)
            writer.WritePropertyName("Z")
            writer.WriteNumberValue(value.Z)
            writer.WriteEndObject()
        else if (ty == TypeHelpers.Matrix4x4)
            let value = MemoryMarshal.Cast<byte, Matrix4x4>(span)[0]
            writer.WriteStartObject()

            writer.WritePropertyName("M11")
            writer.WriteNumberValue(value.M11)
            writer.WritePropertyName("M12")
            writer.WriteNumberValue(value.M12)
            writer.WritePropertyName("M13")
            writer.WriteNumberValue(value.M13)
            writer.WritePropertyName("M14")
            writer.WriteNumberValue(value.M14)

            writer.WritePropertyName("M21")
            writer.WriteNumberValue(value.M21)
            writer.WritePropertyName("M22")
            writer.WriteNumberValue(value.M22)
            writer.WritePropertyName("M23")
            writer.WriteNumberValue(value.M23)
            writer.WritePropertyName("M24")
            writer.WriteNumberValue(value.M14)

            writer.WritePropertyName("M31")
            writer.WriteNumberValue(value.M31)
            writer.WritePropertyName("M32")
            writer.WriteNumberValue(value.M32)
            writer.WritePropertyName("M33")
            writer.WriteNumberValue(value.M33)
            writer.WritePropertyName("M34")
            writer.WriteNumberValue(value.M34)

            writer.WritePropertyName("M41")
            writer.WriteNumberValue(value.M41)
            writer.WritePropertyName("M42")
            writer.WriteNumberValue(value.M42)
            writer.WritePropertyName("M43")
            writer.WriteNumberValue(value.M43)
            writer.WritePropertyName("M44")
            writer.WriteNumberValue(value.M14)

            writer.WriteEndObject()
        else if (ty == TypeHelpers.Byte)
            let mutable value = MemoryMarshal.Cast<byte, byte>(span)[0]
            writer.WriteNumberValue(uint32(value))
        else if (ty == TypeHelpers.SByte)
            let mutable value = MemoryMarshal.Cast<byte, int8>(span)[0]
            writer.WriteNumberValue(int32(value))
        else if (ty == TypeHelpers.UShort)
            let mutable value = MemoryMarshal.Cast<byte, uint16>(span)[0]
            writer.WriteNumberValue(uint32(value))
        else if (ty == TypeHelpers.Short)
            let mutable value = MemoryMarshal.Cast<byte, int16>(span)[0]
            writer.WriteNumberValue(int32(value))
        else if (ty == TypeHelpers.UInt)
            let mutable value = MemoryMarshal.Cast<byte, uint32>(span)[0]
            writer.WriteNumberValue(value)
        else if (ty == TypeHelpers.Int)
            let mutable value = MemoryMarshal.Cast<byte, int32>(span)[0]
            writer.WriteNumberValue(value)
        else if (ty == TypeHelpers.ULong)
            let mutable value = MemoryMarshal.Cast<byte, uint64>(span)[0]
            writer.WriteNumberValue(value)
        else if (ty == TypeHelpers.Long)
            let mutable value = MemoryMarshal.Cast<byte, int64>(span)[0]
            writer.WriteNumberValue(value)
        else if (ty == TypeHelpers.Float)
            let mutable value = MemoryMarshal.Cast<byte, float32>(span)[0]
            writer.WriteNumberValue(value)
        else if (ty == TypeHelpers.Double)
            let mutable value = MemoryMarshal.Cast<byte, float64>(span)[0]
            writer.WriteNumberValue(value)
        else if (ty.IsEnum)
            writer.WriteStringValue(GetEnumValue(ty, span).ToString())
        else
            writer.WriteStartObject()
            let fields = filter(ty.GetFields(), x -> !x.IsStatic)
            ForEach(fields,
                fld ->
                    let fldName = fld.Name

                    let fldTy = fld.FieldType
        
                    let size =
                        if (fldTy.IsEnum)
                            Marshal.SizeOf(Enum.GetUnderlyingType(fldTy))
                        else
                            Marshal.SizeOf(fldTy)

                    let offset = int32(Marshal.OffsetOf(ty, fldName))
    
                    let span = span.Slice(offset, size)

                    let mutable write = unchecked default
                    if (lookup.TryGetValue(fldName, &write))
                        write(fldName, fldTy, span, writer)
                    else
                        writer.WritePropertyName(fldName)
                        TypeHelpers.Write(lookup, fld.FieldType, span, writer)
            )
            writer.WriteEndObject()

    ReadEntityId(json: byref<Utf8JsonReader>): EntityId =
        let mutable entId = EntityId.Nil
        ReadStartObject(&json)
        if (json.TokenType != JsonTokenType.PropertyName)
            fail("Expected PropertyName")
        let _ = json.Read()
        entId.Index <- json.GetInt32()
        let _ = json.Read()
        if (json.TokenType != JsonTokenType.PropertyName)
            fail("Expected PropertyName")
        let _ = json.Read()
        entId.Version <- json.GetUInt32()
        let _ = json.Read()
        ReadEndObject(&json)
        entId

    TryReadPropertyEntityId(propName: string, json: byref<Utf8JsonReader>, outEntId: byref<EntityId>): bool =
        if (json.TokenType != JsonTokenType.PropertyName)
            false
        else
            ()
            if (json.GetString() != propName)
                false
            else
                let _ = json.Read()
                outEntId <- ReadEntityId(&json)
                true

    WriteEntity(json: byref<Utf8JsonWriter>, entId: EntityId): () =
        json.WriteStartObject()
        json.WritePropertyName("Index")
        json.WriteNumberValue(entId.Index)
        json.WritePropertyName("Version")
        json.WriteNumberValue(entId.Version)
        json.WriteEndObject()

alias ArchetypeId = BitSet512

#[open]
internal module Helpers =

    GetArchetypeId<T0>(): ArchetypeId where T0: trait IComponent = T0.GetId()

    GetArchetypeId<T0, T1>(): ArchetypeId where T0: trait IComponent where T1: trait IComponent = T0.GetId() | T1.GetId()

    GetArchetypeId<T0, T1, T2>(): ArchetypeId where T0: trait IComponent where T1: trait IComponent where T2: trait IComponent = T0.GetId() | T1.GetId() | T2.GetId()

    GetArchetypeId<T0, T1, T2, T3>(): ArchetypeId where T0: trait IComponent where T1: trait IComponent where T2: trait IComponent where T3: trait IComponent = T0.GetId() | T1.GetId() | T2.GetId() | T3.GetId()

    GetArchetypeId<T0, T1, T2, T3, T4>(): ArchetypeId where T0: trait IComponent where T1: trait IComponent where T2: trait IComponent where T3: trait IComponent where T4: trait IComponent = T0.GetId() | T1.GetId() | T2.GetId() | T3.GetId() | T4.GetId()

    GetArchetypeId<T0, T1, T2, T3, T4, T5>(): ArchetypeId where T0: trait IComponent where T1: trait IComponent where T2: trait IComponent where T3: trait IComponent where T4: trait IComponent where T5: trait IComponent = T0.GetId() | T1.GetId() | T2.GetId() | T3.GetId() | T4.GetId() | T5.GetId()

    GetArchetypeId<T0, T1, T2, T3, T4, T5, T6>(): ArchetypeId where T0: trait IComponent where T1: trait IComponent where T2: trait IComponent where T3: trait IComponent where T4: trait IComponent where T5: trait IComponent where T6: trait IComponent = T0.GetId() | T1.GetId() | T2.GetId() | T3.GetId() | T4.GetId() | T5.GetId() | T6.GetId()

    GetArchetypeId<T0, T1, T2, T3, T4, T5, T6, T7>(): ArchetypeId where T0: trait IComponent where T1: trait IComponent where T2: trait IComponent where T3: trait IComponent where T4: trait IComponent where T5: trait IComponent where T6: trait IComponent where T7: trait IComponent = T0.GetId() | T1.GetId() | T2.GetId() | T3.GetId() | T4.GetId() | T5.GetId() | T6.GetId() | T7.GetId()

    GetArchetypeId<T0, T1, T2, T3, T4, T5, T6, T7, T8>(): ArchetypeId where T0: trait IComponent where T1: trait IComponent where T2: trait IComponent where T3: trait IComponent where T4: trait IComponent where T5: trait IComponent where T6: trait IComponent where T7: trait IComponent where T8: trait IComponent = T0.GetId() | T1.GetId() | T2.GetId() | T3.GetId() | T4.GetId() | T5.GetId() | T6.GetId() | T7.GetId() | T8.GetId()

    GetArchetypeId<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(): ArchetypeId where T0: trait IComponent where T1: trait IComponent where T2: trait IComponent where T3: trait IComponent where T4: trait IComponent where T5: trait IComponent where T6: trait IComponent where T7: trait IComponent where T8: trait IComponent where T9: trait IComponent = T0.GetId() | T1.GetId() | T2.GetId() | T3.GetId() | T4.GetId() | T5.GetId() | T6.GetId() | T7.GetId() | T8.GetId() | T9.GetId()

    GetComponentIds(archetypeId: ArchetypeId): ComponentId[] =
        let bytes = archetypeId.ToBytes()

        // TODO: Do we need to optimize this?
        let bitArray = System.Collections.BitArray(bytes)
        let tyIds = List<ComponentId>()            
        let mutable i = 0
        while (i < bitArray.Count)
            if (bitArray.Get(i))
                tyIds.Add(BitSet512.FromIndex(i))
            i <- i + 1
        Unsafe.AsImmutable(tyIds.ToArray())

internal class ChunkedItemStore<MaxItemCount, ItemsPerChunk> 
        where MaxItemCount: constant int32
        where ItemsPerChunk: constant int32 =

    field chunks: mutable (mutable byte[])[]
    field mutable chunkCount: int32

    ItemSize: int32 get
    Length: int32
        get() =
            if (this.chunkCount == 0)
                0
            else
                let mutable length = 0
                For(this.chunkCount,
                    i ->
                        let chunk = this.chunks[i]
                        length <- length + chunk.Length
                )
                length

    new(itemSize: int32) =
        {
            ItemSize = itemSize
            chunks = zeroArray(MaxItemCount / ItemsPerChunk)
            chunkCount = 0
        }

    EnsureCapacity(count: int32): () =
        if (count > (this.chunkCount * ItemsPerChunk))
            this.chunks[this.chunkCount] <- zeroArray(this.ItemSize * ItemsPerChunk)
            this.chunkCount<- this.chunkCount + 1
            this.EnsureCapacity(count)

    private GetChunkByItemIndex(index: int32): mutable byte[] =
        this.chunks[index / ItemsPerChunk]

    Clear(): () =
        let mutable i = 0
        while (i < this.chunkCount)
            Span(this.chunks[i]).Clear()
            i <- i + 1 

    ClearAt(index: int32): () =
        Span(this.GetChunkByItemIndex(index), (index % ItemsPerChunk) * this.ItemSize, this.ItemSize).Clear()

    CopyTo(dst: ChunkedItemStore<MaxItemCount, ItemsPerChunk>, count: int32): () =
        if (count > 0)
            let chunkCount = (count / ItemsPerChunk) + 1

            let mutable remainingCount = count

            let mutable i = 0
            while (i < chunkCount)
                if (i == chunkCount - 1)
                    let size = remainingCount * this.ItemSize
                    Span(this.chunks[i], 0, size).CopyTo(Span(dst.chunks[i]))
                else
                    remainingCount <- remainingCount - ItemsPerChunk
                    Span(this.chunks[i], 0, ItemsPerChunk * this.ItemSize).CopyTo(Span(dst.chunks[i]))
                i <- i + 1

    CopyOneTo(srcIndex: int32, dst: ChunkedItemStore<MaxItemCount, ItemsPerChunk>, dstIndex: int32): () =
        Span(this.GetChunkByItemIndex(srcIndex), (srcIndex % ItemsPerChunk) * this.ItemSize, this.ItemSize).CopyTo(Span(dst.GetChunkByItemIndex(dstIndex), (dstIndex % ItemsPerChunk) * this.ItemSize, this.ItemSize))

    GetChunkAs<T>(chunkIndex: int32): Span<T> where T: blittable, struct, ValueType, { new() } =
        MemoryMarshal.Cast<byte, T>(Span(this.chunks[chunkIndex]))

    GetReadOnlyChunkAs<T>(chunkIndex: int32): ReadOnlySpan<T> where T: blittable, struct, ValueType, { new() } =
        Span<_>.op_Implicit(MemoryMarshal.Cast<byte, T>(Span(this.chunks[chunkIndex])))

    GetAs<T>(index: int32): byref<T> where T: blittable, struct, ValueType, { new() } =
        &MemoryMarshal.Cast<byte, T>(Span(this.GetChunkByItemIndex(index)))[index % ItemsPerChunk]

    SetAs<T>(index: int32, item: T): () where T: blittable, struct, ValueType, { new() } =
        this.GetAs<T>(index) <- item

    Get(index: int32): Span<byte> =
        Span(this.GetChunkByItemIndex(index), (index % ItemsPerChunk) * this.ItemSize, this.ItemSize)

    ForEachChunk(lengthInBytes: int32, f: scoped (Span<byte>, count: int32) -> ()): () =
        if (lengthInBytes > 0)
            let count = (lengthInBytes / this.ItemSize)
            let sliceCount = (count / ItemsPerChunk) + 1

            let mutable remainingCount = count

            let mutable i = 0
            while (i < sliceCount)
                if (i == sliceCount - 1)
                    let size = remainingCount * this.ItemSize
                    f(Span(this.chunks[i], 0, size), size / this.ItemSize)
                else
                    remainingCount <- remainingCount - ItemsPerChunk
                    f(Span(this.chunks[i], 0, ItemsPerChunk * this.ItemSize), ItemsPerChunk)
                i <- i + 1
            

    ForEachChunk2(store2: ChunkedItemStore<MaxItemCount, ItemsPerChunk>, lengthInBytes: int32, f: scoped (Span<byte>, Span<byte>, count: int32) -> ()): () =
        if (lengthInBytes > 0)
            let count = (lengthInBytes / this.ItemSize)
            let sliceCount = (count / ItemsPerChunk) + 1

            let mutable remainingCount = count

            let mutable i = 0
            while (i < sliceCount)
                if (i == sliceCount - 1)
                    let size = remainingCount * this.ItemSize
                    f(Span(this.chunks[i], 0, size), Span(store2.chunks[i], 0, size), size / this.ItemSize)
                else
                    remainingCount <- remainingCount - ItemsPerChunk
                    let size = ItemsPerChunk * this.ItemSize
                    f(Span(this.chunks[i], 0, size), Span(store2.chunks[i], 0, size), ItemsPerChunk)
                i <- i + 1

internal class ComponentBuffer =

    static MaxNumberOfEntitiesPerSlice: int32 get() = 128
    
    Store: ChunkedItemStore<65536, 128> get
    ComponentName: string get
    ComponentId: ComponentId get
    ComponentIndex: int32 get
    Type: Type get

    SerializeDeltaForNetwork: SerializeDeltaForNetworkFunction get
    DeserializeDeltaForNetwork: DeserializeDeltaForNetworkFunction get

    new(typeId: ComponentId, index: int32, typeSize: int32, ty: Type, compName: string, serializeDeltaForNetwork: SerializeDeltaForNetworkFunction, deserializeDeltaForNetwork: DeserializeDeltaForNetworkFunction) =
        {          
            Store = ChunkedItemStore(typeSize)
            ComponentId = typeId
            ComponentIndex = index
            ComponentName = compName
            Type = ty
            SerializeDeltaForNetwork = serializeDeltaForNetwork
            DeserializeDeltaForNetwork = deserializeDeltaForNetwork
            ComponentAdded = Event()
            ComponentRemoving = Event()
        }

    ComponentAdded: Event<int32> get
    ComponentRemoving: Event<int32> get

alias EntityIdStore = ChunkedItemStore<65536, 128>

internal class Archetype =

    new(size: int32, buffers: ComponentBuffer[], archetypeId: ArchetypeId, attachmentId: ArchetypeId) =
        let bufferLookup = Dictionary(BitSet512EqualityComparer())
        let bufferLookupByIndex = Dictionary()

        let nonAttachmentBuffers = List<ComponentBuffer>()
        let attachmentBuffers = List<ComponentBuffer>()

        let mutable i = 0
        while (i < buffers.Length)
            let buffer = buffers[i]
            bufferLookup[buffer.ComponentId] <- i
            bufferLookupByIndex[buffer.ComponentIndex] <- i
            if (buffer.ComponentId & attachmentId == buffer.ComponentId)
                attachmentBuffers.Add(buffer)
            else
                nonAttachmentBuffers.Add(buffer)
            i <- i + 1

        {
            IsServerSide = archetypeId.IsSet(0) // TOOD-language-bug: We should be able to do 'BuiltInComponents.ServerSide.GetIndex()'
            IsClientSide = archetypeId.IsSet(1) // TOOD-language-bug: We should be able to do 'BuiltInComponents.ClientSide.GetIndex()'
            Id = archetypeId
            AttachmentId = attachmentId
            FullId = archetypeId | attachmentId
            totalCount = 0
            Capacity = size
            EntityIds = ChunkedItemStore(DotNet.SizeOf<EntityId>)
            Buffers = buffers
            NonAttachmentBuffers = Unsafe.AsImmutable(nonAttachmentBuffers.ToArray())
            AttachmentBuffers = Unsafe.AsImmutable(attachmentBuffers.ToArray())
            BufferLookup = bufferLookup
            BufferLookupByIndex = bufferLookupByIndex
        }
    
    IsLocal: bool get() = this.IsClientSide || this.IsServerSide
    IsClientSide: bool get
    IsServerSide: bool get
    Id: ArchetypeId get
    AttachmentId: ArchetypeId get
    FullId: ArchetypeId get
    Capacity: int32 get
    EntityIds: EntityIdStore get
    Buffers: ComponentBuffer[] get
    NonAttachmentBuffers: ComponentBuffer[] get
    AttachmentBuffers: ComponentBuffer[] get
    BufferLookup: Dictionary<ComponentId, int32> get
    BufferLookupByIndex: Dictionary<int32, int32> get

    ComponentListText: string 
        get() =
            let str = StringBuilder()
            ForEach(this.Buffers,
                x ->
                    let _ = str.Append(x.ComponentName + ",")
            )
            str.ToString()

    ComponentListNoAttachmentsText: string 
        get() =
            let str = StringBuilder()
            ForEach(this.Buffers,
                x ->
                    if (this.AttachmentId & x.ComponentId != x.ComponentId)
                        let _ = str.Append(x.ComponentName + ",")
            )
            str.ToString()

    field mutable totalCount: int32
    Count: int32
        get() = this.totalCount
        set(value) =
            this.EnsureCapacity(value)
            this.totalCount <- value

    CopyTo(dst: Archetype): () =
        let count = this.Count
        dst.Count <- count
        this.EntityIds.CopyTo(dst.EntityIds, count)

        let mutable i = 0
        while (i < this.Buffers.Length)
            let buffer = this.Buffers[i]
            let store = buffer.Store
            let mutable dstBufferIndex = unchecked default
            if (dst.BufferLookupByIndex.TryGetValue(buffer.ComponentIndex, &dstBufferIndex))
                store.CopyTo(dst.Buffers[dstBufferIndex].Store, count)
            i <- i + 1 

    CopyOneTo(srcIndex: int32, dst: Archetype, dstIndex: int32): () =
        let mutable i = 0
        while (i < this.Buffers.Length)
            let buffer = this.Buffers[i]
            let store = buffer.Store
            let mutable dstBufferIndex = unchecked default
            if (dst.BufferLookupByIndex.TryGetValue(buffer.ComponentIndex, &dstBufferIndex))
                store.CopyOneTo(srcIndex, dst.Buffers[dstBufferIndex].Store, dstIndex)

            i <- i + 1

    Set<T>(typedIndex: int32, index: int32, item: T): () where T: blittable, struct, ValueType, { new() } =
        this.GetComponentBuffer(typedIndex).Store.SetAs<T>(index, item)

    Get<T>(typedIndex: int32, index: int32): byref<T> where T: blittable, struct, ValueType, { new() } =
        &this.GetComponentBuffer(typedIndex).Store.GetAs<T>(index)

    #[inline]
    GetComponentBuffer(typedIndex: int32): ComponentBuffer =
        this.Buffers[typedIndex]

    ClearAll(): () =
        this.Count <- 0
        this.EntityIds.Clear()

        let mutable i = 0
        while (i < this.Buffers.Length)
            this.Buffers[i].Store.Clear()
            i <- i + 1

    ClearComponentsAt(index: int32): () =
        let mutable i = 0
        while (i < this.Buffers.Length)
            let buffer = this.Buffers[i]
            buffer.Store.ClearAt(index)
            i <- i + 1

    EnsureCapacity(count: int32): () =
        this.EntityIds.EnsureCapacity(count)

        let buffers = this.Buffers
        let bufferLength = buffers.Length

        let mutable i = 0
        while (i < bufferLength)
            buffers[i].Store.EnsureCapacity(count)
            i <- i + 1

    ClearComponentAttachmentsAt(index: int32): () =
        let buffers = this.AttachmentBuffers
        let bufferLength = buffers.Length

        let mutable i = 0
        while (i < bufferLength)
            buffers[i].Store.ClearAt(index)
            i <- i + 1

    ClearSubscribers(): () =
        ForEach(this.Buffers,
            x ->
                x.ComponentAdded.ClearSubscribers()
                x.ComponentRemoving.ClearSubscribers()
        )

    TriggerComponentRemoving(id: ArchetypeId, index: int32): () =
        ForEach(this.Buffers,
            x ->
                if (id.IsSet(x.ComponentIndex))
                    x.ComponentRemoving.Trigger(index)
        )

    TriggerComponentAdded(id: ArchetypeId, index: int32): () =
        ForEach(this.Buffers,
            x ->
                if (id.IsSet(x.ComponentIndex))
                    x.ComponentAdded.Trigger(index)
        )

internal class ArchetypeManager =

    private Archetypes: List<Archetype> get = List()
    private ArchetypeLookup: Dictionary<ArchetypeId, int32> get = Dictionary(BitSet512EqualityComparer())

    Clear(): () =
        this.Archetypes.Clear()
        this.ArchetypeLookup.Clear()

    Count: int32
        #[inline] 
        get() = this.Archetypes.Count

    #[inline]
    get_Item(index: int32): Archetype = this.Archetypes[index]

    #[inline]
    Contains(archetypeId: ArchetypeId): bool =
        this.ArchetypeLookup.ContainsKey(archetypeId)

    #[inline]
    TryGetValue(archetypeId: ArchetypeId, outArchetypeIndex: byref<int32>): bool =
        this.ArchetypeLookup.TryGetValue(archetypeId, &outArchetypeIndex)

    Create(archetypeId: ArchetypeId, registry: ComponentRegistry): int32 =
        let origArchetypeId = archetypeId
        let origCompIds = GetComponentIds(origArchetypeId)

        let mutable attachmentId = BitSet512.Create(0): ArchetypeId

        let archetypeId =
            let mutable archetypeId = archetypeId
            let mutable i = 0
            while (i < origCompIds.Length)
                let mutable result = unchecked default
                if (registry.AttachmentLookup.TryGetValue(origCompIds[i], &result))
                    archetypeId <- archetypeId | result
                    attachmentId <- attachmentId | result
                i <- i + 1
            archetypeId

        let compIds = GetComponentIds(archetypeId)

        let buffers = List(compIds.Length)
        let mutable i = 0
        while (i < compIds.Length)
            let compId = compIds[i]
            if (registry.Contains(compId))
                let size = registry.GetSize(compId)
                let ty = registry.GetType(compId)
                let index = registry.GetIndex(compId)
                let (compName, serializeDelta, deserializeDelta) = registry.GetFunctions(compId)
                let buffer = ComponentBuffer(compId, index, size, ty, compName, serializeDelta, deserializeDelta)
                buffers.Add(buffer)
            i <- i + 1

        let archetype = Archetype(EntityDatabase.MaxNumberOfEntities, Unsafe.AsImmutable(buffers.ToArray()), origArchetypeId, attachmentId)
        let index = this.Archetypes.Count
        this.Archetypes.Add(archetype)
        this.ArchetypeLookup.Add(origArchetypeId, index)
        index

// TODO: Change all the queries to be like this one with ArchetypeGroup.
class EntityQuery<T0> where T0: blittable, struct, ValueType =

    internal ArchetypeGroup: List<Archetype>       get = List()
    internal EntIdGroup    : List<EntityIdStore>   get = List()
    internal BufferGroup0  : List<ComponentBuffer> get = List()

class EntityQuery<T0, T1> where T0: blittable, struct, ValueType
                          where T1: blittable, struct, ValueType =
    
    internal ArchetypeGroup: List<Archetype>       get = List()
    internal EntIdGroup    : List<EntityIdStore>   get = List()
    internal BufferGroup0  : List<ComponentBuffer> get = List()
    internal BufferGroup1  : List<ComponentBuffer> get = List()

internal class EntityQuery<T0, T1, T2> where T0: blittable, struct, ValueType
                              where T1: blittable, struct, ValueType
                              where T2: blittable, struct, ValueType =
    
    internal CountGroup  : List<int32> get = List()
    EntIdGroup  : List<EntityIdStore> get = List()
    BufferGroup0: List<ComponentBuffer> get       = List()
    BufferGroup1: List<ComponentBuffer> get       = List()
    BufferGroup2: List<ComponentBuffer> get       = List()

internal class EntityQuery<T0, T1, T2, T3> where T0: blittable, struct, ValueType
                              where T1: blittable, struct, ValueType
                              where T2: blittable, struct, ValueType 
                              where T3: blittable, struct, ValueType =
    
    internal CountGroup  : List<int32> get = List()
    EntIdGroup  : List<EntityIdStore> get = List()
    BufferGroup0: List<ComponentBuffer> get       = List()
    BufferGroup1: List<ComponentBuffer> get       = List()
    BufferGroup2: List<ComponentBuffer> get       = List()
    BufferGroup3: List<ComponentBuffer> get       = List()

internal class EntityQuery<T0, T1, T2, T3, T4> where T0: blittable, struct, ValueType
                              where T1: blittable, struct, ValueType
                              where T2: blittable, struct, ValueType 
                              where T3: blittable, struct, ValueType
                              where T4: blittable, struct, ValueType =
    
    internal CountGroup  : List<int32> get = List()
    EntIdGroup  : List<EntityIdStore> get = List()
    BufferGroup0: List<ComponentBuffer> get       = List()
    BufferGroup1: List<ComponentBuffer> get       = List()
    BufferGroup2: List<ComponentBuffer> get       = List()
    BufferGroup3: List<ComponentBuffer> get       = List()
    BufferGroup4: List<ComponentBuffer> get       = List()

internal class EntityQuery<T0, T1, T2, T3, T4, T5> where T0: blittable, struct, ValueType
                              where T1: blittable, struct, ValueType
                              where T2: blittable, struct, ValueType 
                              where T3: blittable, struct, ValueType
                              where T4: blittable, struct, ValueType
                              where T5: blittable, struct, ValueType =
    
    internal CountGroup  : List<int32> get = List()
    EntIdGroup  : List<EntityIdStore> get = List()
    BufferGroup0: List<ComponentBuffer> get       = List()
    BufferGroup1: List<ComponentBuffer> get       = List()
    BufferGroup2: List<ComponentBuffer> get       = List()
    BufferGroup3: List<ComponentBuffer> get       = List()
    BufferGroup4: List<ComponentBuffer> get       = List()
    BufferGroup5: List<ComponentBuffer> get       = List()

internal class EntityQuery<T0, T1, T2, T3, T4, T5, T6> where T0: blittable, struct, ValueType
                              where T1: blittable, struct, ValueType
                              where T2: blittable, struct, ValueType 
                              where T3: blittable, struct, ValueType
                              where T4: blittable, struct, ValueType
                              where T5: blittable, struct, ValueType
                              where T6: blittable, struct, ValueType =
    
    internal CountGroup  : List<int32> get = List()
    EntIdGroup  : List<EntityIdStore> get = List()
    BufferGroup0: List<ComponentBuffer> get       = List()
    BufferGroup1: List<ComponentBuffer> get       = List()
    BufferGroup2: List<ComponentBuffer> get       = List()
    BufferGroup3: List<ComponentBuffer> get       = List()
    BufferGroup4: List<ComponentBuffer> get       = List()
    BufferGroup5: List<ComponentBuffer> get       = List()
    BufferGroup6: List<ComponentBuffer> get       = List()

internal alias SerializeDeltaForNetworkFunction = (prevSrc: ReadOnlySpan<byte>, src: ReadOnlySpan<byte>, ByteStream) -> ()
internal alias DeserializeDeltaForNetworkFunction = (ByteStream, dst: Span<byte>) -> ()

internal struct RegistryEntry =
    Name: string get
    Size: int32 get
    Type: Type get
    Index: int32 get
    SerializeDeltaForNetwork: SerializeDeltaForNetworkFunction get
    DeserializeDeltaForNetwork: DeserializeDeltaForNetworkFunction get

    new(name: string, size: int32, ty: Type, index: int32, serializeDeltaForNetwork: SerializeDeltaForNetworkFunction, deserializeDeltaForNetwork: DeserializeDeltaForNetworkFunction) =
        {
            Name = name
            Size = size
            Type = ty
            Index = index
            SerializeDeltaForNetwork = serializeDeltaForNetwork
            DeserializeDeltaForNetwork = deserializeDeltaForNetwork
        }

class ComponentRegistry =
    private class _JsonFieldNameEndsWithComparer =
        implements IEqualityComparer<string>
        GetHashCode(o: string): int32 = o.GetHashCode()
        Equals(o1: string, o2: string): bool = o1.EndsWith(o2) || o2.EndsWith(o1)

    private Registered: Dictionary<ComponentId, RegistryEntry> get = Dictionary(BitSet512EqualityComparer())
    internal AttachmentLookup: Dictionary<ComponentId, ArchetypeId> get = Dictionary(BitSet512EqualityComparer()) 
    internal NameToId: Dictionary<string, ComponentId> get = Dictionary()
    internal JsonFieldWriteMappings: JsonFieldWriteMappings get = Dictionary(_JsonFieldNameEndsWithComparer())
    internal JsonFieldReadMappings: JsonFieldReadMappings get = Dictionary(_JsonFieldNameEndsWithComparer())

    internal GetIndex(compId: ComponentId): int32 = 
        let entry = this.Registered[compId]
        entry.Index

    internal GetSize(compId: ComponentId): int32 = 
        let entry = this.Registered[compId]
        entry.Size

    internal GetType(compId: ComponentId): Type = 
        let entry = this.Registered[compId]
        entry.Type

    internal GetFunctions(compId: ComponentId): (name: string, SerializeDeltaForNetworkFunction, DeserializeDeltaForNetworkFunction) =
        let entry = this.Registered[compId]
        (entry.Name, entry.SerializeDeltaForNetwork, entry.DeserializeDeltaForNetwork)

    internal Contains(compId: ComponentId): bool = this.Registered.ContainsKey(compId)

    internal Copy(): ComponentRegistry =
        let registryCopy = ComponentRegistry()
        ForEach(this.Registered,
            (mutable pair) -> registryCopy.Registered.Add(pair.Key, pair.Value)
        )
        ForEach(this.AttachmentLookup,
            (mutable pair) -> registryCopy.AttachmentLookup.Add(pair.Key, pair.Value)
        )
        ForEach(this.NameToId,
            (mutable pair) -> registryCopy.NameToId.Add(pair.Key, pair.Value)
        )
        ForEach(this.JsonFieldWriteMappings,
            (mutable pair) -> registryCopy.JsonFieldWriteMappings.Add(pair.Key, pair.Value)
        )
        ForEach(this.JsonFieldReadMappings,
            (mutable pair) -> registryCopy.JsonFieldReadMappings.Add(pair.Key, pair.Value)
        )
        registryCopy

    Contains<T>(): bool where T: blittable, struct, ValueType, { new() }, trait IComponent = this.Contains(T.GetId())
    internal RegisterInternal<T>(checkBuiltIn: bool): () where T: blittable, struct, ValueType, { new() }, trait IComponent = 
        let name = T.GetName()
        if (name == "EntityIndex")
            fail("Component name cannot be 'EntityIndex'.")
        if (checkBuiltIn && (name == "ServerSide"))
            fail("Component name cannot be 'ServerSide'.")
        if (checkBuiltIn && (name == "ClientSide"))
            fail("Component name cannot be 'ClientSide'.")

        let id = T.GetId()

        if (checkBuiltIn && id.ToIndex() < 16)
            fail("Component must have an index 16 or above.")

        this.Registered.Add(id, RegistryEntry(name, T.GetSize(), T.GetType(), T.GetIndex(), T.SerializeDeltaForNetwork, T.DeserializeDeltaForNetwork))
        this.NameToId.Add(name, id)
    Register<T>(): () where T: blittable, struct, ValueType, { new() }, trait IComponent = 
        this.RegisterInternal<T>(true)

    RegisterAttachment<T, TAttachment>(): () where T: blittable, struct, ValueType, { new() }, trait IComponent
                                             where TAttachment: blittable, struct, ValueType, { new() }, trait IComponent =
        let id = T.GetId()
        let mutable attachmentId = default
        if (this.AttachmentLookup.TryGetValue(id, &attachmentId))
            this.AttachmentLookup[id] <- attachmentId | TAttachment.GetId()
        else
            this.AttachmentLookup[id] <- TAttachment.GetId()

    RegisterJsonFieldWriteMapping(fieldNameEndsWith: string, write: (string, Type, ReadOnlySpan<byte>, writer: Utf8JsonWriter) -> ()): () =
        this.JsonFieldWriteMappings[fieldNameEndsWith] <- write

    RegisterJsonFieldReadMapping(fieldNameEndsWith: string, read: (string, Type, Span<byte>, reader: byref<Utf8JsonReader>) -> string): () =
        this.JsonFieldReadMappings[fieldNameEndsWith] <- read

class EntityFilter =

    internal NotId: ArchetypeId get
    internal new(notId: ArchetypeId) = { NotId = notId }

    static None(): EntityFilter =
        EntityFilter(default)

    static Not<T>(): EntityFilter where T: blittable, struct, ValueType, { new() }, trait IComponent =
        EntityFilter(T.GetId())

    static Not<T1, T2>(): EntityFilter 
            where T1: blittable, struct, ValueType, { new() }, trait IComponent
            where T2: blittable, struct, ValueType, { new() }, trait IComponent =
        EntityFilter(T1.GetId() | T2.GetId())

/// Not concurrency safe.
class EntityDatabase =

    static SubAdded<T, TMatch>(db: EntityDatabase, f: (EntityId, byref<T>, byref<TMatch>) -> ()): ()
        where T: blittable, struct, ValueType, { new() }, trait IComponent 
        where TMatch: blittable, struct, ValueType, { new() }, trait IComponent
        =
        let lookup = db.entityIndexLookup
        let indices = db.GetArchetypedIndices(GetArchetypeId<T, TMatch>())
        let mutable i = 0
        while (i < indices.Length)
                let archetype = db.GetArchetype(indices[i])
                let entIds = archetype.EntityIds
                let buffer = archetype.Buffers[archetype.BufferLookup[T.GetId()]]
                let buffer1 = archetype.Buffers[archetype.BufferLookup[TMatch.GetId()]]
                let store = buffer.Store
                let store1 = buffer1.Store
                buffer.ComponentAdded.Add(
                    index -> f(entIds.GetAs(index), &store.GetAs<T>(index), &store1.GetAs<TMatch>(index))                       
                )
                i <- i + 1

    static SubAdded<T, TMatch1, TMatch2>(db: EntityDatabase, f: (EntityId, byref<T>, byref<TMatch1>, byref<TMatch2>) -> ()): ()
        where T: blittable, struct, ValueType, { new() }, trait IComponent 
        where TMatch1: blittable, struct, ValueType, { new() }, trait IComponent
        where TMatch2: blittable, struct, ValueType, { new() }, trait IComponent
        =
        let lookup = db.entityIndexLookup
        let indices = db.GetArchetypedIndices(GetArchetypeId<T, TMatch1, TMatch2>())
        let mutable i = 0
        while (i < indices.Length)
                let archetype = db.GetArchetype(indices[i])
                let entIds = archetype.EntityIds
                let buffer = archetype.Buffers[archetype.BufferLookup[T.GetId()]]
                let buffer1 = archetype.Buffers[archetype.BufferLookup[TMatch1.GetId()]]
                let buffer2 = archetype.Buffers[archetype.BufferLookup[TMatch2.GetId()]]
                let store = buffer.Store
                let store1 = buffer1.Store
                let store2 = buffer2.Store
                buffer.ComponentAdded.Add(
                    index -> f(entIds.GetAs(index), &store.GetAs<T>(index), &store1.GetAs<TMatch1>(index), &store2.GetAs<TMatch2>(index))                       
                )
                i <- i + 1

    static SubAdded<T, TMatch1, TMatch2, TMatch3>(db: EntityDatabase, f: (EntityId, byref<T>, byref<TMatch1>, byref<TMatch2>, byref<TMatch3>) -> ()): ()
        where T: blittable, struct, ValueType, { new() }, trait IComponent 
        where TMatch1: blittable, struct, ValueType, { new() }, trait IComponent
        where TMatch2: blittable, struct, ValueType, { new() }, trait IComponent
        where TMatch3: blittable, struct, ValueType, { new() }, trait IComponent
        =
        let lookup = db.entityIndexLookup
        let indices = db.GetArchetypedIndices(GetArchetypeId<T, TMatch1, TMatch2, TMatch3>())
        let mutable i = 0
        while (i < indices.Length)
                let archetype = db.GetArchetype(indices[i])
                let entIds = archetype.EntityIds
                let buffer = archetype.Buffers[archetype.BufferLookup[T.GetId()]]
                let buffer1 = archetype.Buffers[archetype.BufferLookup[TMatch1.GetId()]]
                let buffer2 = archetype.Buffers[archetype.BufferLookup[TMatch2.GetId()]]
                let buffer3 = archetype.Buffers[archetype.BufferLookup[TMatch3.GetId()]]
                let store = buffer.Store
                let store1 = buffer1.Store
                let store2 = buffer2.Store
                let store3 = buffer3.Store
                buffer.ComponentAdded.Add(
                    index -> f(entIds.GetAs(index), &store.GetAs<T>(index), &store1.GetAs<TMatch1>(index), &store2.GetAs<TMatch2>(index), &store3.GetAs<TMatch3>(index))                       
                )
                i <- i + 1

    static SubRemoving<T>(db: EntityDatabase, f: (EntityId, byref<T>) -> ()): ()
        where T: blittable, struct, ValueType, { new() }, trait IComponent 
        =
        let lookup = db.entityIndexLookup
        let indices = db.GetArchetypedIndices(GetArchetypeId<T>())
        let mutable i = 0
        while (i < indices.Length)
                let archetype = db.GetArchetype(indices[i])
                let entIds = archetype.EntityIds
                let buffer = archetype.Buffers[archetype.BufferLookup[T.GetId()]]
                let store = buffer.Store
                buffer.ComponentRemoving.Add(
                    index -> f(entIds.GetAs(index), &store.GetAs<T>(index))                       
                )
                i <- i + 1

    static SubRemoving<T, TMatch>(db: EntityDatabase, f: (EntityId, byref<T>, byref<TMatch>) -> ()): ()
        where T: blittable, struct, ValueType, { new() }, trait IComponent 
        where TMatch: blittable, struct, ValueType, { new() }, trait IComponent
        =
        let lookup = db.entityIndexLookup
        let indices = db.GetArchetypedIndices(GetArchetypeId<T, TMatch>())
        let mutable i = 0
        while (i < indices.Length)
                let archetype = db.GetArchetype(indices[i])
                let entIds = archetype.EntityIds
                let buffer = archetype.Buffers[archetype.BufferLookup[T.GetId()]]
                let buffer1 = archetype.Buffers[archetype.BufferLookup[TMatch.GetId()]]
                let store = buffer.Store
                let store1 = buffer1.Store
                buffer.ComponentRemoving.Add(
                    index -> f(entIds.GetAs(index), &store.GetAs<T>(index), &store1.GetAs<TMatch>(index))                       
                )
                i <- i + 1

    static SubRemoving<T, TMatch1, TMatch2>(db: EntityDatabase, f: (EntityId, byref<T>, byref<TMatch1>, byref<TMatch2>) -> ()): ()
        where T: blittable, struct, ValueType, { new() }, trait IComponent 
        where TMatch1: blittable, struct, ValueType, { new() }, trait IComponent
        where TMatch2: blittable, struct, ValueType, { new() }, trait IComponent
        =
        let lookup = db.entityIndexLookup
        let indices = db.GetArchetypedIndices(GetArchetypeId<T, TMatch1, TMatch2>())
        let mutable i = 0
        while (i < indices.Length)
                let archetype = db.GetArchetype(indices[i])
                let entIds = archetype.EntityIds
                let buffer = archetype.Buffers[archetype.BufferLookup[T.GetId()]]
                let buffer1 = archetype.Buffers[archetype.BufferLookup[TMatch1.GetId()]]
                let buffer2 = archetype.Buffers[archetype.BufferLookup[TMatch2.GetId()]]
                let store = buffer.Store
                let store1 = buffer1.Store
                let store2 = buffer2.Store
                buffer.ComponentRemoving.Add(
                    index -> f(entIds.GetAs(index), &store.GetAs<T>(index), &store1.GetAs<TMatch1>(index), &store2.GetAs<TMatch2>(index))                       
                )
                i <- i + 1

    static SubRemoving<T, TMatch1, TMatch2, TMatch3>(db: EntityDatabase, f: (EntityId, byref<T>, byref<TMatch1>, byref<TMatch2>, byref<TMatch3>) -> ()): ()
        where T: blittable, struct, ValueType, { new() }, trait IComponent 
        where TMatch1: blittable, struct, ValueType, { new() }, trait IComponent
        where TMatch2: blittable, struct, ValueType, { new() }, trait IComponent
        where TMatch3: blittable, struct, ValueType, { new() }, trait IComponent
        =
        let lookup = db.entityIndexLookup
        let indices = db.GetArchetypedIndices(GetArchetypeId<T, TMatch1, TMatch2, TMatch3>())
        let mutable i = 0
        while (i < indices.Length)
                let archetype = db.GetArchetype(indices[i])
                let entIds = archetype.EntityIds
                let buffer = archetype.Buffers[archetype.BufferLookup[T.GetId()]]
                let buffer1 = archetype.Buffers[archetype.BufferLookup[TMatch1.GetId()]]
                let buffer2 = archetype.Buffers[archetype.BufferLookup[TMatch2.GetId()]]
                let buffer3 = archetype.Buffers[archetype.BufferLookup[TMatch3.GetId()]]
                let store = buffer.Store
                let store1 = buffer1.Store
                let store2 = buffer2.Store
                let store3 = buffer3.Store
                buffer.ComponentRemoving.Add(
                    index -> f(entIds.GetAs(index), &store.GetAs<T>(index), &store1.GetAs<TMatch1>(index), &store2.GetAs<TMatch2>(index), &store3.GetAs<TMatch3>(index))                       
                )
                i <- i + 1  

    Kind: EntityDatabaseKind get

    field mutable depth: int32
    field mutable parallelDepth: int32

    private IncrementDepth(): () =
        this.depth <- this.depth + 1

    private DecrementDepth(): () =
        this.depth <- this.depth - 1

    private IncrementParallelDepth(): () =
        this.parallelDepth <- this.parallelDepth + 1

    private DecrementParallelDepth(): () =
        this.parallelDepth <- this.parallelDepth - 1

    private Resubs: List<() -> ()> get

    #[DebuggerHidden]
    private ThrowIfParallelDepth(): () =
        if (this.parallelDepth > 0)
            throw InvalidOperationException("Cannot perform operation in the middle of a parallel one.")

    #[DebuggerHidden]
    private ThrowIfDepth(): () =
        if (this.depth > 0)
            throw InvalidOperationException("Cannot perform operation in the middle of exposing state.")

    internal Archetypes: ArchetypeManager get

    internal RegisterArchetype(archetypeId: ArchetypeId): int32 =
        if (this.Archetypes.Contains(archetypeId))
            fail("Archetype already registered")
        let result = this.Archetypes.Create(archetypeId, this.registry)
        let mutable i = 0
        while (i < this.GetArchetypeCount())
            let archetype = this.GetArchetype(i)
            ForEach(archetype.Buffers,
                buffer ->
                    buffer.ComponentAdded.ClearSubscribers()
                    buffer.ComponentRemoving.ClearSubscribers()
            )
            i <- i + 1
        ForEach(this.Resubs,
            resub ->
                resub()
        )
        result
        
    private GetArchetype(index: int32): Archetype =
        this.Archetypes[index]

    private GetArchetypeCount(): int32 =
        this.Archetypes.Count

    field lockObj: object
    internal GetArchetypedIndex(archetypeId: ArchetypeId): int32 =
        let mutable archetypedIndex = default
        if (this.Archetypes.TryGetValue(archetypeId, &archetypedIndex))
            archetypedIndex
        else
            lock(this.lockObj,
                () ->
                    this.RegisterArchetype(archetypeId)
                    //let archetype = this.Archetypes[this.RegisterArchetype(archetypeId)]
                    //fail("Archetype not registered: " + archetype.ComponentListNoAttachmentsText)
            )

    internal TryGetArchetypedIndex(archetypeId: ArchetypeId): int32 =
        // TODO: THIS HAS A VERY WEIRD BUG. USING THE COMMENTED CODE BELOW, RETURNING -1 SEEMS TO BE PROBLEMATIC AS IT RETURNS 'archetypedIndex' from 'RegisterArchetype`.
        //       Could this be a JIT bug?
        // try
        //     this.GetArchetypedIndex(archetypeId)
        // catch (ex: Exception) =>
        //     -1
        let mutable archetypedIndex = default
        if (this.Archetypes.TryGetValue(archetypeId, &archetypedIndex))
            archetypedIndex
        else
            -1

    TryGetValidEntityIdByIndex(index: int32): EntityId =
        if (index < 0 || index >= EntityDatabase.MaxNumberOfEntities)
            EntityId.Nil
        else
            let version = this.entityVersions[index]
            if (version == 0)
                EntityId.Nil
            else
                let mutable entId = EntityId()
                entId.Index <- index
                entId.Version <- version
                entId

    HandleComponentAdded<T>(f: (EntityId, byref<T>) -> ()): () where T: blittable, struct, ValueType, { new() }, trait IComponent =
        static let sub(db: EntityDatabase, f: (EntityId, byref<T>) -> ()): () =
            let lookup = db.entityIndexLookup
            let indices = db.GetArchetypedIndices(GetArchetypeId<T>())
            let mutable i = 0
            while (i < indices.Length)
                    let archetype = db.GetArchetype(indices[i])
                    let entIds = archetype.EntityIds
                    let buffer = archetype.Buffers[archetype.BufferLookup[T.GetId()]]
                    let store = buffer.Store
                    buffer.ComponentAdded.Add(
                        index -> f(entIds.GetAs(index), &store.GetAs<T>(index))                       
                    )
                    i <- i + 1
        this.Resubs.Add(() -> sub(this, f))
        sub(this, f)

    HandleComponentAdded<T, TMatch>(f: (EntityId, byref<T>, byref<TMatch>) -> ()): () 
            where T: blittable, struct, ValueType, { new() }, trait IComponent 
            where TMatch: blittable, struct, ValueType, { new() }, trait IComponent
            =
        this.Resubs.Add(() -> SubAdded(this, f))
        SubAdded(this, f)

    HandleComponentAdded<T, TMatch1, TMatch2>(f: (EntityId, byref<T>, byref<TMatch1>, byref<TMatch2>) -> ()): () 
            where T: blittable, struct, ValueType, { new() }, trait IComponent 
            where TMatch1: blittable, struct, ValueType, { new() }, trait IComponent
            where TMatch2: blittable, struct, ValueType, { new() }, trait IComponent
            =
        this.Resubs.Add(() -> SubAdded(this, f))
        SubAdded(this, f)

    HandleComponentAdded<T, TMatch1, TMatch2, TMatch3>(f: (EntityId, byref<T>, byref<TMatch1>, byref<TMatch2>, byref<TMatch3>) -> ()): () 
            where T: blittable, struct, ValueType, { new() }, trait IComponent 
            where TMatch1: blittable, struct, ValueType, { new() }, trait IComponent
            where TMatch2: blittable, struct, ValueType, { new() }, trait IComponent
            where TMatch3: blittable, struct, ValueType, { new() }, trait IComponent
            =
        this.Resubs.Add(() -> SubAdded(this, f))
        SubAdded(this, f)

    HandleComponentRemoving<T>(f: (EntityId, byref<T>) -> ()): () where T: blittable, struct, ValueType, { new() }, trait IComponent =
        this.Resubs.Add(() -> SubRemoving(this, f))
        SubRemoving(this, f)

    HandleComponentRemoving<T, TMatch>(f: (EntityId, byref<T>, byref<TMatch>) -> ()): () 
            where T: blittable, struct, ValueType, { new() }, trait IComponent 
            where TMatch: blittable, struct, ValueType, { new() }, trait IComponent
            =
        this.Resubs.Add(() -> SubRemoving(this, f))
        SubRemoving(this, f)

    HandleComponentRemoving<T, TMatch1, TMatch2>(f: (EntityId, byref<T>, byref<TMatch1>, byref<TMatch2>) -> ()): () 
            where T: blittable, struct, ValueType, { new() }, trait IComponent 
            where TMatch1: blittable, struct, ValueType, { new() }, trait IComponent
            where TMatch2: blittable, struct, ValueType, { new() }, trait IComponent
            =
        this.Resubs.Add(() -> SubRemoving(this, f))
        SubRemoving(this, f)

    HandleComponentRemoving<T, TMatch1, TMatch2, TMatch3>(f: (EntityId, byref<T>, byref<TMatch1>, byref<TMatch2>, byref<TMatch3>) -> ()): () 
            where T: blittable, struct, ValueType, { new() }, trait IComponent 
            where TMatch1: blittable, struct, ValueType, { new() }, trait IComponent
            where TMatch2: blittable, struct, ValueType, { new() }, trait IComponent
            where TMatch3: blittable, struct, ValueType, { new() }, trait IComponent
            =        
        this.Resubs.Add(() -> SubRemoving(this, f))
        SubRemoving(this, f)

    HandleComponentCycle<T>(
        added: (EntityId, byref<T>) -> (),
        removing: (EntityId, byref<T>) -> ()): ()
        where T: blittable, struct, ValueType, { new() }, trait IComponent 
        =
        this.HandleComponentAdded(added)
        this.HandleComponentRemoving(removing)

    HandleComponentCycle<T, TMatch>(
        added: (EntityId, byref<T>, byref<TMatch>) -> (),
        removing: (EntityId, byref<T>, byref<TMatch>) -> ()): ()
        where T: blittable, struct, ValueType, { new() }, trait IComponent 
        where TMatch: blittable, struct, ValueType, { new() }, trait IComponent
        =
        this.HandleComponentAdded(added)
        this.HandleComponentRemoving(removing)

    HandleComponentCycle<T, TMatch1, TMatch2>(
        added: (EntityId, byref<T>, byref<TMatch1>, byref<TMatch2>) -> (),
        removing: (EntityId, byref<T>, byref<TMatch1>, byref<TMatch2>) -> ()): ()
        where T: blittable, struct, ValueType, { new() }, trait IComponent 
        where TMatch1: blittable, struct, ValueType, { new() }, trait IComponent
        where TMatch2: blittable, struct, ValueType, { new() }, trait IComponent
        =
        this.HandleComponentAdded(added)
        this.HandleComponentRemoving(removing)

    HandleComponentCycle<T, TMatch1, TMatch2, TMatch3>(
        added: (EntityId, byref<T>, byref<TMatch1>, byref<TMatch2>, byref<TMatch3>) -> (),
        removing: (EntityId, byref<T>, byref<TMatch1>, byref<TMatch2>, byref<TMatch3>) -> ()): ()
        where T: blittable, struct, ValueType, { new() }, trait IComponent 
        where TMatch1: blittable, struct, ValueType, { new() }, trait IComponent
        where TMatch2: blittable, struct, ValueType, { new() }, trait IComponent
        where TMatch3: blittable, struct, ValueType, { new() }, trait IComponent
        =
        this.HandleComponentAdded(added)
        this.HandleComponentRemoving(removing)

    new(kind: EntityDatabaseKind, registry: ComponentRegistry) =
        if (EntityDatabase.MaxNumberOfEntities % 2 != 0)
            fail("MaxNumberOfEntities must be divisible by 2")

        let registryCopy = registry.Copy()
        registryCopy.RegisterInternal<BuiltInComponents.ServerSide>(false)
        registryCopy.RegisterInternal<BuiltInComponents.ClientSide>(false)
        {
            Kind = kind
            depth = 0
            parallelDepth = 0

            registry = registryCopy

            Archetypes = ArchetypeManager()

            // debug
            DebugDeletedEntities = Dictionary()

            // entity management
            lastCreatedEntity = EntityId.Nil
            entityCount = 0
            entityArchetypeIndicesClear = initMutableArray(EntityDatabase.MaxNumberOfEntities, i -> -1)
            entityArchetypeIndices = initMutableArray(EntityDatabase.MaxNumberOfEntities, i -> -1)
            entityIndexLookup = initMutableArray(EntityDatabase.MaxNumberOfEntities, i -> -1)
            entityVersions = zeroArray(EntityDatabase.MaxNumberOfEntities)

            lastCreatedLocalEntity = EntityId.Nil
            localEntityCount = 0
            Resubs = List()

            lockObj = Object()
        }

    public static field MaxNumberOfEntities: int32 = 65536 // note: do not increase this

    private field registry: ComponentRegistry

    field DebugDeletedEntities: Dictionary<EntityId, ()> get

    private GetTypedIndex<T>(archetypedIndex: int32): int32 where T: blittable, struct, ValueType, { new() }, trait IComponent =
        let key = T.GetId()
        let archetype = this.GetArchetype(archetypedIndex)
        archetype.BufferLookup[key]

    private GetArchetypedIndices(archetypeId: ArchetypeId): int32[] =
        let indices = List<int32>()
        let mutable i = 0
        while (i < this.GetArchetypeCount())
            let archetype = this.GetArchetype(i)

            if (archetype.FullId.IsSupersetOf(archetypeId))
                indices.Add(i)
            
            i <- i + 1

        Unsafe.AsImmutable(indices.ToArray())

    private GetArchetypedIndices(archetypeId: ArchetypeId, filterNotId: ArchetypeId): int32[] =
        let indices = List<int32>()
        let mutable i = 0
        while (i < this.GetArchetypeCount())
            let archetype = this.GetArchetype(i)

            if ((archetype.FullId.IsSupersetOf(archetypeId) && (filterNotId.IsZero || !archetype.FullId.IsSupersetOf(filterNotId))))
                indices.Add(i)
            
            i <- i + 1

        Unsafe.AsImmutable(indices.ToArray())
        
    CreateQuery<T0>(): EntityQuery<T0> where T0: blittable, struct, ValueType, { new() }, trait IComponent =
        let query = EntityQuery<T0>()
        
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0>())

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.GetArchetype(index)
            
            query.ArchetypeGroup.Add(archetype)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T0.GetId()]))

            i <- i + 1

        query

    CreateQuery<T0, T1>(): EntityQuery<T0, T1> 
            where T0: blittable, struct, ValueType, { new() }, trait IComponent 
            where T1: blittable, struct, ValueType, { new() }, trait IComponent
            =
        let query = EntityQuery<T0, T1>()

        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1>())

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.GetArchetype(index)
            
            query.ArchetypeGroup.Add(archetype)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T0.GetId()]))
            query.BufferGroup1.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T1.GetId()]))

            i <- i + 1

        query

    private CreateQuery<T0, T1, T2>(): EntityQuery<T0, T1, T2> where T0: blittable, struct, ValueType, { new() }, trait IComponent  
                                                               where T1: blittable, struct, ValueType, { new() }, trait IComponent 
                                                               where T2: blittable, struct, ValueType, { new() }, trait IComponent  =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2>())

        let query = EntityQuery<T0, T1, T2>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.GetArchetype(index)
            
            query.CountGroup.Add(archetype.Count)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T0.GetId()]))
            query.BufferGroup1.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T1.GetId()]))
            query.BufferGroup2.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T2.GetId()]))

            i <- i + 1

        query

    private CreateQuery<T0, T1, T2>(filter: EntityFilter): EntityQuery<T0, T1, T2> 
            where T0: blittable, struct, ValueType, { new() }, trait IComponent  
            where T1: blittable, struct, ValueType, { new() }, trait IComponent 
            where T2: blittable, struct, ValueType, { new() }, trait IComponent  =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2>(), filter.NotId)
        this.CreateQueryCore<T0, T1, T2>(filter, indices)

    private CreateQueryCore<T0, T1, T2>(filter: EntityFilter, indices: int32[]): EntityQuery<T0, T1, T2> 
            where T0: blittable, struct, ValueType, { new() }, trait IComponent  
            where T1: blittable, struct, ValueType, { new() }, trait IComponent 
            where T2: blittable, struct, ValueType, { new() }, trait IComponent  =
        let query = EntityQuery<T0, T1, T2>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.GetArchetype(index)
            
            query.CountGroup.Add(archetype.Count)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T0.GetId()]))
            query.BufferGroup1.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T1.GetId()]))
            query.BufferGroup2.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T2.GetId()]))

            i <- i + 1

        query

    private CreateQuery<T0, T1, T2, T3>(indices: int32[]): EntityQuery<T0, T1, T2, T3> where T0: blittable, struct, ValueType, { new() }, trait IComponent  
                                                                       where T1: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                       where T2: blittable, struct, ValueType, { new() }, trait IComponent  
                                                                       where T3: blittable, struct, ValueType, { new() }, trait IComponent  =
        let query = EntityQuery<T0, T1, T2, T3>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.GetArchetype(index)
            
            query.CountGroup.Add(archetype.Count)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T0.GetId()]))
            query.BufferGroup1.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T1.GetId()]))
            query.BufferGroup2.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T2.GetId()]))
            query.BufferGroup3.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T3.GetId()]))

            i <- i + 1

        query

    private CreateQuery<T0, T1, T2, T3, T4>(): EntityQuery<T0, T1, T2, T3, T4> where T0: blittable, struct, ValueType, { new() }, trait IComponent  
                                                                       where T1: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                       where T2: blittable, struct, ValueType, { new() }, trait IComponent  
                                                                       where T3: blittable, struct, ValueType, { new() }, trait IComponent
                                                                       where T4: blittable, struct, ValueType, { new() }, trait IComponent  =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2, T3, T4>())

        let query = EntityQuery<T0, T1, T2, T3, T4>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.GetArchetype(index)
            
            query.CountGroup.Add(archetype.Count)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T0.GetId()]))
            query.BufferGroup1.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T1.GetId()]))
            query.BufferGroup2.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T2.GetId()]))
            query.BufferGroup3.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T3.GetId()]))
            query.BufferGroup4.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T4.GetId()]))

            i <- i + 1

        query

    private CreateQuery<T0, T1, T2, T3, T4, T5>(): EntityQuery<T0, T1, T2, T3, T4, T5> where T0: blittable, struct, ValueType, { new() }, trait IComponent  
                                                                                       where T1: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                                       where T2: blittable, struct, ValueType, { new() }, trait IComponent  
                                                                                       where T3: blittable, struct, ValueType, { new() }, trait IComponent
                                                                                       where T4: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                                       where T5: blittable, struct, ValueType, { new() }, trait IComponent =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2, T3, T4, T5>())

        let query = EntityQuery<T0, T1, T2, T3, T4, T5>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.GetArchetype(index)
            
            query.CountGroup.Add(archetype.Count)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T0.GetId()]))
            query.BufferGroup1.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T1.GetId()]))
            query.BufferGroup2.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T2.GetId()]))
            query.BufferGroup3.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T3.GetId()]))
            query.BufferGroup4.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T4.GetId()]))
            query.BufferGroup5.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T5.GetId()]))

            i <- i + 1

        query

    private CreateQuery<T0, T1, T2, T3, T4, T5, T6>(): EntityQuery<T0, T1, T2, T3, T4, T5, T6> where T0: blittable, struct, ValueType, { new() }, trait IComponent  
                                                                                       where T1: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                                       where T2: blittable, struct, ValueType, { new() }, trait IComponent  
                                                                                       where T3: blittable, struct, ValueType, { new() }, trait IComponent
                                                                                       where T4: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                                       where T5: blittable, struct, ValueType, { new() }, trait IComponent
                                                                                       where T6: blittable, struct, ValueType, { new() }, trait IComponent =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2, T3, T4, T5, T6>())

        let query = EntityQuery<T0, T1, T2, T3, T4, T5, T6>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.GetArchetype(index)
            
            query.CountGroup.Add(archetype.Count)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T0.GetId()]))
            query.BufferGroup1.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T1.GetId()]))
            query.BufferGroup2.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T2.GetId()]))
            query.BufferGroup3.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T3.GetId()]))
            query.BufferGroup4.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T4.GetId()]))
            query.BufferGroup5.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T5.GetId()]))
            query.BufferGroup6.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T6.GetId()]))

            i <- i + 1

        query

    #[inline]
    ForEachSpan<T0>(query: EntityQuery<T0>, #[inline] f: scoped (ReadOnlySpan<EntityId>, Span<T0>) -> ()): () 
            where T0: blittable, struct, ValueType, { new() }, trait IComponent =
        this.IncrementDepth()

        let archetypeGroup   = query.ArchetypeGroup
        let entIdGroup       = query.EntIdGroup
        let bufferGroup0     = query.BufferGroup0

        let mutable i = 0
        while (i < archetypeGroup.Count)
            let archetype = archetypeGroup[i]
            let entIds = entIdGroup[i]
            let buffer0 = bufferGroup0[i].Store
            let count = archetype.Count

            let sliceCount = if (count == 0) 0 else (count / ComponentBuffer.MaxNumberOfEntitiesPerSlice) + 1
            let sliceNumber = ComponentBuffer.MaxNumberOfEntitiesPerSlice

            let mutable j = 0
            while (j < sliceCount)
                if (j == sliceCount - 1)
                    let start = j * sliceNumber
                    let length = count - start
                    f(
                        entIds.GetReadOnlyChunkAs(j).Slice(0, length),
                        buffer0.GetChunkAs(j).Slice(0, length)
                    )
                else
                    f(
                        entIds.GetReadOnlyChunkAs(j),
                        buffer0.GetChunkAs(j)
                    )
                j <- j + 1

            i <- i + 1
        this.DecrementDepth()

    #[inline]
    ForEachSpan<T0, T1>(#[inline] f: scoped (ReadOnlySpan<EntityId>, Span<T0>, Span<T1>) -> ()): () where T0: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                                   where T1: blittable, struct, ValueType, { new() }, trait IComponent =
        this.IncrementDepth()
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1>())

        let query = this.CreateQuery<T0, T1>()
        let archetypeGroup = query.ArchetypeGroup
        let entIdGroup     = query.EntIdGroup
        let bufferGroup0   = query.BufferGroup0
        let bufferGroup1   = query.BufferGroup1

        let mutable i = 0
        while (i < indices.Length)
            let archetype = archetypeGroup[i]
            let entIds = entIdGroup[i]
            let buffer0 = bufferGroup0[i].Store
            let buffer1 = bufferGroup1[i].Store
            let count = archetype.Count

            let sliceCount = if (count == 0) 0 else (count / ComponentBuffer.MaxNumberOfEntitiesPerSlice) + 1
            let sliceNumber = ComponentBuffer.MaxNumberOfEntitiesPerSlice

            let mutable j = 0
            while (j < sliceCount)
                if (j == sliceCount - 1)
                    let start = j * sliceNumber
                    let length = count - start
                    f(
                        entIds.GetReadOnlyChunkAs(j).Slice(0, length),
                        buffer0.GetChunkAs(j).Slice(0, length),
                        buffer1.GetChunkAs(j).Slice(0, length)
                    )
                else
                    f(
                        entIds.GetReadOnlyChunkAs(j),
                        buffer0.GetChunkAs(j),
                        buffer1.GetChunkAs(j)
                    )
                j <- j + 1

            i <- i + 1
        this.DecrementDepth()

    #[inline]
    ForEachSpan<T0, T1, T2>(#[inline] f: scoped (ReadOnlySpan<EntityId>, Span<T0>, Span<T1>, Span<T2>) -> ()): () 
            where T0: blittable, struct, ValueType, { new() }, trait IComponent 
            where T1: blittable, struct, ValueType, { new() }, trait IComponent 
            where T2: blittable, struct, ValueType, { new() }, trait IComponent =
        this.IncrementDepth()
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2>())

        let query = this.CreateQuery<T0, T1, T2>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0
        let bufferGroup1 = query.BufferGroup1
        let bufferGroup2 = query.BufferGroup2

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i]
            let entIds = entIdGroup[i]
            let buffer0 = bufferGroup0[i].Store
            let buffer1 = bufferGroup1[i].Store
            let buffer2 = bufferGroup2[i].Store

            let sliceCount = if (count == 0) 0 else (count / ComponentBuffer.MaxNumberOfEntitiesPerSlice) + 1
            let sliceNumber = ComponentBuffer.MaxNumberOfEntitiesPerSlice

            let mutable j = 0
            while (j < sliceCount)
                if (j == sliceCount - 1)
                    let start = j * sliceNumber
                    let length = count - start
                    f(
                        entIds.GetReadOnlyChunkAs(j).Slice(0, length),
                        buffer0.GetChunkAs(j).Slice(0, length),
                        buffer1.GetChunkAs(j).Slice(0, length),
                        buffer2.GetChunkAs(j).Slice(0, length)
                    )
                else
                    f(
                        entIds.GetReadOnlyChunkAs(j),
                        buffer0.GetChunkAs(j),
                        buffer1.GetChunkAs(j),
                        buffer2.GetChunkAs(j)
                    )
                j <- j + 1

            i <- i + 1
        this.DecrementDepth()

    #[inline]
    ForEachSpan<T0, T1, T2>(filter: EntityFilter, #[inline] f: scoped (ReadOnlySpan<EntityId>, Span<T0>, Span<T1>, Span<T2>) -> ()): () 
            where T0: blittable, struct, ValueType, { new() }, trait IComponent 
            where T1: blittable, struct, ValueType, { new() }, trait IComponent 
            where T2: blittable, struct, ValueType, { new() }, trait IComponent =
        this.IncrementDepth()
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2>(), filter.NotId)

        let query = this.CreateQuery<T0, T1, T2>(filter)
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0
        let bufferGroup1 = query.BufferGroup1
        let bufferGroup2 = query.BufferGroup2

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i]
            let entIds = entIdGroup[i]
            let buffer0 = bufferGroup0[i].Store
            let buffer1 = bufferGroup1[i].Store
            let buffer2 = bufferGroup2[i].Store

            let sliceCount = if (count == 0) 0 else (count / ComponentBuffer.MaxNumberOfEntitiesPerSlice) + 1
            let sliceNumber = ComponentBuffer.MaxNumberOfEntitiesPerSlice

            let mutable j = 0
            while (j < sliceCount)
                if (j == sliceCount - 1)
                    let start = j * sliceNumber
                    let length = count - start
                    f(
                        entIds.GetReadOnlyChunkAs(j).Slice(0, length),
                        buffer0.GetChunkAs(j).Slice(0, length),
                        buffer1.GetChunkAs(j).Slice(0, length),
                        buffer2.GetChunkAs(j).Slice(0, length)
                    )
                else
                    f(
                        entIds.GetReadOnlyChunkAs(j),
                        buffer0.GetChunkAs(j),
                        buffer1.GetChunkAs(j),
                        buffer2.GetChunkAs(j)
                    )
                j <- j + 1

            i <- i + 1
        this.DecrementDepth()

    #[inline]
    ForEachSpan<T0, T1, T2, T3>(filter: EntityFilter, #[inline] f: scoped (ReadOnlySpan<EntityId>, Span<T0>, Span<T1>, Span<T2>, Span<T3>) -> ()): () 
            where T0: blittable, struct, ValueType, { new() }, trait IComponent 
            where T1: blittable, struct, ValueType, { new() }, trait IComponent 
            where T2: blittable, struct, ValueType, { new() }, trait IComponent 
            where T3: blittable, struct, ValueType, { new() }, trait IComponent =
        this.IncrementDepth()
        
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2, T3>(), filter.NotId)
        let query = this.CreateQuery<T0, T1, T2, T3>(indices)
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0
        let bufferGroup1 = query.BufferGroup1
        let bufferGroup2 = query.BufferGroup2
        let bufferGroup3 = query.BufferGroup3

        let mutable i = 0
        while (i < countGroup.Count)
            let count = countGroup[i]
            let entIds = entIdGroup[i]
            let buffer0 = bufferGroup0[i].Store
            let buffer1 = bufferGroup1[i].Store
            let buffer2 = bufferGroup2[i].Store
            let buffer3 = bufferGroup3[i].Store

            let sliceCount = if (count == 0) 0 else (count / ComponentBuffer.MaxNumberOfEntitiesPerSlice) + 1
            let sliceNumber = ComponentBuffer.MaxNumberOfEntitiesPerSlice

            let mutable j = 0
            while (j < sliceCount)
                if (j == sliceCount - 1)
                    let start = j * sliceNumber
                    let length = count - start
                    f(
                        entIds.GetReadOnlyChunkAs(j).Slice(0, length),
                        buffer0.GetChunkAs(j).Slice(0, length),
                        buffer1.GetChunkAs(j).Slice(0, length),
                        buffer2.GetChunkAs(j).Slice(0, length),
                        buffer3.GetChunkAs(j).Slice(0, length)
                    )
                else
                    f(
                        entIds.GetReadOnlyChunkAs(j),
                        buffer0.GetChunkAs(j),
                        buffer1.GetChunkAs(j),
                        buffer2.GetChunkAs(j),
                        buffer3.GetChunkAs(j)
                    )
                j <- j + 1

            i <- i + 1
        this.DecrementDepth()

    #[inline]
    ForEachSpan<T0, T1, T2, T3, T4>(filter: EntityFilter, #[inline] f: scoped (ReadOnlySpan<EntityId>, Span<T0>, Span<T1>, Span<T2>, Span<T3>, Span<T4>) -> ()): () 
            where T0: blittable, struct, ValueType, { new() }, trait IComponent 
            where T1: blittable, struct, ValueType, { new() }, trait IComponent 
            where T2: blittable, struct, ValueType, { new() }, trait IComponent 
            where T3: blittable, struct, ValueType, { new() }, trait IComponent
            where T4: blittable, struct, ValueType, { new() }, trait IComponent =
        this.IncrementDepth()

        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2, T3, T4>(), filter.NotId)
        let query = this.CreateQuery<T0, T1, T2, T3, T4>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0
        let bufferGroup1 = query.BufferGroup1
        let bufferGroup2 = query.BufferGroup2
        let bufferGroup3 = query.BufferGroup3
        let bufferGroup4 = query.BufferGroup4

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i]
            let entIds = entIdGroup[i]
            let buffer0 = bufferGroup0[i].Store
            let buffer1 = bufferGroup1[i].Store
            let buffer2 = bufferGroup2[i].Store
            let buffer3 = bufferGroup3[i].Store
            let buffer4 = bufferGroup4[i].Store

            let sliceCount = if (count == 0) 0 else (count / ComponentBuffer.MaxNumberOfEntitiesPerSlice) + 1
            let sliceNumber = ComponentBuffer.MaxNumberOfEntitiesPerSlice

            let mutable j = 0
            while (j < sliceCount)
                if (j == sliceCount - 1)
                    let start = j * sliceNumber
                    let length = count - start
                    f(
                        entIds.GetReadOnlyChunkAs(j).Slice(0, length),
                        buffer0.GetChunkAs(j).Slice(0, length),
                        buffer1.GetChunkAs(j).Slice(0, length),
                        buffer2.GetChunkAs(j).Slice(0, length),
                        buffer3.GetChunkAs(j).Slice(0, length),
                        buffer4.GetChunkAs(j).Slice(0, length)
                    )
                else
                    f(
                        entIds.GetReadOnlyChunkAs(j),
                        buffer0.GetChunkAs(j),
                        buffer1.GetChunkAs(j),
                        buffer2.GetChunkAs(j),
                        buffer3.GetChunkAs(j),
                        buffer4.GetChunkAs(j)
                    )
                j <- j + 1

            i <- i + 1
        this.DecrementDepth()

    #[inline]
    ForEachSpan<T0, T1, T2, T3, T4, T5>(#[inline] f: scoped (ReadOnlySpan<EntityId>, Span<T0>, Span<T1>, Span<T2>, Span<T3>, Span<T4>, Span<T5>) -> ()): () where T0: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                                                                                           where T1: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                                                                                           where T2: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                                                                                           where T3: blittable, struct, ValueType, { new() }, trait IComponent
                                                                                                                                           where T4: blittable, struct, ValueType, { new() }, trait IComponent
                                                                                                                                           where T5: blittable, struct, ValueType, { new() }, trait IComponent =
        this.IncrementDepth()
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2, T3, T4, T5>())

        let query = this.CreateQuery<T0, T1, T2, T3, T4, T5>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0
        let bufferGroup1 = query.BufferGroup1
        let bufferGroup2 = query.BufferGroup2
        let bufferGroup3 = query.BufferGroup3
        let bufferGroup4 = query.BufferGroup4
        let bufferGroup5 = query.BufferGroup5

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i]
            let entIds = entIdGroup[i]
            let buffer0 = bufferGroup0[i].Store
            let buffer1 = bufferGroup1[i].Store
            let buffer2 = bufferGroup2[i].Store
            let buffer3 = bufferGroup3[i].Store
            let buffer4 = bufferGroup4[i].Store
            let buffer5 = bufferGroup5[i].Store

            let sliceCount = if (count == 0) 0 else (count / ComponentBuffer.MaxNumberOfEntitiesPerSlice) + 1
            let sliceNumber = ComponentBuffer.MaxNumberOfEntitiesPerSlice

            let mutable j = 0
            while (j < sliceCount)
                if (j == sliceCount - 1)
                    let start = j * sliceNumber
                    let length = count - start
                    f(
                        entIds.GetReadOnlyChunkAs(j).Slice(0, length),
                        buffer0.GetChunkAs(j).Slice(0, length),
                        buffer1.GetChunkAs(j).Slice(0, length),
                        buffer2.GetChunkAs(j).Slice(0, length),
                        buffer3.GetChunkAs(j).Slice(0, length),
                        buffer4.GetChunkAs(j).Slice(0, length),
                        buffer5.GetChunkAs(j).Slice(0, length)
                    )
                else
                    f(
                        entIds.GetReadOnlyChunkAs(j),
                        buffer0.GetChunkAs(j),
                        buffer1.GetChunkAs(j),
                        buffer2.GetChunkAs(j),
                        buffer3.GetChunkAs(j),
                        buffer4.GetChunkAs(j),
                        buffer5.GetChunkAs(j)
                    )
                j <- j + 1

            i <- i + 1
        this.DecrementDepth()

    #[inline]
    ForEachSpan<T0, T1, T2, T3, T4, T5, T6>(#[inline] f: scoped (ReadOnlySpan<EntityId>, Span<T0>, Span<T1>, Span<T2>, Span<T3>, Span<T4>, Span<T5>, Span<T6>) -> ()): () 
            where T0: blittable, struct, ValueType, { new() }, trait IComponent 
            where T1: blittable, struct, ValueType, { new() }, trait IComponent 
            where T2: blittable, struct, ValueType, { new() }, trait IComponent 
            where T3: blittable, struct, ValueType, { new() }, trait IComponent
            where T4: blittable, struct, ValueType, { new() }, trait IComponent
            where T5: blittable, struct, ValueType, { new() }, trait IComponent
            where T6: blittable, struct, ValueType, { new() }, trait IComponent =
        this.IncrementDepth()
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2, T3, T4, T5, T6>())

        let query = this.CreateQuery<T0, T1, T2, T3, T4, T5, T6>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0
        let bufferGroup1 = query.BufferGroup1
        let bufferGroup2 = query.BufferGroup2
        let bufferGroup3 = query.BufferGroup3
        let bufferGroup4 = query.BufferGroup4
        let bufferGroup5 = query.BufferGroup5
        let bufferGroup6 = query.BufferGroup6

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i]
            let entIds = entIdGroup[i]
            let buffer0 = bufferGroup0[i].Store
            let buffer1 = bufferGroup1[i].Store
            let buffer2 = bufferGroup2[i].Store
            let buffer3 = bufferGroup3[i].Store
            let buffer4 = bufferGroup4[i].Store
            let buffer5 = bufferGroup5[i].Store
            let buffer6 = bufferGroup6[i].Store

            let sliceCount = if (count == 0) 0 else (count / ComponentBuffer.MaxNumberOfEntitiesPerSlice) + 1
            let sliceNumber = ComponentBuffer.MaxNumberOfEntitiesPerSlice

            let mutable j = 0
            while (j < sliceCount)
                if (j == sliceCount - 1)
                    let start = j * sliceNumber
                    let length = count - start
                    f(
                        entIds.GetReadOnlyChunkAs(j).Slice(0, length),
                        buffer0.GetChunkAs(j).Slice(0, length),
                        buffer1.GetChunkAs(j).Slice(0, length),
                        buffer2.GetChunkAs(j).Slice(0, length),
                        buffer3.GetChunkAs(j).Slice(0, length),
                        buffer4.GetChunkAs(j).Slice(0, length),
                        buffer5.GetChunkAs(j).Slice(0, length),
                        buffer6.GetChunkAs(j).Slice(0, length)
                    )
                else
                    f(
                        entIds.GetReadOnlyChunkAs(j),
                        buffer0.GetChunkAs(j),
                        buffer1.GetChunkAs(j),
                        buffer2.GetChunkAs(j),
                        buffer3.GetChunkAs(j),
                        buffer4.GetChunkAs(j),
                        buffer5.GetChunkAs(j),
                        buffer6.GetChunkAs(j)
                    )
                j <- j + 1

            i <- i + 1
        this.DecrementDepth()

    #[inline]
    ForEach<T0>(query: EntityQuery<T0>, #[inline] f: scoped (EntityId, byref<T0>) -> ()): () where T0: blittable, struct, ValueType, { new() }, trait IComponent =
        this.ForEachSpan<T0>(query,
            (mutable entIds, mutable buffer0) ->
                let count = entIds.Length
                let mutable i = 0
                while (i < count)
                    f(entIds[i], &buffer0[i])
                    i <- i + 1
        )

    #[inline]
    ForEach<T0, T1>(#[inline] f: scoped (EntityId, byref<T0>, byref<T1>) -> ()): () where T0: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                   where T1: blittable, struct, ValueType, { new() }, trait IComponent =
        this.ForEachSpan<T0, T1>(
            (mutable entIds, mutable buffer0, mutable buffer1) ->
                let count = entIds.Length
                let mutable i = 0
                while (i < count)
                    f(entIds[i], &buffer0[i], &buffer1[i])
                    i <- i + 1
        )
          
    #[inline]
    ForEach<T0, T1, T2>(#[inline] f: scoped (EntityId, byref<T0>, byref<T1>, byref<T2>) -> ()): () where T0: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                                  where T1: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                                  where T2: blittable, struct, ValueType, { new() }, trait IComponent =
        this.ForEachSpan<T0, T1, T2>(
            (mutable entIds, mutable buffer0, mutable buffer1, mutable buffer2) ->
                let count = entIds.Length
                let mutable i = 0
                while (i < count)
                    f(entIds[i], &buffer0[i], &buffer1[i], &buffer2[i])
                    i <- i + 1
        )

    #[inline]
    ForEach<T0, T1, T2>(filter: EntityFilter, #[inline] f: scoped (EntityId, byref<T0>, byref<T1>, byref<T2>) -> ()): () where T0: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                                  where T1: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                                  where T2: blittable, struct, ValueType, { new() }, trait IComponent =
        this.ForEachSpan<T0, T1, T2>(filter,
            (mutable entIds, mutable buffer0, mutable buffer1, mutable buffer2) ->
                let count = entIds.Length
                let mutable i = 0
                while (i < count)
                    f(entIds[i], &buffer0[i], &buffer1[i], &buffer2[i])
                    i <- i + 1
        )

    #[inline]
    ForEach<T0, T1, T2, T3>(filter: EntityFilter, #[inline] f: scoped (EntityId, byref<T0>, byref<T1>, byref<T2>, byref<T3>) -> ()): () 
            where T0: blittable, struct, ValueType, { new() }, trait IComponent 
            where T1: blittable, struct, ValueType, { new() }, trait IComponent 
            where T2: blittable, struct, ValueType, { new() }, trait IComponent 
            where T3: blittable, struct, ValueType, { new() }, trait IComponent =

        this.ForEachSpan<T0, T1, T2, T3>(filter,
            (mutable entIds, mutable buffer0, mutable buffer1, mutable buffer2, mutable buffer3) ->
                let count = entIds.Length
                let mutable i = 0
                while (i < count)
                    f(entIds[i], &buffer0[i], &buffer1[i], &buffer2[i], &buffer3[i])
                    i <- i + 1
        )

    #[inline]
    ForEach<T0, T1, T2, T3>(#[inline] f: scoped (EntityId, byref<T0>, byref<T1>, byref<T2>, byref<T3>) -> ()): () 
            where T0: blittable, struct, ValueType, { new() }, trait IComponent 
            where T1: blittable, struct, ValueType, { new() }, trait IComponent 
            where T2: blittable, struct, ValueType, { new() }, trait IComponent 
            where T3: blittable, struct, ValueType, { new() }, trait IComponent =
        this.ForEach(EntityFilter.None(), f)

    #[inline]
    ForEach<T0, T1, T2, T3, T4>(filter: EntityFilter, #[inline] f: scoped (EntityId, byref<T0>, byref<T1>, byref<T2>, byref<T3>, byref<T4>) -> ()): () 
            where T0: blittable, struct, ValueType, { new() }, trait IComponent 
            where T1: blittable, struct, ValueType, { new() }, trait IComponent 
            where T2: blittable, struct, ValueType, { new() }, trait IComponent 
            where T3: blittable, struct, ValueType, { new() }, trait IComponent
            where T4: blittable, struct, ValueType, { new() }, trait IComponent =

        this.ForEachSpan<T0, T1, T2, T3, T4>(filter,
            (mutable entIds, mutable buffer0, mutable buffer1, mutable buffer2, mutable buffer3, mutable buffer4) ->
                let count = entIds.Length
                let mutable i = 0
                while (i < count)
                    f(entIds[i], &buffer0[i], &buffer1[i], &buffer2[i], &buffer3[i], &buffer4[i])
                    i <- i + 1
        )

    #[inline]
    ForEach<T0, T1, T2, T3, T4>(#[inline] f: scoped (EntityId, byref<T0>, byref<T1>, byref<T2>, byref<T3>, byref<T4>) -> ()): () 
            where T0: blittable, struct, ValueType, { new() }, trait IComponent 
            where T1: blittable, struct, ValueType, { new() }, trait IComponent 
            where T2: blittable, struct, ValueType, { new() }, trait IComponent 
            where T3: blittable, struct, ValueType, { new() }, trait IComponent
            where T4: blittable, struct, ValueType, { new() }, trait IComponent =

        this.ForEachSpan<T0, T1, T2, T3, T4>(EntityFilter.None(),
            (mutable entIds, mutable buffer0, mutable buffer1, mutable buffer2, mutable buffer3, mutable buffer4) ->
                let count = entIds.Length
                let mutable i = 0
                while (i < count)
                    f(entIds[i], &buffer0[i], &buffer1[i], &buffer2[i], &buffer3[i], &buffer4[i])
                    i <- i + 1
        )

    #[inline]
    ForEach<T0, T1, T2, T3, T4, T5>(#[inline] f: scoped (EntityId, byref<T0>, byref<T1>, byref<T2>, byref<T3>, byref<T4>, byref<T5>) -> ()): () where T0: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                                                                               where T1: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                                                                               where T2: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                                                                               where T3: blittable, struct, ValueType, { new() }, trait IComponent
                                                                                                                               where T4: blittable, struct, ValueType, { new() }, trait IComponent
                                                                                                                               where T5: blittable, struct, ValueType, { new() }, trait IComponent =

        this.ForEachSpan<T0, T1, T2, T3, T4, T5>(
            (mutable entIds, mutable buffer0, mutable buffer1, mutable buffer2, mutable buffer3, mutable buffer4, mutable buffer5) ->
                let count = entIds.Length
                let mutable i = 0
                while (i < count)
                    f(entIds[i], &buffer0[i], &buffer1[i], &buffer2[i], &buffer3[i], &buffer4[i], &buffer5[i])
                    i <- i + 1
        )

    #[inline]
    ForEach<T0, T1, T2, T3, T4, T5, T6>(#[inline] f: scoped (EntityId, byref<T0>, byref<T1>, byref<T2>, byref<T3>, byref<T4>, byref<T5>, byref<T6>) -> ()): () 
            where T0: blittable, struct, ValueType, { new() }, trait IComponent 
            where T1: blittable, struct, ValueType, { new() }, trait IComponent 
            where T2: blittable, struct, ValueType, { new() }, trait IComponent 
            where T3: blittable, struct, ValueType, { new() }, trait IComponent
            where T4: blittable, struct, ValueType, { new() }, trait IComponent
            where T5: blittable, struct, ValueType, { new() }, trait IComponent 
            where T6: blittable, struct, ValueType, { new() }, trait IComponent =

        this.ForEachSpan<T0, T1, T2, T3, T4, T5, T6>(
            (mutable entIds, mutable buffer0, mutable buffer1, mutable buffer2, mutable buffer3, mutable buffer4, mutable buffer5, mutable buffer6) ->
                let count = entIds.Length
                let mutable i = 0
                while (i < count)
                    f(entIds[i], &buffer0[i], &buffer1[i], &buffer2[i], &buffer3[i], &buffer4[i], &buffer5[i], &buffer6[i])
                    i <- i + 1
        )
            
    Create<T0>(value0: T0): EntityId where T0: blittable, struct, ValueType, { new() }, trait IComponent =
        this.Create(&value0)
    Create<T0>(value0: inref<T0>): EntityId where T0: blittable, struct, ValueType, { new() }, trait IComponent =
        this.ThrowIfParallelDepth()

        let lookup = this.entityIndexLookup

        let archetypeId = GetArchetypeId<T0>()
        let archetypedIndex = this.GetArchetypedIndex(archetypeId)
        let typedIndex0 = this.GetTypedIndex<T0>(archetypedIndex)

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.GetArchetype(archetypedIndex)
        let index = archetype.Count
        archetype.Count <- index + 1
        lookup[entId.Index] <- index
        archetype.EntityIds.SetAs(index, entId)

        archetype.ClearComponentAttachmentsAt(index)

        archetype.Set(typedIndex0, index, value0)

        this.IncrementDepth()
        archetype.TriggerComponentAdded(archetype.FullId, index)
        this.DecrementDepth()

        entId

    Create<T0, T1>(value0: T0, value1: T1): EntityId where T0: blittable, struct, ValueType, { new() }, trait IComponent
                                                     where T1: blittable, struct, ValueType, { new() }, trait IComponent =
        this.Create(&value0, &value1)
    Create<T0, T1>(value0: inref<T0>, value1: inref<T1>): EntityId where T0: blittable, struct, ValueType, { new() }, trait IComponent
                                                                   where T1: blittable, struct, ValueType, { new() }, trait IComponent =
        this.ThrowIfParallelDepth()

        let lookup = this.entityIndexLookup

        let archetypeId = GetArchetypeId<T0, T1>()
        let archetypedIndex = this.GetArchetypedIndex(archetypeId)
        let typedIndex0 = this.GetTypedIndex<T0>(archetypedIndex)
        let typedIndex1 = this.GetTypedIndex<T1>(archetypedIndex)

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.GetArchetype(archetypedIndex)
        let index = archetype.Count
        archetype.Count <- index + 1
        lookup[entId.Index] <- index
        archetype.EntityIds.SetAs(index, entId)

        archetype.ClearComponentAttachmentsAt(index)

        archetype.Set(typedIndex0, index, value0)
        archetype.Set(typedIndex1, index, value1)

        this.IncrementDepth()
        archetype.TriggerComponentAdded(archetype.FullId, index)
        this.DecrementDepth()

        entId

    Create<T0, T1, T2>(value0: T0, value1: T1, value2: T2): EntityId where T0: blittable, struct, ValueType, { new() }, trait IComponent
                                                                     where T1: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                     where T2: blittable, struct, ValueType, { new() }, trait IComponent = 
        this.Create(&value0, &value1, &value2)
    Create<T0, T1, T2>(value0: inref<T0>, value1: inref<T1>, value2: inref<T2>): EntityId where T0: blittable, struct, ValueType, { new() }, trait IComponent
                                                                                          where T1: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                                          where T2: blittable, struct, ValueType, { new() }, trait IComponent =   
        this.ThrowIfParallelDepth()

        let lookup = this.entityIndexLookup

        let archetypeId = GetArchetypeId<T0, T1, T2>()
        let archetypedIndex = this.GetArchetypedIndex(archetypeId)
        let typedIndex0 = this.GetTypedIndex<T0>(archetypedIndex)
        let typedIndex1 = this.GetTypedIndex<T1>(archetypedIndex)
        let typedIndex2 = this.GetTypedIndex<T2>(archetypedIndex)

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.GetArchetype(archetypedIndex)
        let index = archetype.Count
        archetype.Count <- index + 1
        lookup[entId.Index] <- index
        archetype.EntityIds.SetAs(index, entId)

        archetype.ClearComponentAttachmentsAt(index)

        archetype.Set(typedIndex0, index, value0)
        archetype.Set(typedIndex1, index, value1)
        archetype.Set(typedIndex2, index, value2)

        this.IncrementDepth()
        archetype.TriggerComponentAdded(archetype.FullId, index)
        this.DecrementDepth()

        entId

    Create<T0, T1, T2, T3>(value0: T0, value1: T1, value2: T2, value3: T3): EntityId where T0: blittable, struct, ValueType, { new() }, trait IComponent
                                                                                     where T1: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                                     where T2: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                                     where T3: blittable, struct, ValueType, { new() }, trait IComponent = 
        this.Create(&value0, &value1, &value2, &value3)
    Create<T0, T1, T2, T3>(value0: inref<T0>, value1: inref<T1>, value2: inref<T2>, value3: inref<T3>): EntityId where T0: blittable, struct, ValueType, { new() }, trait IComponent
                                                                                                                 where T1: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                                                                 where T2: blittable, struct, ValueType, { new() }, trait IComponent
                                                                                                                 where T3: blittable, struct, ValueType, { new() }, trait IComponent =
        this.ThrowIfParallelDepth()

        let lookup = this.entityIndexLookup

        let archetypeId = GetArchetypeId<T0, T1, T2, T3>()
        let archetypedIndex = this.GetArchetypedIndex(archetypeId)
        let typedIndex0 = this.GetTypedIndex<T0>(archetypedIndex)
        let typedIndex1 = this.GetTypedIndex<T1>(archetypedIndex)
        let typedIndex2 = this.GetTypedIndex<T2>(archetypedIndex)
        let typedIndex3 = this.GetTypedIndex<T3>(archetypedIndex)

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.GetArchetype(archetypedIndex)
        let index = archetype.Count
        archetype.Count <- index + 1
        lookup[entId.Index] <- index
        archetype.EntityIds.SetAs(index, entId)

        archetype.ClearComponentAttachmentsAt(index)

        archetype.Set(typedIndex0, index, value0)
        archetype.Set(typedIndex1, index, value1)
        archetype.Set(typedIndex2, index, value2)
        archetype.Set(typedIndex3, index, value3)

        this.IncrementDepth()
        archetype.TriggerComponentAdded(archetype.FullId, index)
        this.DecrementDepth()

        entId

    Create<T0, T1, T2, T3, T4>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4): EntityId where T0: blittable, struct, ValueType, { new() }, trait IComponent
                                                                                                     where T1: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                                                     where T2: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                                                     where T3: blittable, struct, ValueType, { new() }, trait IComponent
                                                                                                     where T4: blittable, struct, ValueType, { new() }, trait IComponent = 
        this.Create(&value0, &value1, &value2, &value3, &value4)
    Create<T0, T1, T2, T3, T4>(value0: inref<T0>, value1: inref<T1>, value2: inref<T2>, value3: inref<T3>, value4: inref<T4>): EntityId where T0: blittable, struct, ValueType, { new() }, trait IComponent
                                                                                                                                        where T1: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                                                                                        where T2: blittable, struct, ValueType, { new() }, trait IComponent
                                                                                                                                        where T3: blittable, struct, ValueType, { new() }, trait IComponent
                                                                                                                                        where T4: blittable, struct, ValueType, { new() }, trait IComponent =
        this.ThrowIfParallelDepth()

        let lookup = this.entityIndexLookup

        let archetypeId = GetArchetypeId<T0, T1, T2, T3, T4>()
        let archetypedIndex = this.GetArchetypedIndex(archetypeId)
        let typedIndex0 = this.GetTypedIndex<T0>(archetypedIndex)
        let typedIndex1 = this.GetTypedIndex<T1>(archetypedIndex)
        let typedIndex2 = this.GetTypedIndex<T2>(archetypedIndex)
        let typedIndex3 = this.GetTypedIndex<T3>(archetypedIndex)
        let typedIndex4 = this.GetTypedIndex<T4>(archetypedIndex)

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.GetArchetype(archetypedIndex)
        let index = archetype.Count
        archetype.Count <- index + 1
        lookup[entId.Index] <- index
        archetype.EntityIds.SetAs(index, entId)

        archetype.ClearComponentAttachmentsAt(index)

        archetype.Set(typedIndex0, index, value0)
        archetype.Set(typedIndex1, index, value1)
        archetype.Set(typedIndex2, index, value2)
        archetype.Set(typedIndex3, index, value3)
        archetype.Set(typedIndex4, index, value4)

        this.IncrementDepth()
        archetype.TriggerComponentAdded(archetype.FullId, index)
        this.DecrementDepth()

        entId

    Create<T0, T1, T2, T3, T4, T5>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5): EntityId where T0: blittable, struct, ValueType, { new() }, trait IComponent
                                                                                                                     where T1: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                                                                     where T2: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                                                                     where T3: blittable, struct, ValueType, { new() }, trait IComponent
                                                                                                                     where T4: blittable, struct, ValueType, { new() }, trait IComponent
                                                                                                                     where T5: blittable, struct, ValueType, { new() }, trait IComponent = 
        this.Create(&value0, &value1, &value2, &value3, &value4, &value5)
    Create<T0, T1, T2, T3, T4, T5>(value0: inref<T0>, value1: inref<T1>, value2: inref<T2>, value3: inref<T3>, value4: inref<T4>, value5: inref<T5>): EntityId where T0: blittable, struct, ValueType, { new() }, trait IComponent
                                                                                                                                                               where T1: blittable, struct, ValueType, { new() }, trait IComponent 
                                                                                                                                                               where T2: blittable, struct, ValueType, { new() }, trait IComponent
                                                                                                                                                               where T3: blittable, struct, ValueType, { new() }, trait IComponent
                                                                                                                                                               where T4: blittable, struct, ValueType, { new() }, trait IComponent
                                                                                                                                                               where T5: blittable, struct, ValueType, { new() }, trait IComponent =      
        this.ThrowIfParallelDepth()

        let lookup = this.entityIndexLookup

        let archetypeId = GetArchetypeId<T0, T1, T2, T3, T4, T5>()
        let archetypedIndex = this.GetArchetypedIndex(archetypeId)
        let typedIndex0 = this.GetTypedIndex<T0>(archetypedIndex)
        let typedIndex1 = this.GetTypedIndex<T1>(archetypedIndex)
        let typedIndex2 = this.GetTypedIndex<T2>(archetypedIndex)
        let typedIndex3 = this.GetTypedIndex<T3>(archetypedIndex)
        let typedIndex4 = this.GetTypedIndex<T4>(archetypedIndex)
        let typedIndex5 = this.GetTypedIndex<T5>(archetypedIndex)

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.GetArchetype(archetypedIndex)
        let index = archetype.Count
        archetype.Count <- index + 1
        lookup[entId.Index] <- index
        archetype.EntityIds.SetAs(index, entId)

        archetype.ClearComponentAttachmentsAt(index)

        archetype.Set(typedIndex0, index, value0)
        archetype.Set(typedIndex1, index, value1)
        archetype.Set(typedIndex2, index, value2)
        archetype.Set(typedIndex3, index, value3)
        archetype.Set(typedIndex4, index, value4)
        archetype.Set(typedIndex5, index, value5)

        this.IncrementDepth()
        archetype.TriggerComponentAdded(archetype.FullId, index)
        this.DecrementDepth()

        entId

    Create<T0, T1, T2, T3, T4, T5, T6>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6): EntityId 
            where T0: blittable, struct, ValueType, { new() }, trait IComponent
            where T1: blittable, struct, ValueType, { new() }, trait IComponent 
            where T2: blittable, struct, ValueType, { new() }, trait IComponent 
            where T3: blittable, struct, ValueType, { new() }, trait IComponent
            where T4: blittable, struct, ValueType, { new() }, trait IComponent
            where T5: blittable, struct, ValueType, { new() }, trait IComponent 
            where T6: blittable, struct, ValueType, { new() }, trait IComponent = 
        this.Create(&value0, &value1, &value2, &value3, &value4, &value5, &value6)
    Create<T0, T1, T2, T3, T4, T5, T6>(value0: inref<T0>, value1: inref<T1>, value2: inref<T2>, value3: inref<T3>, value4: inref<T4>, value5: inref<T5>, value6: inref<T6>): EntityId 
            where T0: blittable, struct, ValueType, { new() }, trait IComponent
            where T1: blittable, struct, ValueType, { new() }, trait IComponent 
            where T2: blittable, struct, ValueType, { new() }, trait IComponent
            where T3: blittable, struct, ValueType, { new() }, trait IComponent
            where T4: blittable, struct, ValueType, { new() }, trait IComponent
            where T5: blittable, struct, ValueType, { new() }, trait IComponent
            where T6: blittable, struct, ValueType, { new() }, trait IComponent =      
        this.ThrowIfParallelDepth()

        let lookup = this.entityIndexLookup

        let archetypeId = GetArchetypeId<T0, T1, T2, T3, T4, T5, T6>()
        let archetypedIndex = this.GetArchetypedIndex(archetypeId)
        let typedIndex0 = this.GetTypedIndex<T0>(archetypedIndex)
        let typedIndex1 = this.GetTypedIndex<T1>(archetypedIndex)
        let typedIndex2 = this.GetTypedIndex<T2>(archetypedIndex)
        let typedIndex3 = this.GetTypedIndex<T3>(archetypedIndex)
        let typedIndex4 = this.GetTypedIndex<T4>(archetypedIndex)
        let typedIndex5 = this.GetTypedIndex<T5>(archetypedIndex)
        let typedIndex6 = this.GetTypedIndex<T6>(archetypedIndex)

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.GetArchetype(archetypedIndex)
        let index = archetype.Count
        archetype.Count <- index + 1
        lookup[entId.Index] <- index
        archetype.EntityIds.SetAs(index, entId)

        archetype.ClearComponentAttachmentsAt(index)

        archetype.Set(typedIndex0, index, value0)
        archetype.Set(typedIndex1, index, value1)
        archetype.Set(typedIndex2, index, value2)
        archetype.Set(typedIndex3, index, value3)
        archetype.Set(typedIndex4, index, value4)
        archetype.Set(typedIndex5, index, value5)
        archetype.Set(typedIndex6, index, value6)

        this.IncrementDepth()
        archetype.TriggerComponentAdded(archetype.FullId, index)
        this.DecrementDepth()

        entId

    Create<T0, T1, T2, T3, T4, T5, T6, T7>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7): EntityId 
            where T0: blittable, struct, ValueType, { new() }, trait IComponent
            where T1: blittable, struct, ValueType, { new() }, trait IComponent 
            where T2: blittable, struct, ValueType, { new() }, trait IComponent 
            where T3: blittable, struct, ValueType, { new() }, trait IComponent
            where T4: blittable, struct, ValueType, { new() }, trait IComponent
            where T5: blittable, struct, ValueType, { new() }, trait IComponent 
            where T6: blittable, struct, ValueType, { new() }, trait IComponent 
            where T7: blittable, struct, ValueType, { new() }, trait IComponent = 
        this.Create(&value0, &value1, &value2, &value3, &value4, &value5, &value6, &value7)
    Create<T0, T1, T2, T3, T4, T5, T6, T7>(value0: inref<T0>, value1: inref<T1>, value2: inref<T2>, value3: inref<T3>, value4: inref<T4>, value5: inref<T5>, value6: inref<T6>, value7: inref<T7>): EntityId 
            where T0: blittable, struct, ValueType, { new() }, trait IComponent
            where T1: blittable, struct, ValueType, { new() }, trait IComponent 
            where T2: blittable, struct, ValueType, { new() }, trait IComponent
            where T3: blittable, struct, ValueType, { new() }, trait IComponent
            where T4: blittable, struct, ValueType, { new() }, trait IComponent
            where T5: blittable, struct, ValueType, { new() }, trait IComponent
            where T6: blittable, struct, ValueType, { new() }, trait IComponent
            where T7: blittable, struct, ValueType, { new() }, trait IComponent =      
        this.ThrowIfParallelDepth()

        let lookup = this.entityIndexLookup

        let archetypeId = GetArchetypeId<T0, T1, T2, T3, T4, T5, T6, T7>()
        let archetypedIndex = this.GetArchetypedIndex(archetypeId)
        let typedIndex0 = this.GetTypedIndex<T0>(archetypedIndex)
        let typedIndex1 = this.GetTypedIndex<T1>(archetypedIndex)
        let typedIndex2 = this.GetTypedIndex<T2>(archetypedIndex)
        let typedIndex3 = this.GetTypedIndex<T3>(archetypedIndex)
        let typedIndex4 = this.GetTypedIndex<T4>(archetypedIndex)
        let typedIndex5 = this.GetTypedIndex<T5>(archetypedIndex)
        let typedIndex6 = this.GetTypedIndex<T6>(archetypedIndex)
        let typedIndex7 = this.GetTypedIndex<T7>(archetypedIndex)

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.GetArchetype(archetypedIndex)
        let index = archetype.Count
        archetype.Count <- index + 1
        lookup[entId.Index] <- index
        archetype.EntityIds.SetAs(index, entId)

        archetype.ClearComponentAttachmentsAt(index)

        archetype.Set(typedIndex0, index, value0)
        archetype.Set(typedIndex1, index, value1)
        archetype.Set(typedIndex2, index, value2)
        archetype.Set(typedIndex3, index, value3)
        archetype.Set(typedIndex4, index, value4)
        archetype.Set(typedIndex5, index, value5)
        archetype.Set(typedIndex6, index, value6)
        archetype.Set(typedIndex7, index, value7)

        this.IncrementDepth()
        archetype.TriggerComponentAdded(archetype.FullId, index)
        this.DecrementDepth()

        entId

    Create<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7, value8: T8): EntityId 
            where T0: blittable, struct, ValueType, { new() }, trait IComponent
            where T1: blittable, struct, ValueType, { new() }, trait IComponent 
            where T2: blittable, struct, ValueType, { new() }, trait IComponent 
            where T3: blittable, struct, ValueType, { new() }, trait IComponent
            where T4: blittable, struct, ValueType, { new() }, trait IComponent
            where T5: blittable, struct, ValueType, { new() }, trait IComponent 
            where T6: blittable, struct, ValueType, { new() }, trait IComponent 
            where T7: blittable, struct, ValueType, { new() }, trait IComponent 
            where T8: blittable, struct, ValueType, { new() }, trait IComponent = 
        this.Create(&value0, &value1, &value2, &value3, &value4, &value5, &value6, &value7, &value8)
    Create<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value0: inref<T0>, value1: inref<T1>, value2: inref<T2>, value3: inref<T3>, value4: inref<T4>, value5: inref<T5>, value6: inref<T6>, value7: inref<T7>, value8: inref<T8>): EntityId 
            where T0: blittable, struct, ValueType, { new() }, trait IComponent
            where T1: blittable, struct, ValueType, { new() }, trait IComponent 
            where T2: blittable, struct, ValueType, { new() }, trait IComponent
            where T3: blittable, struct, ValueType, { new() }, trait IComponent
            where T4: blittable, struct, ValueType, { new() }, trait IComponent
            where T5: blittable, struct, ValueType, { new() }, trait IComponent
            where T6: blittable, struct, ValueType, { new() }, trait IComponent
            where T7: blittable, struct, ValueType, { new() }, trait IComponent
            where T8: blittable, struct, ValueType, { new() }, trait IComponent =      
        this.ThrowIfParallelDepth()

        let lookup = this.entityIndexLookup

        let archetypeId = GetArchetypeId<T0, T1, T2, T3, T4, T5, T6, T7, T8>()
        let archetypedIndex = this.GetArchetypedIndex(archetypeId)
        let typedIndex0 = this.GetTypedIndex<T0>(archetypedIndex)
        let typedIndex1 = this.GetTypedIndex<T1>(archetypedIndex)
        let typedIndex2 = this.GetTypedIndex<T2>(archetypedIndex)
        let typedIndex3 = this.GetTypedIndex<T3>(archetypedIndex)
        let typedIndex4 = this.GetTypedIndex<T4>(archetypedIndex)
        let typedIndex5 = this.GetTypedIndex<T5>(archetypedIndex)
        let typedIndex6 = this.GetTypedIndex<T6>(archetypedIndex)
        let typedIndex7 = this.GetTypedIndex<T7>(archetypedIndex)

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.GetArchetype(archetypedIndex)
        let index = archetype.Count
        archetype.Count <- index + 1
        lookup[entId.Index] <- index
        archetype.EntityIds.SetAs(index, entId)

        archetype.ClearComponentAttachmentsAt(index)

        archetype.Set(typedIndex0, index, value0)
        archetype.Set(typedIndex1, index, value1)
        archetype.Set(typedIndex2, index, value2)
        archetype.Set(typedIndex3, index, value3)
        archetype.Set(typedIndex4, index, value4)
        archetype.Set(typedIndex5, index, value5)
        archetype.Set(typedIndex6, index, value6)
        archetype.Set(typedIndex7, index, value7)

        this.IncrementDepth()
        archetype.TriggerComponentAdded(archetype.FullId, index)
        this.DecrementDepth()

        entId

    Create<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7, value8: T8, value9: T9): EntityId 
            where T0: blittable, struct, ValueType, { new() }, trait IComponent
            where T1: blittable, struct, ValueType, { new() }, trait IComponent 
            where T2: blittable, struct, ValueType, { new() }, trait IComponent 
            where T3: blittable, struct, ValueType, { new() }, trait IComponent
            where T4: blittable, struct, ValueType, { new() }, trait IComponent
            where T5: blittable, struct, ValueType, { new() }, trait IComponent 
            where T6: blittable, struct, ValueType, { new() }, trait IComponent 
            where T7: blittable, struct, ValueType, { new() }, trait IComponent 
            where T8: blittable, struct, ValueType, { new() }, trait IComponent
            where T9: blittable, struct, ValueType, { new() }, trait IComponent = 
        this.Create(&value0, &value1, &value2, &value3, &value4, &value5, &value6, &value7, &value8, &value9)
    Create<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(value0: inref<T0>, value1: inref<T1>, value2: inref<T2>, value3: inref<T3>, value4: inref<T4>, value5: inref<T5>, value6: inref<T6>, value7: inref<T7>, value8: inref<T8>, value9: inref<T9>): EntityId 
            where T0: blittable, struct, ValueType, { new() }, trait IComponent
            where T1: blittable, struct, ValueType, { new() }, trait IComponent 
            where T2: blittable, struct, ValueType, { new() }, trait IComponent
            where T3: blittable, struct, ValueType, { new() }, trait IComponent
            where T4: blittable, struct, ValueType, { new() }, trait IComponent
            where T5: blittable, struct, ValueType, { new() }, trait IComponent
            where T6: blittable, struct, ValueType, { new() }, trait IComponent
            where T7: blittable, struct, ValueType, { new() }, trait IComponent
            where T8: blittable, struct, ValueType, { new() }, trait IComponent
            where T9: blittable, struct, ValueType, { new() }, trait IComponent =      
        this.ThrowIfParallelDepth()

        let lookup = this.entityIndexLookup

        let archetypeId = GetArchetypeId<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>()
        let archetypedIndex = this.GetArchetypedIndex(archetypeId)
        let typedIndex0 = this.GetTypedIndex<T0>(archetypedIndex)
        let typedIndex1 = this.GetTypedIndex<T1>(archetypedIndex)
        let typedIndex2 = this.GetTypedIndex<T2>(archetypedIndex)
        let typedIndex3 = this.GetTypedIndex<T3>(archetypedIndex)
        let typedIndex4 = this.GetTypedIndex<T4>(archetypedIndex)
        let typedIndex5 = this.GetTypedIndex<T5>(archetypedIndex)
        let typedIndex6 = this.GetTypedIndex<T6>(archetypedIndex)
        let typedIndex7 = this.GetTypedIndex<T7>(archetypedIndex)
        let typedIndex8 = this.GetTypedIndex<T8>(archetypedIndex)

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.GetArchetype(archetypedIndex)
        let index = archetype.Count
        archetype.Count <- index + 1
        lookup[entId.Index] <- index
        archetype.EntityIds.SetAs(index, entId)

        archetype.ClearComponentAttachmentsAt(index)

        archetype.Set(typedIndex0, index, value0)
        archetype.Set(typedIndex1, index, value1)
        archetype.Set(typedIndex2, index, value2)
        archetype.Set(typedIndex3, index, value3)
        archetype.Set(typedIndex4, index, value4)
        archetype.Set(typedIndex5, index, value5)
        archetype.Set(typedIndex6, index, value6)
        archetype.Set(typedIndex7, index, value7)
        archetype.Set(typedIndex8, index, value8)

        this.IncrementDepth()
        archetype.TriggerComponentAdded(archetype.FullId, index)
        this.DecrementDepth()

        entId

    private AddCore(entId: EntityId, typeId: ComponentId, diff: byref<ArchetypeId>): Archetype =
        this.Check(entId)

        let srcArchetypedIndex = this.entityArchetypeIndices[entId.Index]
        let srcArchetype = this.GetArchetype(srcArchetypedIndex)
        let srcArchetypeId = srcArchetype.Id

        if (srcArchetypeId.IsSupersetOf(typeId))
            srcArchetype
        else
            let lookup = this.entityIndexLookup

            let dstArchetypeId = srcArchetypeId | typeId
            let dstArchetypedIndex = this.GetArchetypedIndex(dstArchetypeId)//this.TryGetArchetypedIndex(dstArchetypeId)
            if (dstArchetypedIndex == -1)
                unchecked default
            else
                let dstArchetype = this.GetArchetype(dstArchetypedIndex)

                let srcIndex = lookup[entId.Index]
                let dstIndex = dstArchetype.Count

                // Copy components
                dstArchetype.Count <- dstIndex + 1
                srcArchetype.CopyOneTo(srcIndex, dstArchetype, dstIndex)
                dstArchetype.EntityIds.SetAs(dstIndex, entId)

                // Remove leftovers by swapping
                let lastSrcIndex = srcArchetype.Count - 1
                let lastEntId = srcArchetype.EntityIds.GetAs<EntityId>(lastSrcIndex)
                srcArchetype.CopyOneTo(lastSrcIndex, srcArchetype, srcIndex)
                lookup[lastEntId.Index] <- srcIndex
                lookup[entId.Index] <- dstIndex
                
                srcArchetype.EntityIds.SetAs(srcIndex, lastEntId)
                srcArchetype.Count <- lastSrcIndex    

                this.entityArchetypeIndices[entId.Index] <- dstArchetypedIndex

                diff <- dstArchetype.FullId & srcArchetype.FullId.BitwiseNot()

                dstArchetype

    TryAddOrUpdate<T>(entId: EntityId, value: T): () where T: blittable, struct, ValueType, { new() }, trait IComponent =
        this.TryAddOrUpdate(entId, &value)
    TryAddOrUpdate<T>(mutable entId: EntityId, value: inref<T>): () where T: blittable, struct, ValueType, { new() }, trait IComponent =
        this.ThrowIfDepth()
        this.ThrowIfParallelDepth()
        if (this.IsValid(entId))
            let lookup = this.entityIndexLookup
            let tyId: ComponentId = T.GetId()

            let mutable diff = default
            let archetype = this.AddCore(entId, tyId, &diff)
            if (archetype !== unchecked default)
                let index = lookup[entId.Index]
                archetype.Set(archetype.BufferLookup[tyId], index, value)

                if (!diff.IsZero)
                    archetype.TriggerComponentAdded(diff, index)
            else
                let currentArchetype = this.GetArchetype(this.entityArchetypeIndices[entId.Index])
#if DEBUG
                fail("Cannot add component '" + T.GetName() + "' to entity '" + entId.ToString() + "'. The resulting archetype is not registered:\n\t" + currentArchetype.ComponentListNoAttachmentsText + T.GetName() + ",")
#end
                LogError("Cannot add component '" + T.GetName() + "' to entity '" + entId.ToString() + "'. The resulting archetype is not registered:\n\t" + currentArchetype.ComponentListNoAttachmentsText + T.GetName() + ",")

    TryRemove<T>(entId: EntityId): () where T: blittable, struct, ValueType, { new() }, trait IComponent =
        this.ThrowIfDepth()
        this.ThrowIfParallelDepth()
        if (this.IsValid(entId))
            let archetypeIndex = this.entityArchetypeIndices[entId.Index]
            if (archetypeIndex != -1)
                let archetype = this.GetArchetype(archetypeIndex)
                if (archetype.Id.IsSet(T.GetIndex()))
                    let compId: ComponentId = T.GetId()
                    let lookupIndex = this.entityIndexLookup[entId.Index]

                    archetype.TriggerComponentRemoving(compId, lookupIndex)

                    let newArchetypeId = archetype.Id & compId.BitwiseNot()
                    let newArchetypeIndex = this.GetArchetypedIndex(newArchetypeId)
                    let newArchetype = this.GetArchetype(newArchetypeIndex)
                    let newLookupIndex = newArchetype.Count
                    newArchetype.Count <- newArchetype.Count + 1
                    newArchetype.EntityIds.SetAs(newLookupIndex, entId)

                    archetype.CopyOneTo(lookupIndex, newArchetype, newLookupIndex)
                    this.entityArchetypeIndices[entId.Index] <- newArchetypeIndex
                    this.entityIndexLookup[entId.Index] <- newLookupIndex
                    this.SwapRemoveEntityByLookupIndex(archetype, lookupIndex)
                    
                    this.DebugCheckIntegrity()

    Has<T>(entId: EntityId): bool where T: blittable, struct, ValueType, { new() }, trait IComponent =
        let index = this.entityArchetypeIndices[entId.Index]
        if (index == -1)
            false
        else
            let archetype = this.GetArchetype(index)
            archetype.FullId.IsSet(T.GetIndex())

    Exists<T>(entId: EntityId, condition: scoped inref<T> -> bool): bool where T: blittable, struct, ValueType, { new() }, trait IComponent =
        let mutable result = false
        // TODO-language-bug: 'condition(x)' should give a proper range for error message.
        let _ = this.TryGet<T>(entId, x -> result <- condition(&x))
        result

    #[inline]
    TryGet<T>(entId: EntityId, #[inline] callback: scoped byref<T> -> ()): bool where T: blittable, struct, ValueType, { new() }, trait IComponent =
        let index = this.entityArchetypeIndices[entId.Index]
        if (index == -1)
            false
        else
            let archetype = this.GetArchetype(index)
            let tyIndex = T.GetIndex()
            if (archetype.FullId.IsSet(tyIndex))
                let lookup = this.entityIndexLookup
                this.IncrementDepth()
                callback(&archetype.Get(archetype.BufferLookupByIndex[tyIndex], lookup[entId.Index]))
                this.DecrementDepth()

                true
            else
                false

    #[inline]
    TryGet<T0, T1>(entId: EntityId, #[inline] callback: scoped (byref<T0>, byref<T1>) -> ()): bool where T0: blittable, struct, ValueType, { new() }, trait IComponent where T1: blittable, struct, ValueType, { new() }, trait IComponent =
        let index = this.entityArchetypeIndices[entId.Index]
        if (index == -1)
            false
        else
            let archetype = this.GetArchetype(index)
            let tyIndex0 = T0.GetIndex()
            let tyIndex1 = T1.GetIndex()
            let fullId = archetype.FullId
            if (fullId.IsSet(tyIndex0) && fullId.IsSet(tyIndex1))
                let lookup = this.entityIndexLookup
                this.IncrementDepth()
                callback(
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex0], lookup[entId.Index]),
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex1], lookup[entId.Index])
                )
                this.DecrementDepth()
                true
            else
                false

    #[inline]
    If<T0, T1>(entId: EntityId, #[inline] callback: scoped (byref<T0>, byref<T1>) -> ()): () where T0: blittable, struct, ValueType, { new() }, trait IComponent where T1: blittable, struct, ValueType, { new() }, trait IComponent =
        let _ = this.TryGet<T0, T1>(entId, callback)

    #[inline]
    TryGet<T0, T1, T2>(entId: EntityId, #[inline] callback: scoped (byref<T0>, byref<T1>, byref<T2>) -> ()): bool where T0: blittable, struct, ValueType, { new() }, trait IComponent where T1: blittable, struct, ValueType, { new() }, trait IComponent where T2: blittable, struct, ValueType, { new() }, trait IComponent =
        let index = this.entityArchetypeIndices[entId.Index]
        if (index == -1)
            false
        else
            let archetype = this.GetArchetype(index)
            let tyIndex0 = T0.GetIndex()
            let tyIndex1 = T1.GetIndex()
            let tyIndex2 = T2.GetIndex()
            let fullId = archetype.FullId
            if (fullId.IsSet(tyIndex0) && fullId.IsSet(tyIndex1) && fullId.IsSet(tyIndex2))
                let lookup = this.entityIndexLookup
                this.IncrementDepth()
                callback(
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex0], lookup[entId.Index]),
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex1], lookup[entId.Index]),
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex2], lookup[entId.Index])
                )
                this.DecrementDepth()

                true
            else
                false

    #[inline]
    If<T0, T1, T2>(entId: EntityId, #[inline] callback: scoped (byref<T0>, byref<T1>, byref<T2>) -> ()): () where T0: blittable, struct, ValueType, { new() }, trait IComponent where T1: blittable, struct, ValueType, { new() }, trait IComponent where T2: blittable, struct, ValueType, { new() }, trait IComponent =
        let _ = this.TryGet<T0, T1, T2>(entId, callback)

    #[inline]
    TryGet<T0, T1, T2, T3>(entId: EntityId, #[inline] callback: scoped (byref<T0>, byref<T1>, byref<T2>, byref<T3>) -> ()): bool where T0: blittable, struct, ValueType, { new() }, trait IComponent where T1: blittable, struct, ValueType, { new() }, trait IComponent where T2: blittable, struct, ValueType, { new() }, trait IComponent where T3: blittable, struct, ValueType, { new() }, trait IComponent =
        let index = this.entityArchetypeIndices[entId.Index]
        if (index == -1)
            false
        else
            let archetype = this.GetArchetype(index)
            let tyIndex0 = T0.GetIndex()
            let tyIndex1 = T1.GetIndex()
            let tyIndex2 = T2.GetIndex()
            let tyIndex3 = T3.GetIndex()
            let fullId = archetype.FullId
            if (fullId.IsSet(tyIndex0) && fullId.IsSet(tyIndex1) && fullId.IsSet(tyIndex2) && fullId.IsSet(tyIndex3))
                let lookup = this.entityIndexLookup
                this.IncrementDepth()
                callback(
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex0], lookup[entId.Index]),
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex1], lookup[entId.Index]),
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex2], lookup[entId.Index]),
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex3], lookup[entId.Index])
                )
                this.DecrementDepth()

                true
            else
                false

    #[inline]
    TryGet<T0, T1, T2, T3, T4>(entId: EntityId, #[inline] callback: scoped (byref<T0>, byref<T1>, byref<T2>, byref<T3>, byref<T4>) -> ()): bool where T0: blittable, struct, ValueType, { new() }, trait IComponent where T1: blittable, struct, ValueType, { new() }, trait IComponent where T2: blittable, struct, ValueType, { new() }, trait IComponent where T3: blittable, struct, ValueType, { new() }, trait IComponent where T4: blittable, struct, ValueType, { new() }, trait IComponent =
        let index = this.entityArchetypeIndices[entId.Index]
        if (index == -1)
            false
        else
            let archetype = this.GetArchetype(index)
            let tyIndex0 = T0.GetIndex()
            let tyIndex1 = T1.GetIndex()
            let tyIndex2 = T2.GetIndex()
            let tyIndex3 = T3.GetIndex()
            let tyIndex4 = T4.GetIndex()
            let fullId = archetype.FullId
            if (fullId.IsSet(tyIndex0) && fullId.IsSet(tyIndex1) && fullId.IsSet(tyIndex2) && fullId.IsSet(tyIndex3) && fullId.IsSet(tyIndex4))
                let lookup = this.entityIndexLookup
                this.IncrementDepth()
                callback(
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex0], lookup[entId.Index]),
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex1], lookup[entId.Index]),
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex2], lookup[entId.Index]),
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex3], lookup[entId.Index]),
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex4], lookup[entId.Index])
                )
                this.DecrementDepth()

                true
            else
                false

    #[inline]
    TryGet<T0, T1, T2, T3, T4, T5>(entId: EntityId, #[inline] callback: scoped (byref<T0>, byref<T1>, byref<T2>, byref<T3>, byref<T4>, byref<T5>) -> ()): bool 
            where T0: blittable, struct, ValueType, { new() }, trait IComponent 
            where T1: blittable, struct, ValueType, { new() }, trait IComponent 
            where T2: blittable, struct, ValueType, { new() }, trait IComponent 
            where T3: blittable, struct, ValueType, { new() }, trait IComponent
            where T4: blittable, struct, ValueType, { new() }, trait IComponent
            where T5: blittable, struct, ValueType, { new() }, trait IComponent =
        let index = this.entityArchetypeIndices[entId.Index]
        if (index == -1)
            false
        else
            let archetype = this.GetArchetype(index)
            let tyIndex0 = T0.GetIndex()
            let tyIndex1 = T1.GetIndex()
            let tyIndex2 = T2.GetIndex()
            let tyIndex3 = T3.GetIndex()
            let tyIndex4 = T4.GetIndex()
            let tyIndex5 = T5.GetIndex()
            let fullId = archetype.FullId
            if (fullId.IsSet(tyIndex0) && fullId.IsSet(tyIndex1) && fullId.IsSet(tyIndex2) && fullId.IsSet(tyIndex3) && fullId.IsSet(tyIndex4) && fullId.IsSet(tyIndex5))
                let lookup = this.entityIndexLookup
                this.IncrementDepth()
                callback(
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex0], lookup[entId.Index]),
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex1], lookup[entId.Index]),
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex2], lookup[entId.Index]),
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex3], lookup[entId.Index]),
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex4], lookup[entId.Index]),
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex5], lookup[entId.Index])
                )
                this.DecrementDepth()

                true
            else
                false

    #[inline]
    TryGet<T0, T1, T2, T3, T4, T5, T6>(entId: EntityId, #[inline] callback: scoped (byref<T0>, byref<T1>, byref<T2>, byref<T3>, byref<T4>, byref<T5>, byref<T6>) -> ()): bool
            where T0: blittable, struct, ValueType, { new() }, trait IComponent 
            where T1: blittable, struct, ValueType, { new() }, trait IComponent 
            where T2: blittable, struct, ValueType, { new() }, trait IComponent 
            where T3: blittable, struct, ValueType, { new() }, trait IComponent
            where T4: blittable, struct, ValueType, { new() }, trait IComponent
            where T5: blittable, struct, ValueType, { new() }, trait IComponent
            where T6: blittable, struct, ValueType, { new() }, trait IComponent =
        let index = this.entityArchetypeIndices[entId.Index]
        if (index == -1)
            false
        else
            let archetype = this.GetArchetype(index)
            let tyIndex0 = T0.GetIndex()
            let tyIndex1 = T1.GetIndex()
            let tyIndex2 = T2.GetIndex()
            let tyIndex3 = T3.GetIndex()
            let tyIndex4 = T4.GetIndex()
            let tyIndex5 = T5.GetIndex()
            let tyIndex6 = T6.GetIndex()
            let fullId = archetype.FullId
            if (fullId.IsSet(tyIndex0) && fullId.IsSet(tyIndex1) && fullId.IsSet(tyIndex2) && fullId.IsSet(tyIndex3) && fullId.IsSet(tyIndex4) && fullId.IsSet(tyIndex5) && fullId.IsSet(tyIndex6))
                let lookup = this.entityIndexLookup
                this.IncrementDepth()
                callback(
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex0], lookup[entId.Index]),
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex1], lookup[entId.Index]),
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex2], lookup[entId.Index]),
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex3], lookup[entId.Index]),
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex4], lookup[entId.Index]),
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex5], lookup[entId.Index]),
                    &archetype.Get(archetype.BufferLookupByIndex[tyIndex6], lookup[entId.Index])
                )
                this.DecrementDepth()

                true
            else
                false

    private DeleteCore(entId: EntityId): () =
        this.ThrowIfDepth()
        this.ThrowIfParallelDepth()
        
        let archetypedIndex = this.entityArchetypeIndices[entId.Index]
        let archetype = this.GetArchetype(archetypedIndex)
        if (archetype.Count == 0)
            fail("Archetype is in an invalid state, no entity count for deletion")

        // ---
        let lookup = this.entityIndexLookup
        let index = lookup[entId.Index]

        this.IncrementDepth()
        archetype.TriggerComponentRemoving(archetype.FullId, index)
        this.DecrementDepth()

        this.SwapRemoveEntityByLookupIndex(archetype, index)
        // ---

        this.DeleteEntityId(entId)

    Delete(entId: EntityId): () =
        this.Check(entId)
        this.DeleteCore(entId)

    TryDelete(entId: EntityId): bool =
        if (this.IsValid(entId))
            this.DeleteCore(entId)
            true
        else
            false

    private SwapRemoveEntityByLookupIndex(archetype: Archetype, index: int32): () =
        let lastIndex = archetype.Count - 1
        let lastEntId = archetype.EntityIds.GetAs<EntityId>(lastIndex)

        let lookup = this.entityIndexLookup
        lookup[lastEntId.Index] <- index
        archetype.EntityIds.SetAs(index, lastEntId)

        let buffers = archetype.Buffers
        let mutable i = 0
        while (i < buffers.Length)
            let buffer = buffers[i].Store
            buffer.CopyOneTo(lastIndex, buffer, index)
            i <- i + 1

        archetype.Count <- archetype.Count - 1

    // ----------------------------------------------

    internal field mutable lastCreatedEntity: EntityId
    internal field mutable entityCount: int32
    private field entityArchetypeIndicesClear: mutable int32[]
    internal field entityArchetypeIndices: mutable int32[]
    internal field entityIndexLookup: mutable int32[]
    internal field entityVersions: mutable uint32[]

    internal field mutable lastCreatedLocalEntity: EntityId
    internal field mutable localEntityCount: int32

    internal NewEntityId(archetypedIndex: int32): EntityId =
        if (this.Archetypes[archetypedIndex].IsLocal)
            this.NewLocalEntityId(archetypedIndex)
        else
            ()
            if (!this.CanSpawnEntity)
                fail("Max entity count reached")
            let index =
                if (this.lastCreatedEntity.IsNil)
                    0
                else
                    let nextIndex = this.lastCreatedEntity.Index + 1
                    if (nextIndex == (EntityDatabase.MaxNumberOfEntities / 2))
                        0
                    else
                        nextIndex

            let version = 
                let version = this.entityVersions[index]
                if (version == 0)
                    version + 1 // first entity
                else
                    version // this is the next version
            this.entityVersions[index] <- version
            this.entityArchetypeIndices[index] <- archetypedIndex
            this.entityCount <- this.entityCount + 1

            let mutable entId = EntityId()
            entId.Index <- index
            entId.Version <- version
            this.lastCreatedEntity <- entId
            entId

    internal NewLocalEntityId(archetypedIndex: int32): EntityId =
        if (!this.CanSpawnLocalEntity)
            fail("Max local entity count reached")
        let index =
            if (this.lastCreatedLocalEntity.IsNil)
                EntityDatabase.MaxNumberOfEntities / 2
            else
                let nextIndex = this.lastCreatedLocalEntity.Index + 1
                if (nextIndex == EntityDatabase.MaxNumberOfEntities)
                    EntityDatabase.MaxNumberOfEntities / 2
                else
                    nextIndex

        let version = 
            let version = this.entityVersions[index]
            if (version == 0)
                version + 1 // first entity
            else
                version // this is the next version
        this.entityVersions[index] <- version
        this.entityArchetypeIndices[index] <- archetypedIndex
        this.localEntityCount <- this.localEntityCount + 1

        let mutable entId = EntityId()
        entId.Index <- index
        entId.Version <- version
        this.lastCreatedLocalEntity <- entId
        entId

    internal Check(entId: EntityId): () =
        if (!this.IsValid(entId))
            fail("Invalid entity.")

    private DeleteEntityId(entId: EntityId): () =
        this.entityVersions[entId.Index] <- this.entityVersions[entId.Index] + 1
        this.entityArchetypeIndices[entId.Index] <- -1

        if (this.IsLocal(entId))
            this.localEntityCount <- this.localEntityCount - 1
        else
            this.entityCount <- this.entityCount - 1

    IsValid(entId: EntityId): bool =
        this.entityArchetypeIndices[entId.Index] != -1 && this.entityVersions[entId.Index] == entId.Version

    IsLocal(entId: EntityId): bool =
        entId.Index >= (EntityDatabase.MaxNumberOfEntities / 2)

    CanSpawnEntity: bool get() = this.entityCount < (EntityDatabase.MaxNumberOfEntities / 2)

    CanSpawnLocalEntity: bool get() = this.localEntityCount < (EntityDatabase.MaxNumberOfEntities / 2)

    EntityCount: int32 get() = this.entityCount

    LocalEntityCount: int32 get() = this.localEntityCount

    private DebugCheckIntegrity(): () =
#if DEBUG
        let lookup = Dictionary<EntityId, Archetype>()
        let mutable i = 0
        while (i < this.GetArchetypeCount())
            let archetype = this.GetArchetype(i)
            let mutable j = 0
            while (j < archetype.Count)
                let mutable entId = archetype.EntityIds.GetAs<EntityId>(j)
                if (!lookup.TryAdd(entId, archetype))
                    let prevArchetype = lookup[entId]
                    fail("Entity '" + entId.ToString() + "' is used in multiple archetypes.\nArchetype1: " + prevArchetype.ComponentListText + "\nArchetype2: " + archetype.ComponentListText)
                j <- j + 1
            i <- i + 1
#end
        ()

    CopyTo(dst: EntityDatabase): () =          
        if (this.GetArchetypeCount() > dst.GetArchetypeCount())
            let mutable i = 0
            while (i < this.GetArchetypeCount())
                let thisArchetype = this.GetArchetype(i)
                if (i >= dst.GetArchetypeCount())
                    let dstIndex = dst.RegisterArchetype(thisArchetype.Id)
                    if (i != dstIndex)
                        fail("Archetype integrity failed")
                let dstArchetype = dst.GetArchetype(i)
                if (thisArchetype.Id != dstArchetype.Id)
                    fail("Archetype integrity failed")
                i <- i + 1
        else if (this.GetArchetypeCount() < dst.GetArchetypeCount())
            let mutable i = this.GetArchetypeCount()
            while (i < dst.GetArchetypeCount())
                let dstArchetype = dst.GetArchetype(i)
                dstArchetype.Count <- 0
                i <- i + 1

#if DEBUG
        let mutable i = 0
        while (i < this.GetArchetypeCount())
            let thisArchetype = this.GetArchetype(i)
            let dstArchetype = dst.GetArchetype(i)
            if (thisArchetype.Id != dstArchetype.Id)
                fail("Archetype integrity failed")
            i <- i + 1
#end      

        this.DebugCheckIntegrity()

        Span(this.entityVersions).CopyTo(Span(dst.entityVersions))
        Span(this.entityArchetypeIndices).CopyTo(Span(dst.entityArchetypeIndices))
        Span(this.entityIndexLookup).CopyTo(Span(dst.entityIndexLookup))

        dst.lastCreatedEntity <- this.lastCreatedEntity
        dst.entityCount <- this.entityCount

        dst.lastCreatedLocalEntity <- this.lastCreatedLocalEntity
        dst.localEntityCount <- this.localEntityCount

        let mutable i = 0
        while (i < this.GetArchetypeCount())
            let archetype = this.GetArchetype(i)
            let dstArchetype = dst.GetArchetype(i)
            archetype.CopyTo(dstArchetype)
            i <- i + 1

        dst.DebugCheckIntegrity()

    static SerializeForNetwork(db: EntityDatabase, bstream: ByteStream): () =
        db.DebugCheckIntegrity()

        bstream.Write<uint16>(uint16(db.entityCount))

        let mutable i = 0
        while (i < db.GetArchetypeCount())
            let archetype = db.GetArchetype(i)
            if (!archetype.IsLocal)
                let count = archetype.Count
                let entIds = archetype.EntityIds
                let buffers = archetype.NonAttachmentBuffers

                bstream.Write<uint16>(uint16(i))
                bstream.Write<ArchetypeId>(archetype.Id)
                bstream.Write<uint16>(uint16(count))

                entIds.ForEachChunk(entIds.ItemSize * count,
                    (chunk, _count) ->
                        bstream.Write(Span<_>.op_Implicit(chunk))
                )

                let mutable bufferCount = 0
                let mutable bufferIndex = 0
                while (bufferIndex < buffers.Length)
                    let buffer = buffers[bufferIndex].Store

                    let length = buffer.ItemSize * count
                    buffer.ForEachChunk(length,
                        (rawBufferSpan, _count)  ->
                            bstream.Write(Span<_>.op_Implicit(rawBufferSpan))
                    )
                    bufferIndex <- bufferIndex + 1

            i <- i + 1

    static DeserializeForNetwork(bstream: ByteStream, db: EntityDatabase, adapterState: EntityDatabaseNetworkAdapterState): () =
        db.DebugCheckIntegrity()
        db.ClearEntities()

        db.entityCount <- int32(bstream.Read<uint16>())
        while (bstream.Position.Index < bstream.TotalCount)
            let senderArchetypedIndex = int32(bstream.Read<uint16>())
            let archetypeId = bstream.Read<ArchetypeId>()
            let count = int32(bstream.Read<uint16>())
            let archetypedIndex = db.GetArchetypedIndex(archetypeId)
            adapterState.Value[senderArchetypedIndex] <- archetypedIndex
            let archetype = db.GetArchetype(archetypedIndex)
            let buffers = archetype.NonAttachmentBuffers

            archetype.EnsureCapacity(count)

            let entIds = archetype.EntityIds
            entIds.ForEachChunk(entIds.ItemSize * count,
                (chunk, _count) ->
                    bstream.Read(chunk)
            )

            let bufferCount = buffers.Length
            let mutable bufferIndex = 0
            while (bufferIndex < bufferCount)
                let buffer = buffers[bufferIndex].Store
                let length = buffer.ItemSize * count
                buffer.ForEachChunk(length,
                    (rawBufferSpan, _count) ->
                        bstream.Read(rawBufferSpan)
                )
                bufferIndex <- bufferIndex + 1

            archetype.Count <- count

            // Fix-ups
            let lookup = db.entityIndexLookup
            let entVersions = db.entityVersions 
            let entArchetypeIndices = db.entityArchetypeIndices
            let mutable i = 0
            while (i < count)
                let entId = entIds.GetAs<EntityId>(i)
                let index = entId.Index
                entArchetypeIndices[index] <- archetypedIndex
                entVersions[index] <- entId.Version
                lookup[index] <- i
                i <- i + 1

        db.DebugCheckIntegrity()

    static SyncArchetypesIfNeccessary(prevDb: EntityDatabase, db: EntityDatabase): () =
        if (db.GetArchetypeCount() == 0)
            let mutable i = 0
            while (i < prevDb.GetArchetypeCount())
                let prevArchetype = prevDb.GetArchetype(i)
                let _ = db.RegisterArchetype(prevArchetype.Id)
                i <- i + 1

    static Reset(db: EntityDatabase): () =
        db.ClearEntities()
        db.ClearLocalEntities()
        db.Archetypes.Clear()

    static SerializeDeltaForNetwork(prevDb: EntityDatabase, db: EntityDatabase, canDeltaArchetypeId: bool, bstream: ByteStream): () =
        let prevArchetypeCount = prevDb.GetArchetypeCount()

#if DEBUG
        if (prevArchetypeCount > db.GetArchetypeCount())       
            fail("Archetype integrity failed")

        let mutable i = 0
        while (i < prevDb.GetArchetypeCount())
            let prevArchetype = prevDb.GetArchetype(i)
            let archetype = db.GetArchetype(i)
            if (prevArchetype.Id != archetype.Id)
                fail("Archetype integrity failed")
            i <- i + 1
#end
        bstream.Write<uint16>(uint16(db.entityCount))

        let mutable i = 0
        while (i < db.GetArchetypeCount())
            let archetype = db.GetArchetype(i)
            if (!archetype.IsLocal)
                let count = archetype.Count
                let buffers = archetype.NonAttachmentBuffers

                let prevArchetypeOpt = 
                    if (i >= prevArchetypeCount)
                        None
                    else
                        Some(prevDb.GetArchetype(i))

                let mustSerialize =
                    match (prevArchetypeOpt)
                    | Some(prevArchetype) =>
#if DEBUG
                        if (archetype.Id != prevArchetype.Id)
                            fail("Archetypes are not in sync")
#end
                        prevArchetype.EnsureCapacity(count)
                        prevArchetype.Count != 0 || archetype.Count != 0
                    | _ =>
                        true

                archetype.EnsureCapacity(count)

                if (mustSerialize)
                    let nextArchetypeStatePosition = bstream.Position
                    let nextArchetypeStateCount = bstream.TotalCount
                    let mutable hasArchetypeData = false
                    bstream.WritePackedUInt16(uint16(i))

                    if (canDeltaArchetypeId && prevArchetypeOpt.IsSome)
                        bstream.WriteBit(false)
                    else
                        bstream.WriteBit(true)
                        bstream.Write(archetype.Id)

                    match (prevArchetypeOpt)
                    | Some(prevArchetype) =>
                        if (prevArchetype.Count == archetype.Count)
                            bstream.WriteBit(false)
                        else
                            hasArchetypeData <- true
                            bstream.WriteBit(true)
                            bstream.WritePackedUInt16(uint16(count))
                    | _ =>
                        hasArchetypeData <- true
                        bstream.WriteBit(true)
                        bstream.WritePackedUInt16(uint16(count))

                    let mutable entIds = archetype.EntityIds

                    let mutable k = 0
                    while (k < count)
                        let entId = entIds.GetAs<EntityId>(k)

                        match (prevArchetypeOpt)
                        | Some(prevArchetype) when (k < prevArchetype.Count) =>
                            let mutable prevEntIds = prevArchetype.EntityIds
                            let prevEntId = prevEntIds.GetAs<EntityId>(k)
                            if (prevEntId.Index == entId.Index && prevEntId.Version == entId.Version)
                                bstream.WriteBit(false)
                            else
                                hasArchetypeData <- true
                                bstream.WriteBit(true)
                                bstream.Write(entId)                           
                        | _ =>
                            hasArchetypeData <- true
                            bstream.WriteBit(true)
                            bstream.Write(entId)
                        k <- k + 1

                    let mutable bufferIndex = 0
                    while (bufferIndex < buffers.Length)
                        let buffer = buffers[bufferIndex]
                        let serializeDelta = buffer.SerializeDeltaForNetwork
                        let buffer = buffers[bufferIndex].Store
                        let length = buffer.ItemSize * count

                        match (prevArchetypeOpt)
                        | Some(prevArchetype) =>
                            let prevCount = prevArchetype.Count
                            let prevBuffers = prevArchetype.NonAttachmentBuffers
                            buffer.ForEachChunk2(prevBuffers[bufferIndex].Store, length,
                                (mutable rawBufferSpan, mutable prevRawBufferSpan, count) ->
                                    let mutable k = 0
                                    while (k < count)
                                        let slice = rawBufferSpan.Slice(buffer.ItemSize * k, buffer.ItemSize)

                                        // This ensures that if the data was moved, we will always write the data as to avoid stale data.
                                        if (k < prevCount)
                                            bstream.WriteBit(false)
                                            let prevSlice = prevRawBufferSpan.Slice(buffer.ItemSize * k, buffer.ItemSize)
                                            if (System.MemoryExtensions.SequenceEqual(prevSlice, Span<_>.op_Implicit(slice)))
                                                bstream.WriteBit(false)
                                            else
                                                hasArchetypeData <- true
                                                bstream.WriteBit(true)
                                                serializeDelta(Span<_>.op_Implicit(prevSlice), Span<_>.op_Implicit(slice), bstream)
                                        else
                                            hasArchetypeData <- true
                                            bstream.WriteBit(true)
                                            bstream.Write(slice)
                                        k <- k + 1
                            )
                        | _ =>
                            buffer.ForEachChunk(length,
                                (mutable rawBufferSpan, count) ->
                                    let mutable k = 0
                                    while (k < count)
                                        let slice = rawBufferSpan.Slice(buffer.ItemSize * k, buffer.ItemSize)
                                        hasArchetypeData <- true
                                        bstream.WriteBit(true)
                                        bstream.Write(slice)
                                        k <- k + 1                             
                            )

                        bufferIndex <- bufferIndex + 1
                    if (!hasArchetypeData)
                        bstream.Position <- nextArchetypeStatePosition
                        bstream.TotalCount <- nextArchetypeStateCount

            i <- i + 1

    static DeserializeDeltaForNetwork(bstream: ByteStream, db: EntityDatabase, adapterState: EntityDatabaseNetworkAdapterState): () =
        db.DebugCheckIntegrity()
        db.ClearEntitiesExceptArchetypes()

        db.entityCount <- int32(bstream.Read<uint16>())

        while (bstream.Position.Index < bstream.TotalCount)
            let senderArchetypedIndex = int32(bstream.ReadPackedUInt16())
            let archetype = 
                if (bstream.ReadBit())
                    let archetypeId = bstream.Read<ArchetypeId>()
                    let archetypedIndex = db.GetArchetypedIndex(archetypeId)
                    adapterState.Value[senderArchetypedIndex] <- archetypedIndex
                    db.GetArchetype(archetypedIndex)
                else
                    db.GetArchetype(adapterState.Value[senderArchetypedIndex])
            let count = 
                if (bstream.ReadBit())
                    int32(bstream.ReadPackedUInt16())
                else
                    archetype.Count
            let buffers = archetype.NonAttachmentBuffers
            let entIds = archetype.EntityIds

            archetype.EnsureCapacity(count)
            
            let mutable k = 0
            while (k < count)
                if (bstream.ReadBit())
                    entIds.SetAs(k, bstream.Read<EntityId>())
                k <- k + 1

            let bufferCount = buffers.Length
            let mutable bufferIndex = 0
            while (bufferIndex < bufferCount)
                let buffer = buffers[bufferIndex]
                let deserializeDelta = buffer.DeserializeDeltaForNetwork
                let buffer = buffer.Store
                let length = buffer.ItemSize * count

                buffer.ForEachChunk(length,
                    (mutable rawBufferSpan, count) ->
                        let mutable k = 0
                        while (k < count)
                            if (bstream.ReadBit())
                                bstream.Read(rawBufferSpan.Slice(buffer.ItemSize * k, buffer.ItemSize))
                            else if (bstream.ReadBit())
                                deserializeDelta(bstream, rawBufferSpan.Slice(buffer.ItemSize * k, buffer.ItemSize))
                            k <- k + 1
                )
                bufferIndex <- bufferIndex + 1

            archetype.Count <- count

            // Fix-ups
            // let archetypedIndex = db.GetArchetypedIndex(archetype.Id)
            // let lookup = db.entityIndexLookup
            // let entVersions = db.entityVersions 
            // let entArchetypeIndices = db.entityArchetypeIndices
            // let mutable i = 0
            // while (i < count)
            //     let entId = entIds.GetAs<EntityId>(i)
            //     let index = entId.Index
            //     entArchetypeIndices[index] <- archetypedIndex
            //     entVersions[index] <- entId.Version
            //     lookup[index] <- i
            //     i <- i + 1

        // -- Full fixups --
        // We have to do this since we clear out the entity tables when deserializing deltas.
        // This is to handle entity deletions in deltas. If the archetypes are synced with the exact EntityIds, then we know what entities were deleted.
        // REVIEW: Perhaps there is a better way to handle it? If so, then we can use the old approach that is commented above.
        // REVIEW: This should not be a perf issue, but something to keep in mind.
        //         We are iterating over all archetypes and updating the entity tables based on each archetype's information.
        let lookup = db.entityIndexLookup
        let entVersions = db.entityVersions 
        let entArchetypeIndices = db.entityArchetypeIndices
        let numOfArchetypes = db.Archetypes.Count
        let mutable archetypedIndex = 0
        while (archetypedIndex < numOfArchetypes)
            let archetype = db.Archetypes[archetypedIndex]
            if (!archetype.IsLocal)
                let count = archetype.Count
                if (count > 0)
                    // Fix-ups
                    let entIds = archetype.EntityIds

                    let mutable i = 0
                    while (i < count)
                        let entId = entIds.GetAs<EntityId>(i)
                        let index = entId.Index
                        entArchetypeIndices[index] <- archetypedIndex
                        entVersions[index] <- entId.Version
                        lookup[index] <- i
                        i <- i + 1
            archetypedIndex <- archetypedIndex + 1

        db.DebugCheckIntegrity()

    DeleteAll(): () =
        let queue = Queue<EntityId>()

        let mutable i = 0
        while (i < this.GetArchetypeCount())
            let archetype = this.GetArchetype(i)
            let count = archetype.Count
            let entIds = archetype.EntityIds
            For(count,
                i ->
                    queue.Enqueue(entIds.GetAs(i))
            )
            i <- i + 1

        let mutable entId = default
        while (queue.TryDequeue(&entId))
            let _ = this.Delete(entId)

        if (this.entityCount != 0)
            fail("Integrity has failed")

        if (this.localEntityCount != 0)
            fail("Integrity has failed")

    ClearEntities(): () =
        this.lastCreatedEntity <- EntityId.Nil
        this.entityCount <- 0
        Span(this.entityArchetypeIndicesClear, 0, EntityDatabase.MaxNumberOfEntities / 2).CopyTo(Span(this.entityArchetypeIndices))
        Span(this.entityVersions, 0, EntityDatabase.MaxNumberOfEntities / 2).Clear()

        // Archetype counts should also be zero.
        let mutable i = 0
        while (i < this.GetArchetypeCount())
            let archetype = this.GetArchetype(i)
            if (!archetype.IsLocal)
                archetype.Count <- 0
            i <- i + 1

    ClearLocalEntities(): () =
        this.lastCreatedLocalEntity <- EntityId.Nil
        this.localEntityCount <- 0
        Span(this.entityArchetypeIndicesClear, EntityDatabase.MaxNumberOfEntities / 2, EntityDatabase.MaxNumberOfEntities / 2).CopyTo(Span(this.entityArchetypeIndices))
        Span(this.entityVersions, EntityDatabase.MaxNumberOfEntities / 2, EntityDatabase.MaxNumberOfEntities / 2).Clear()

        // Archetype counts should also be zero.
        let mutable i = 0
        while (i < this.GetArchetypeCount())
            let archetype = this.GetArchetype(i)
            if (archetype.IsLocal)
                archetype.Count <- 0
            i <- i + 1

    private ClearEntitiesExceptArchetypes(): () =
        this.lastCreatedEntity <- EntityId.Nil
        this.entityCount <- 0
        Span(this.entityArchetypeIndicesClear, 0, EntityDatabase.MaxNumberOfEntities / 2).CopyTo(Span(this.entityArchetypeIndices))
        Span(this.entityVersions, 0, EntityDatabase.MaxNumberOfEntities / 2).Clear()

    internal struct CreatedEntityInfo =
        public field mutable EntityId: EntityId = default
        public field mutable ArchetypeId: ArchetypeId = default

    #[DebuggerDisplay("{EntityId}")]
    internal struct DeletingEntityInfo =
        public field mutable EntityId: EntityId = default

    internal struct ArchetypeChangedEntityInfo =
        public field mutable EntityIndex: int32 = default
        public field mutable PreviousIndex: int32 = default
        public field mutable Index: int32 = default
        public field mutable PreviousArchetypeId: ArchetypeId = default
        public field mutable ArchetypeId: ArchetypeId = default

    struct ReplicatingEvents =
        internal field CreatedEntities: List<CreatedEntityInfo> = List()
        internal field DeletingEntities: List<DeletingEntityInfo> = List()
        internal field ArchetypeChangedEntities: List<ArchetypeChangedEntityInfo> = List()

    GetReplicatingEvents(prevDb: EntityDatabase, nonLocalOnly: bool): ReplicatingEvents =
        let verboseLogging = false

        let events = ReplicatingEvents()
        // --
        let prevLookup = prevDb.entityIndexLookup
        let lookup = this.entityIndexLookup
        let prevVersions = prevDb.entityVersions
        let versions = this.entityVersions

        let maxNumber = 
            if (nonLocalOnly)
                MaxNumberOfEntities / 2
            else
                MaxNumberOfEntities

        let mutable i = 0
        while (i < maxNumber)
            let prevVersion = prevVersions[i]
            let version = versions[i]

            let prevArchetypeIndex = prevDb.entityArchetypeIndices[i]
            let archetypeIndex = this.entityArchetypeIndices[i]

            if (prevVersion != version)
                if (prevArchetypeIndex != -1)
                    let mutable entId = EntityId()
                    entId.Index <- i
                    entId.Version <- prevVersion
                    let mutable info = DeletingEntityInfo()
                    info.EntityId <- entId
                    events.DeletingEntities.Add(info)

                if (archetypeIndex != -1)
                    let mutable entId = EntityId()
                    entId.Index <- i
                    entId.Version <- version
                    let mutable info = CreatedEntityInfo()
                    info.EntityId <- entId
                    info.ArchetypeId <- this.GetArchetype(archetypeIndex).Id
                    events.CreatedEntities.Add(info)

            else if (prevArchetypeIndex != -1 && archetypeIndex != -1)
                let prevIndex = prevLookup[i]
                let index = lookup[i]

                let prevArchetypeId = prevDb.GetArchetype(prevArchetypeIndex).Id
                let archetypeId = this.GetArchetype(archetypeIndex).Id
                
                if (prevIndex != index || (prevArchetypeId != archetypeId))
                    let mutable info = ArchetypeChangedEntityInfo()
                    info.EntityIndex <- i
                    info.PreviousIndex <- prevIndex
                    info.Index <- index
                    info.PreviousArchetypeId <- prevArchetypeId
                    info.ArchetypeId <- archetypeId
                    events.ArchetypeChangedEntities.Add(info)

            i <- i + 1
        // --
        events

    Replicate(dstCopy: EntityDatabase, dst: EntityDatabase, events: ReplicatingEvents, nonLocalOnly: bool): () =
        let mutable i = 0
        while (i < events.DeletingEntities.Count)
            let info = events.DeletingEntities[i]

#if DEBUG
            if (nonLocalOnly && info.EntityId.Index >= (MaxNumberOfEntities / 2))
                fail("Cannot delete local entity in a non-local context")
#end

            dst.Delete(info.EntityId)
            i <- i + 1

        dst.IncrementDepth()

        // TODO: Make this non-allocating if it makes sense to.
        let queue = Queue()

        let mutable i = 0
        while (i < events.ArchetypeChangedEntities.Count)
            let result = events.ArchetypeChangedEntities[i]
            let entIndex = result.EntityIndex

#if DEBUG
            if (nonLocalOnly && entIndex >= (MaxNumberOfEntities / 2))
                fail("Cannot change local entity in a non-local context")
#end

            let prevArchetypeCopy = dstCopy.GetArchetype(dstCopy.GetArchetypedIndex(result.PreviousArchetypeId))
            let prevArchetype = dst.GetArchetype(dst.GetArchetypedIndex(result.PreviousArchetypeId))
            let archetypedIndex = dst.GetArchetypedIndex(result.ArchetypeId)
            let dstArchetype = dst.GetArchetype(archetypedIndex)

            let diff = prevArchetype.FullId & dstArchetype.FullId.BitwiseNot()
            if (!diff.IsZero)
                prevArchetype.TriggerComponentRemoving(diff, result.PreviousIndex)

            dstArchetype.EnsureCapacity(dstArchetype.Count + 1)

            prevArchetypeCopy.CopyOneTo(result.PreviousIndex, dstArchetype, result.Index)
            dst.entityArchetypeIndices[entIndex] <- archetypedIndex

            let diff = dstArchetype.FullId & prevArchetype.FullId.BitwiseNot()
            if (!diff.IsZero)
                queue.Enqueue(
                    () ->
                        dstArchetype.TriggerComponentAdded(diff, result.Index)
                )

            i <- i + 1

        if (nonLocalOnly)
            Span(this.entityVersions, 0, this.entityVersions.Length / 2).CopyTo(Span(dst.entityVersions))
            Span(this.entityIndexLookup, 0, this.entityIndexLookup.Length / 2).CopyTo(Span(dst.entityIndexLookup))
        else
            Span(this.entityVersions).CopyTo(Span(dst.entityVersions))
            Span(this.entityIndexLookup).CopyTo(Span(dst.entityIndexLookup))

        dst.lastCreatedEntity <- this.lastCreatedEntity
        dst.entityCount <- this.entityCount

        if (!nonLocalOnly)
            dst.lastCreatedLocalEntity <- this.lastCreatedLocalEntity
            dst.localEntityCount <- this.localEntityCount

        // Archetype counts should also be zero.
        let mutable i = 0
        while (i < dst.GetArchetypeCount())
            let archetype = dst.GetArchetype(i)
            if (nonLocalOnly)
                if (!archetype.IsLocal)
                    archetype.Count <- 0
            else
                archetype.Count <- 0
            i <- i + 1

        let mutable i = 0
        while (i < this.GetArchetypeCount())     
            let archetype = this.GetArchetype(i)
            if (nonLocalOnly)
                if (!archetype.IsLocal)
                    archetype.CopyTo(dst.GetArchetype(dst.GetArchetypedIndex(archetype.Id)))
            else
                archetype.CopyTo(dst.GetArchetype(dst.GetArchetypedIndex(archetype.Id)))
            i <- i + 1

        let mutable f = unchecked default
        while (queue.TryDequeue(&f))
            f()

        let mutable i = 0
        while (i < events.CreatedEntities.Count)
            let result = events.CreatedEntities[i]
            let entId = result.EntityId
            let entIndex = entId.Index
#if DEBUG
            if (nonLocalOnly && entIndex >= (MaxNumberOfEntities / 2))
                fail("Cannot create local entity in a non-local context")
#end
            let archetypedIndex = dst.GetArchetypedIndex(result.ArchetypeId)
            dst.entityVersions[entIndex] <- entId.Version
            dst.entityArchetypeIndices[entIndex] <- archetypedIndex

            let archetype = dst.GetArchetype(archetypedIndex)
            archetype.TriggerComponentAdded(archetype.FullId, dst.entityIndexLookup[entIndex])

            i <- i + 1

        dst.DecrementDepth()

    static SerializeJsonForEntity(db: EntityDatabase, entId: EntityId, utf8Stream: Stream): () =
        if (!db.IsValid(entId))
            // TODO: better message
            fail("entity not valid")

        let archetype = db.GetArchetype(db.entityArchetypeIndices[entId.Index])
        let buffers = archetype.Buffers
        let entIds = archetype.EntityIds
        let i = db.entityIndexLookup[entId.Index]

        let mutable options = default: JsonWriterOptions
        options.Indented <- true
        let json = Utf8JsonWriter(utf8Stream, options)

        json.WriteStartObject()

        json.WritePropertyName("EntityIndex")
        json.WriteNumberValue(entIds.GetAs<EntityId>(i).Index)

        let bufferCount = buffers.Length
        let mutable bufferIndex = 0
        while (bufferIndex < bufferCount)
            let buffer = buffers[bufferIndex]

            if (archetype.AttachmentId & buffer.ComponentId != buffer.ComponentId)
                let span = Span<_>.op_Implicit(buffer.Store.Get(i))
                json.WritePropertyName(buffer.ComponentName)
                TypeHelpers.Write(db.registry.JsonFieldWriteMappings, buffer.Type, span, json)

            bufferIndex <- bufferIndex + 1

        json.WriteEndObject()

        json.Flush()
        json.Dispose()

    static SerializeJson(db: EntityDatabase, utf8Stream: Stream): () =
        if (db.Kind == EntityDatabaseKind.Client)
            fail("Cannot serialize a client database")

        let mutable options = default: JsonWriterOptions
        options.Indented <- true
        let mutable json = Utf8JsonWriter(utf8Stream, options)

        db.DebugCheckIntegrity()

        json.WriteStartObject()

        json.WritePropertyName("LastCreatedEntity")
        TypeHelpers.WriteEntity(&json, db.lastCreatedEntity)

        json.WritePropertyName("LastCreatedLocalEntity")
        TypeHelpers.WriteEntity(&json, db.lastCreatedLocalEntity)

        json.WritePropertyName("Entities")
        json.WriteStartArray()

        let mutable i = 0
        while (i < db.GetArchetypeCount())
            let archetype = db.GetArchetype(i)
            let count = archetype.Count
            let buffers = archetype.Buffers
            let entIds = archetype.EntityIds

            For(count,
                i ->
                    json.WriteStartObject()

                    json.WritePropertyName("EntityIndex")
                    json.WriteNumberValue(entIds.GetAs<EntityId>(i).Index)

                    let bufferCount = buffers.Length
                    let mutable bufferIndex = 0
                    while (bufferIndex < bufferCount)
                        let buffer = buffers[bufferIndex]

                        if (archetype.AttachmentId & buffer.ComponentId != buffer.ComponentId)
                            let span = Span<_>.op_Implicit(buffer.Store.Get(i))
                            json.WritePropertyName(buffer.ComponentName)
                            TypeHelpers.Write(db.registry.JsonFieldWriteMappings, buffer.Type, span, json)

                        bufferIndex <- bufferIndex + 1

                    json.WriteEndObject()
            )

            i <- i + 1

        json.WriteEndArray()
        json.WriteEndObject()

        json.Flush()
        json.Dispose()

    private static PreDeserializeJsonForEntityCoreFinished(reader: byref<Utf8JsonReader>, db: EntityDatabase, i: int32, lookup: mutable int32[], iterLookup: mutable EntityId[], nameToIndex: Dictionary<string, int32>, compIds: List<ComponentId>, count: byref<int32>, localCount: byref<int32>, entIndex: byref<int32>, entName: byref<string>, isUsingEntityIndices: bool): () =
        let mutable archetypeId = default: ArchetypeId
        For(compIds.Count,
                i ->
                    archetypeId <- archetypeId | compIds[i]
            )
        let archetypedIndex = db.GetArchetypedIndex(archetypeId)
        let archetype = db.GetArchetype(archetypedIndex)

        if (!(db.Kind == EntityDatabaseKind.Client && !archetype.IsClientSide))
            let mutable entId = EntityId.Nil
            if (!isUsingEntityIndices)
                if (archetype.IsLocal)
                    entId <- db.NewLocalEntityId(archetypedIndex)
                else
                    entId <- db.NewEntityId(archetypedIndex)
                if (!string.IsNullOrWhiteSpace(entName))
                    nameToIndex.Add(entName, entId.Index)
                entName <- string.Empty
            else
                entId.Index <- entIndex
                entId.Version <- db.entityVersions[entId.Index]

            db.entityArchetypeIndices[entId.Index] <- archetypedIndex

            let index = archetype.Count
            archetype.Count <- index + 1
            archetype.EntityIds.SetAs(index, entId)
            lookup[entId.Index] <- index
            iterLookup[i] <- entId

            if (db.IsLocal(entId))
                localCount <- localCount + 1
            else
                count <- count + 1
        compIds.Clear()

    private static PreDeserializeJsonForEntityCore(reader: byref<Utf8JsonReader>, db: EntityDatabase, compIds: List<ComponentId>, entIndex: byref<int32>, entName: byref<string>, isUsingEntityIndices: bool): bool =
        match (reader.TokenType)
        | JsonTokenType.StartObject =>
            let _ = reader.Read()
            true               
        | JsonTokenType.EndObject =>
            TypeHelpers.ReadEndObject(&reader)
            false
        | JsonTokenType.PropertyName =>
            let propName = reader.GetString()
            let _ = reader.Read()

            if (propName == "EntityIndex")
                if (!isUsingEntityIndices)
                    fail("Malformed json")
                entIndex <- reader.GetInt32()
                let _ = reader.Read()
            else if (propName == "EntityName")
                if (isUsingEntityIndices)
                    fail("Malformed json")
                entName <- reader.GetString()
                let _ = reader.Read()
            else
                // Component
                let componentId = db.registry.NameToId[propName]
                compIds.Add(componentId)
                reader.Skip()
                TypeHelpers.ReadEndObject(&reader)           
            true
        | _ =>
            fail("Unhandled json token type")

    private static DeserializeJsonForEntityCore(visitedComps: HashSet<string>, reader: byref<Utf8JsonReader>, db: EntityDatabase, i: int32, lookup: mutable int32[], iterLookup: mutable EntityId[], nameToIndex: Dictionary<string, int32>): bool =
        match (reader.TokenType)
        | JsonTokenType.StartObject =>
            let _ = reader.Read()
            true               
        | JsonTokenType.EndObject =>
            TypeHelpers.ReadEndObject(&reader)
            false
        | JsonTokenType.PropertyName =>
            let propName = reader.GetString()
            let _ = reader.Read()

            if (propName == "EntityIndex")
                let _ = reader.Read()

            else if (propName == "EntityName")
                let _ = reader.Read()

            else
                // Component
                let componentId = db.registry.NameToId[propName]
                let componentTy = db.registry.GetType(componentId)

                let entId = iterLookup[i]

                if (entId.IsNil)
                    reader.Skip()
                    TypeHelpers.ReadEndObject(&reader)
                else
                    let archetypedIndex = db.entityArchetypeIndices[entId.Index]

                    if (archetypedIndex != -1)
                        let archetype = db.GetArchetype(archetypedIndex)

                        let buffer = archetype.Buffers[archetype.BufferLookup[componentId]]
                        let index = lookup[entId.Index]
                        let mutable span = buffer.Store.Get(index)

                        // First time we visit a component, it must be provided all fields.
                        let isStrict = visitedComps.Add(propName)
                        TypeHelpers.Read(isStrict, nameToIndex, db.registry.JsonFieldReadMappings, componentTy, span, &reader)
                    else
                        reader.Skip()
                        TypeHelpers.ReadEndObject(&reader)   
            true
        | _ =>
            fail("Unhandled json token type")

    static DeserializeJson(utf8Stream: Stream, db: EntityDatabase): () =
        db.DebugCheckIntegrity()
        db.ClearEntities()
        db.ClearLocalEntities()

        // Clear archetype buffers.
        let mutable i = 0
        while (i < db.GetArchetypeCount())
            let archetype = db.GetArchetype(i)
            archetype.ClearAll()
            i <- i + 1

        let length = int32(utf8Stream.Length - utf8Stream.Position)
        let buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(length)
        let length = utf8Stream.Read(buffer, 0, length)
        let json = ReadOnlySpan(buffer, 0, length)

        let mutable options = default: JsonReaderOptions
        let mutable reader = Utf8JsonReader(json, options)

        let _ = reader.Read()

        TypeHelpers.ReadStartObject(&reader)

        if (reader.GetString() == "$schema")
            let _ = reader.Read()

            if (reader.TokenType != JsonTokenType.String)
                fail("Expected type 'string' for '$schema'.")
            let _ = reader.Read()

        let mutable isUsingEntityIndices = false
        if (TypeHelpers.TryReadPropertyEntityId("LastCreatedEntity", &reader, &db.lastCreatedEntity))
            isUsingEntityIndices <- true

            if (db.Kind != EntityDatabaseKind.Client)
                if (db.lastCreatedEntity.Version > 1)
                    For(EntityDatabase.MaxNumberOfEntities / 2,
                        i ->
                            db.entityVersions[i] <- db.lastCreatedEntity.Version - 1
                    )
                For(db.lastCreatedEntity.Index + 1,
                    i ->
                        db.entityVersions[i] <- db.lastCreatedEntity.Version
                )
            else
                db.lastCreatedEntity <- EntityId.Nil

            if (!TypeHelpers.TryReadPropertyEntityId("LastCreatedLocalEntity", &reader, &db.lastCreatedLocalEntity))
                fail("Missing 'LastCreatedLocalEntity' after 'LastCreatedEntity'.")

            if (db.lastCreatedLocalEntity.Version > 1)
                For(EntityDatabase.MaxNumberOfEntities / 2,
                    i ->
                        db.entityVersions[i + (EntityDatabase.MaxNumberOfEntities / 2)] <- db.lastCreatedLocalEntity.Version - 1
                )
            For(db.lastCreatedLocalEntity.Index + 1 - (EntityDatabase.MaxNumberOfEntities / 2),
                i ->
                    db.entityVersions[i + (EntityDatabase.MaxNumberOfEntities / 2)] <- db.lastCreatedLocalEntity.Version
            )

        if (reader.TokenType != JsonTokenType.PropertyName)
            fail("Expected PropertyName")

        let _ = reader.Read()
        if (reader.TokenType != JsonTokenType.StartArray)
            fail("Expected StartArray")
        let _ = reader.Read()


        let mutable count = 0
        let mutable localCount = 0

        let nameToIndex = Dictionary<string, int32>()

        let start = reader

        let compIds = List()
        let lookup = db.entityIndexLookup      
        let mutable entIndex = -1
        let mutable entName = string.Empty
        
        let iterLookup = initMutableArray(EntityDatabase.MaxNumberOfEntities, i -> EntityId.Nil)

        let mutable i = 0
        while (reader.TokenType != JsonTokenType.EndArray)
            match (reader.TokenType)
            | JsonTokenType.PropertyName when (reader.GetString() == "#") =>
                let _ = reader.Read()
                let utf8Stream = File.Open(reader.GetString(), FileMode.Open) // TODO:
                let _ = reader.Read()
                let length = int32(utf8Stream.Length - utf8Stream.Position)
                let buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(length)
                let length = utf8Stream.Read(buffer, 0, length)
                utf8Stream.Dispose()
                let json = ReadOnlySpan(buffer, 0, length)
        
                let mutable options = default: JsonReaderOptions
                let mutable innerReader = Utf8JsonReader(json, options)
                let _ = innerReader.Read()

                let mutable willContinue = true
                while (willContinue)
                    willContinue <-
                        PreDeserializeJsonForEntityCore(
                            &innerReader,
                            db,
                            compIds,
                            &entIndex,
                            &entName,
                            isUsingEntityIndices
                        )
                
                willContinue <- reader.TokenType != JsonTokenType.EndObject
                if (!willContinue)
                    PreDeserializeJsonForEntityCoreFinished(
                        &innerReader,
                        db,
                        i,
                        lookup,
                        iterLookup,
                        nameToIndex,
                        compIds,
                        &count,
                        &localCount,
                        &entIndex,
                        &entName,
                        isUsingEntityIndices
                    )
                    i <- i + 1

                System.Buffers.ArrayPool<byte>.Shared.Return(buffer, true)        
            | _ =>
                let willContinue = 
                    PreDeserializeJsonForEntityCore(
                        &reader,
                        db,
                        compIds,
                        &entIndex,
                        &entName,
                        isUsingEntityIndices
                    )
                if (!willContinue)
                    PreDeserializeJsonForEntityCoreFinished(
                        &reader,
                        db,
                        i,
                        lookup,
                        iterLookup,
                        nameToIndex,
                        compIds,
                        &count,
                        &localCount,
                        &entIndex,
                        &entName,
                        isUsingEntityIndices
                    )
                    i <- i + 1

        reader <- start

        let visitedComps = HashSet<string>()

        let mutable i = 0
        while (reader.TokenType != JsonTokenType.EndArray)
            match (reader.TokenType)
            | JsonTokenType.PropertyName when (reader.GetString() == "#") =>
                let _ = reader.Read()
                let utf8Stream = File.Open(reader.GetString(), FileMode.Open) // TODO:
                let _ = reader.Read()
                let length = int32(utf8Stream.Length - utf8Stream.Position)
                let buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(length)
                let length = utf8Stream.Read(buffer, 0, length)
                utf8Stream.Dispose()
                let json = ReadOnlySpan(buffer, 0, length)
        
                let mutable options = default: JsonReaderOptions
                let mutable innerReader = Utf8JsonReader(json, options)
                let _ = innerReader.Read()

                let mutable willContinue = true
                while (willContinue)
                    willContinue <-
                        DeserializeJsonForEntityCore(
                            visitedComps,
                            &innerReader,
                            db,
                            i,
                            lookup,
                            iterLookup,
                            nameToIndex
                        )

                willContinue <- reader.TokenType != JsonTokenType.EndObject
                if (!willContinue)
                    visitedComps.Clear()
                    i <- i + 1

                System.Buffers.ArrayPool<byte>.Shared.Return(buffer, true) 
            | _ =>
                let willContinue =
                    DeserializeJsonForEntityCore(
                        visitedComps,
                        &reader,
                        db,
                        i,
                        lookup,
                        iterLookup,
                        nameToIndex               
                    )
                if (!willContinue)
                    visitedComps.Clear()
                    i <- i + 1

        let _ = reader.Read()

        TypeHelpers.ReadEndObject(&reader)

        db.entityCount <- count
        db.localEntityCount <- localCount

        db.DebugCheckIntegrity()

        System.Buffers.ArrayPool<byte>.Shared.Return(buffer, true)
