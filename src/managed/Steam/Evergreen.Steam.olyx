#target "dotnet: net10.0"
#library

#load "*.oly"

#reference "Interop/Evergreen.Steam.Interop.csproj"
#reference "Steamworks.NET.dll"
#reference "../Utilities/Evergreen.Utilities.olyx"

namespace Evergreen.SteamOld

open System
open System.IO
open System.Runtime.InteropServices
open Steamworks

private alias CallConvCdecl = System.Runtime.CompilerServices.CallConvCdecl

private module Marker

class SteamException =
    inherits Exception

    new(msg: string) = base(msg) { }

module Steam =

    field mutable isSteamRunning: bool = false

    internal CheckRunning(): () =
        if (!IsRunning)
            throw SteamException("Steam is not running")

    private class DebugCallback =
        
        OnDebugOutput(eType: ESteamNetworkingSocketsDebugOutputType, pszMsg: int8*): () =
            let msg = String(pszMsg)
            printLine(msg)

    IsRunning: bool get() = isSteamRunning

    Initialize(): () =
        let origDir = Environment.CurrentDirectory
        let markerTy = DotNet.TypeOf<Marker>
        Environment.CurrentDirectory <- Path.GetDirectoryName(markerTy.Assembly.Location)
        isSteamRunning <- SteamAPI.Init()
        Environment.CurrentDirectory <- origDir

        let debugCallback = DebugCallback()

        SteamNetworkingUtils.SetDebugOutputFunction(
            ESteamNetworkingSocketsDebugOutputType.k_ESteamNetworkingSocketsDebugOutputType_Everything, 
            FSteamNetworkingSocketsDebugOutput(debugCallback, nint(&&debugCallback.OnDebugOutput))
        )

        let mutable x = 8
        let xPtr = &&x
        let xPtrPtr = &&xPtr

        let res = 
            SteamNetworkingUtils.SetConfigValue(
                ESteamNetworkingConfigValue.k_ESteamNetworkingConfig_LogLevel_Message, 
                ESteamNetworkingConfigScope.k_ESteamNetworkingConfig_Global, 
                nint(0), 
                ESteamNetworkingConfigDataType.k_ESteamNetworkingConfig_Int32, nint(xPtrPtr)
            )

        ()

    Shutdown(): () =
        SteamAPI.Shutdown()

    module Networking =

        RunCallbacks(): () =
            SteamNetworkingSockets.RunCallbacks()

struct SteamListenSocket =
    implements IDisposable

    field socket: HSteamListenSocket
    field pollGroup: HSteamNetPollGroup
    new(socket: HSteamListenSocket, pollGroup: HSteamNetPollGroup) = this { socket = socket; pollGroup = pollGroup }

    #[blittable]
    #[UnmanagedCallersOnlyAttribute() { CallConvs = [DotNet.TypeOf<CallConvCdecl>] }]
    private static OnConnectionStatusChanged(payload: SteamNetConnectionStatusChangedCallback_t*): () =
        let payload2 = *payload
        let state = payload2.m_info.m_eState
        match (state)
        | ESteamNetworkingConnectionState.k_ESteamNetworkingConnectionState_None => ()
        | _ => fail("success")

    static Start(port: uint16): SteamListenSocket =
        Steam.CheckRunning()

        let mutable optValue = default: SteamNetworkingConfigValue_t.OptionValue
        optValue.m_functionPtr <- nint(&&OnConnectionStatusChanged)

        let mutable opt: SteamNetworkingConfigValue_t = default
        opt.m_eDataType <- ESteamNetworkingConfigDataType.k_ESteamNetworkingConfig_Ptr
        opt.m_eValue <- ESteamNetworkingConfigValue.k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged
        opt.m_val <- optValue

        // let mutable addr: SteamNetworkingIPAddr = default
        // addr.Clear()
        // addr.m_port <- port
        let socket = SteamNetworkingSockets.CreateListenSocketP2P(int32(port), 1, mutable [opt])
        if (socket == HSteamListenSocket.Invalid)
            throw SteamException("Unable to create listen socket")

        let pollGroup = SteamNetworkingSockets.CreatePollGroup()
        if (pollGroup == HSteamNetPollGroup.Invalid)
            throw SteamException("Unable to create poll group")
        
        SteamListenSocket(socket, pollGroup)

    ReceiveMessage(mutable buffer: Span<byte>): int32 =
        let bufferPtr = &&buffer.GetPinnableReference()
        let msgs = mutable [nint(bufferPtr)]
        SteamNetworkingSockets.ReceiveMessagesOnPollGroup(this.pollGroup, msgs, 1)

    Dispose(): () =
        if (!SteamNetworkingSockets.DestroyPollGroup(this.pollGroup))
            throw SteamException("Failed to destroy poll group")
        if (!SteamNetworkingSockets.CloseListenSocket(this.socket))
            throw SteamException("Failed to close listen socket")
        
struct SteamServerConnection =
    implements IDisposable

    field connection: HSteamNetConnection
    new(connection: HSteamNetConnection) = this { connection = connection }

    #[blittable]
    #[UnmanagedCallersOnlyAttribute() { CallConvs = [DotNet.TypeOf<CallConvCdecl>] }]
    private static OnConnectionStatusChanged(payload: SteamNetConnectionStatusChangedCallback_t*): () =
        let payload2 = *payload
        let state = payload2.m_info.m_eState
        match (state)
        | ESteamNetworkingConnectionState.k_ESteamNetworkingConnectionState_None => ()
        | _ => fail("success")

    static Connect(address: string, port: uint16): SteamServerConnection =
        Steam.CheckRunning()

        let mutable optValue = default: SteamNetworkingConfigValue_t.OptionValue
        optValue.m_functionPtr <- nint(&&OnConnectionStatusChanged)

        let mutable opt: SteamNetworkingConfigValue_t = default
        opt.m_eDataType <- ESteamNetworkingConfigDataType.k_ESteamNetworkingConfig_Ptr
        opt.m_eValue <- ESteamNetworkingConfigValue.k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged
        opt.m_val <- optValue

        // let mutable addr: SteamNetworkingIPAddr = default
        // addr.SetIPv4(0x7f000001, port)
        let mutable identity = default: SteamNetworkingIdentity
        identity.SetSteamID(SteamUser.GetSteamID())
        let connection = SteamNetworkingSockets.ConnectP2P(&identity, int32(port), 1, mutable [opt]) //ConnectByIPAddress(&addr, 1, mutable [opt])
        if (connection == HSteamNetConnection.Invalid)
            throw SteamException("Unable to create socket")

        SteamNetworkingSockets.SetConnectionName(connection, "client")
        
        SteamServerConnection(connection)

    SendMessage(mutable buffer: ReadOnlySpan<byte>): () =
        // TODO-language-bug: We should get diagnostic error, but compiles and causes an internal compiler
        // let bytes = bytes.GetPinnableReference()
        // let mutable msgNum = default
        // 'if (SteamNetworkingSockets.SendMessageToConnection(this.connection, &&bytes, 0, 0, &msgNum) != EResult.k_EResultOK)' causes an internal compiler error

        // TODO-language-bug: We should get diagnostic error, but compiles and causes an internal compiler of invalid cast
        // let bytes = &bytes.GetPinnableReference()
        // let mutable msgNum = default
        // 'if (SteamNetworkingSockets.SendMessageToConnection(this.connection, nint(&&bytes), 0, 0, &msgNum) != EResult.k_EResultOK)' causes an internal compiler error

        let bufferPtr = &&buffer.GetPinnableReference()
        let mutable msgNum = default
        if (SteamNetworkingSockets.SendMessageToConnection(this.connection, nint(bufferPtr), 0, 0, &msgNum) != EResult.k_EResultOK)
            throw SteamException("Failed to send message")

    ReceiveMessage(mutable buffer: Span<byte>): int32 =
        let bufferPtr = &&buffer.GetPinnableReference()
        let msgs = mutable [nint(bufferPtr)]
        SteamNetworkingSockets.ReceiveMessagesOnConnection(this.connection, msgs, 1)

    Dispose(): () =
        if (!SteamNetworkingSockets.CloseConnection(this.connection, 0, "", false)) // TODO-language-bug: 'if (!SteamNetworkingSockets.(this.socket))' causes a crash
            throw SteamException("Failed to close server connection")

module SteamTests =

    `basic client server`(): () =

        // let mutable server = default
        // let mutable serverIdentity = default
        // let mutable client = default
        // let mutable clientIdentity = default
        // if (!SteamNetworkingSockets.CreateSocketPair(&server, &client, true, &serverIdentity, &clientIdentity))
        //     fail("failed to create loopback")

        let port = 27019: uint16
        let steamListenSocket = SteamListenSocket.Start(port)
        let steamServerConnection = SteamServerConnection.Connect("localhost", port)

        let mutable i = 0
        while (i < 500)
            Steam.Networking.RunCallbacks()
            System.Threading.Thread.Sleep(1)
            i <- i + 1

        // TODO-language-bug: 'steamServerConnection.SendMessage(ReadOnlySpan(mutable [5;4;3;2;1]))' causes an internal error when compiling
        // TODO-language-bug: 'steamServerConnection.SendMessage(ReadOnlySpan<byte>(mutable [5;4;3;2;1]))' causes an internal error when compiling
        // TODO-language-bug: 'steamServerConnection.SendMessage(ReadOnlySpan(mutable [5: byte;4;3;2;1]))' causes an internal error when compiling
        let inputMsgData = mutable [5: byte;4;3;2;1]
        let inputMsgData = ReadOnlySpan(inputMsgData)
        steamServerConnection.SendMessage(inputMsgData)

        let mutable i = 0
        while (i < 500)
            Steam.Networking.RunCallbacks()
            System.Threading.Thread.Sleep(1)
            i <- i + 1

        let outputMsgData = mutable [0: byte;0;0;0;0]
        let outputMsgData = Span(outputMsgData)
        let result = steamListenSocket.ReceiveMessage(outputMsgData)

        // TODO-language-bug: 'if (!System.MemoryExtensions.SequenceEqual(inputMsgData, Span<_>.op_Implicit(inputMsgData)))' causes an internal error when compiling
        if (!System.MemoryExtensions.SequenceEqual(inputMsgData, Span<_>.op_Implicit(outputMsgData)))
            fail("Expected correct output")

        steamServerConnection.Dispose()
        steamListenSocket.Dispose()
