module Evergreen.Steam.Steam

open System
open System.IO
open System.Collections.Generic
open Evergreen.Steam.Interop
open Evergreen.Utilities

open static Evergreen.Steam.Interop.Methods

private module Marker

newtype SteamNetworkClientConnection =

    internal field connection: EgSteamNetworking_Connection

    static op_Equality(a: SteamNetworkClientConnection, b: SteamNetworkClientConnection): bool =
        a.connection.`internal` == b.connection.`internal`

newtype SteamNetworkServer =
    internal field socket: EgSteamNetworking_ListenSocket

    SendMessage(mutable buffer: ReadOnlySpan<byte>, connection: SteamNetworkClientConnection): () =
        let bufferPtr = &&buffer.GetPinnableReference()
        let _ = egSteamNetworking_SendMessage(connection.connection, buffer.Length, Unsafe.AsPointer(bufferPtr))

    ReceiveMessage(mutable buffer: Span<byte>): (SteamNetworkClientConnection, int32) =
        let mutable connectionOut = default: EgSteamNetworking_Connection
        let bufferPtr = &&buffer.GetPinnableReference()
        let bytesRead = egSteamNetworking_ReceiveMessageFromListenSocket(this.socket, Unsafe.AsPointer(bufferPtr), &&connectionOut)
        (SteamNetworkClientConnection(connectionOut), bytesRead)

    GetConnection(index: int32): SteamNetworkClientConnection =
        let connection = egSteamNetworking_GetConnection(this.socket, index)
        SteamNetworkClientConnection(connection)

    ConnectionCount: int32 get() = egSteamNetworking_GetConnectionCount(this.socket)

newtype SteamNetworkClient =
    internal field connection: EgSteamNetworking_Connection

    SendMessage(mutable buffer: ReadOnlySpan<byte>): () =
        let bufferPtr = &&buffer.GetPinnableReference()
        let _ = egSteamNetworking_SendMessage(this.connection, buffer.Length, Unsafe.AsPointer(bufferPtr))

    ReceiveMessage(mutable buffer: Span<byte>): int32 =
        let bufferPtr = &&buffer.GetPinnableReference()
        egSteamNetworking_ReceiveMessageFromConnection(this.connection, Unsafe.AsPointer(bufferPtr))

    GetConnection(): SteamNetworkClientConnection =
        SteamNetworkClientConnection(this.connection)

newtype SteamImageHandle =
    internal field handle: int32

    static op_Equality(a: SteamImageHandle, b: SteamImageHandle): bool =
        a.handle == b.handle

newtype SteamId =
    internal field id: uint64

    IsInvalid: bool get() = egSteamUser_IsInvalidSteamID(this.id) != 0

    static op_Equality(a: SteamId, b: SteamId): bool =
        a.id == b.id

    static Parse(idString: string): SteamId =
        SteamId(uint64.Parse(idString))

    static TryParse(idString: string, outIdOut: outref<SteamId>): bool =
        let mutable id = 0: uint64
        let success = UInt64.TryParse(idString, &id)
        if (success)
            outIdOut <- SteamId(id)
        success

Initialize(): () =
    let origDir = Environment.CurrentDirectory
    let markerTy = DotNet.TypeOf<Marker>
    Environment.CurrentDirectory <- Path.GetDirectoryName(markerTy.Assembly.Location)

    let mutable options = default: EgSteam_InitializeOptions
    options.flags <- EgSteam_InitializeFlags.DebugOutputEnabled | EgSteam_InitializeFlags.InitializeRelayNetworkAccess
    if (egSteam_Initialize(&&options) == 0)
        fail("Failed to initialize Steamworks API.")

    Environment.CurrentDirectory <- origDir

Shutdown(): () =
    egSteam_Shutdown()

RunCallbacks(): () =
    egSteam_RunCallbacks()
    egSteamNetworking_RunCallbacks()

CreateNetworkServer(port: int32): SteamNetworkServer =
    let socket = egSteamNetworking_CreateListenSocketP2P(uint16(port))
    if (egSteamNetworking_IsInvalidListenSocket(socket) != 0)
        fail("Failed to create Steam listen socket.")

    SteamNetworkServer(socket)

DestroyNetworkServer(server: SteamNetworkServer): () =
    if (egSteamNetworking_CloseListenSocket(server.socket) == 0)
        fail("Failed to close Steam listen socket.")

CreateNetworkClient(steamId: SteamId, port: int32): SteamNetworkClient =    
    let connection = egSteamNetworking_ConnectP2P(steamId.id, uint16(port))
    if (egSteamNetworking_IsInvalidConnection(connection) != 0)
        fail("Failed to create Steam connection.")

    SteamNetworkClient(connection)

DestroyNetworkClient(client: SteamNetworkClient): () =
    if (egSteamNetworking_CloseConnection(client.connection) == 0)
        fail("Failed to close Steam connection.")

GetSteamId(): SteamId =
    SteamId(egSteamUser_GetSteamID())

GetSteamIdFromConnection(connection: SteamNetworkClientConnection): OptionStruct<SteamId> =
    let mutable steamId = 0: uint64
    let result = egSteamNetworking_GetSteamIDFromConnection(connection.connection, &&steamId)
    if (result != 0)
        SomeStruct(SteamId(steamId))
    else
        NoneStruct

GetPersonaName(): string =
    let namePtr = egSteamFriends_GetPersonaName()
    System.Runtime.InteropServices.Marshal.PtrToStringUTF8(nint(namePtr))

GetPersonaName(steamId: SteamId): string =
    let namePtr = egSteamFriends_GetFriendPersonaName(steamId.id)
    System.Runtime.InteropServices.Marshal.PtrToStringUTF8(nint(namePtr))

SetRichPresence(key: string, value: string): bool =
    let mutable keyHandle = fixedCopyUTF8(key)
    let mutable valueHandle = fixedCopyUTF8(value)
    let result = egSteamFriends_SetRichPresence(Unsafe.AsPointer(keyHandle.AddrOfPinnedObject()), Unsafe.AsPointer(valueHandle.AddrOfPinnedObject()))
    keyHandle.Free()
    valueHandle.Free()
    result != 0

ClearRichPresence(): () =
    egSteamFriends_ClearRichPresence()

GetLargeFriendAvatar(steamId: SteamId, outImageOut: outref<SteamImageHandle>): bool =
    let mutable handle = 0
    let status = egSteamFriends_GetLargeFriendAvatar(steamId.id, &&handle)
    if (status == EgSteamFriends_AvatarLoadStatus.Loaded)
        outImageOut <- SteamImageHandle(handle)
        true
    else
        false
        
GetMediumFriendAvatar(steamId: SteamId, outImageOut: outref<SteamImageHandle>): bool =
    let mutable handle = 0
    let status = egSteamFriends_GetMediumFriendAvatar(steamId.id, &&handle)
    if (status == EgSteamFriends_AvatarLoadStatus.Loaded)
        outImageOut <- SteamImageHandle(handle)
        true
    else
        false

GetSmallFriendAvatar(steamId: SteamId, outImageOut: outref<SteamImageHandle>): bool =
    let mutable handle = 0
    let status = egSteamFriends_GetSmallFriendAvatar(steamId.id, &&handle)
    if (status == EgSteamFriends_AvatarLoadStatus.Loaded)
        outImageOut <- SteamImageHandle(handle)
        true
    else
        false

GetImageSize(imageHandle: SteamImageHandle): (width: int32, height: int32) =
    let mutable width = 0
    let mutable height = 0
    let success = egSteam_GetImageSize(imageHandle.handle, &&width, &&height)
    if (success == 0)
        fail("Failed to get Steam image size.")

    (width, height)

GetImageRGBA(imageHandle: SteamImageHandle, mutable buffer: Span<byte>): () =
    let bufferPtr = &&buffer.GetPinnableReference()
    let success = egSteam_GetImageRGBA(imageHandle.handle, buffer.Length, Unsafe.AsPointer(bufferPtr))
    if (success == 0)
        fail("Failed to get Steam image data.")

private ActivateGameOverlay(dialog: string): () =
    let mutable dialogHandle = fixedCopyUTF8(dialog)
    egSteamFriends_ActivateGameOverlay(Unsafe.AsPointer(dialogHandle.AddrOfPinnedObject()))
    dialogHandle.Free()

ShowFriendsOverlay(): () =
    ActivateGameOverlay("friends")

ShowInviteDialog(): () =
    egSteamFriends_ActivateGameOverlayInviteDialog(GetSteamId().id)