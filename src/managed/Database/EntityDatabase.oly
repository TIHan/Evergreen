namespace Evergreen.Database

open System
open System.IO
open System.Text
open System.Text.Json
open System.Numerics
open System.Diagnostics
open System.Collections.Generic
open System.Collections.Concurrent
open System.Runtime.InteropServices

open Evergreen.Utilities

internal alias SerializeDeltaForNetworkFunction = (prevSrc: ReadOnlySpan<byte>, src: ReadOnlySpan<byte>, ByteStream) -> ()
internal alias DeserializeDeltaForNetworkFunction = (ByteStream, dst: Span<byte>) -> ()

internal struct RegistryEntry =
    Name: string get
    Size: int32 get
    Type: Type get
    Index: int32 get
    SerializeDeltaForNetwork: SerializeDeltaForNetworkFunction get
    DeserializeDeltaForNetwork: DeserializeDeltaForNetworkFunction get

    new(name: string, size: int32, ty: Type, index: int32, serializeDeltaForNetwork: SerializeDeltaForNetworkFunction, deserializeDeltaForNetwork: DeserializeDeltaForNetworkFunction) =
        {
            Name = name
            Size = size
            Type = ty
            Index = index
            SerializeDeltaForNetwork = serializeDeltaForNetwork
            DeserializeDeltaForNetwork = deserializeDeltaForNetwork
        }

class ComponentRegistry =
    private class _JsonFieldNameEndsWithComparer =
        implements IEqualityComparer<string>
        GetHashCode(o: string): int32 = o.GetHashCode()
        Equals(o1: string, o2: string): bool = o1.EndsWith(o2) || o2.EndsWith(o1)

    private Registered: Dictionary<ComponentId, RegistryEntry> get = Dictionary(BitSet512EqualityComparer())
    internal AttachmentLookup: Dictionary<ComponentId, ArchetypeId> get = Dictionary(BitSet512EqualityComparer()) 
    internal NameToId: Dictionary<string, ComponentId> get = Dictionary()
    internal JsonFieldWriteMappings: JsonFieldWriteMappings get = Dictionary(_JsonFieldNameEndsWithComparer())
    internal JsonFieldReadMappings: JsonFieldReadMappings get = Dictionary(_JsonFieldNameEndsWithComparer())

    internal GetIndex(compId: ComponentId): int32 = 
        let entry = this.Registered[compId]
        entry.Index

    internal GetSize(compId: ComponentId): int32 = 
        let entry = this.Registered[compId]
        entry.Size

    internal GetType(compId: ComponentId): Type = 
        let entry = this.Registered[compId]
        entry.Type

    internal GetFunctions(compId: ComponentId): (name: string, SerializeDeltaForNetworkFunction, DeserializeDeltaForNetworkFunction) =
        let entry = this.Registered[compId]
        (entry.Name, entry.SerializeDeltaForNetwork, entry.DeserializeDeltaForNetwork)

    internal Contains(compId: ComponentId): bool = this.Registered.ContainsKey(compId)

    internal Copy(): ComponentRegistry =
        let registryCopy = ComponentRegistry()
        ForEach(this.Registered,
            (mutable pair) -> registryCopy.Registered.Add(pair.Key, pair.Value)
        )
        ForEach(this.AttachmentLookup,
            (mutable pair) -> registryCopy.AttachmentLookup.Add(pair.Key, pair.Value)
        )
        ForEach(this.NameToId,
            (mutable pair) -> registryCopy.NameToId.Add(pair.Key, pair.Value)
        )
        ForEach(this.JsonFieldWriteMappings,
            (mutable pair) -> registryCopy.JsonFieldWriteMappings.Add(pair.Key, pair.Value)
        )
        ForEach(this.JsonFieldReadMappings,
            (mutable pair) -> registryCopy.JsonFieldReadMappings.Add(pair.Key, pair.Value)
        )
        registryCopy

    Contains<T>(): bool where T: blittable, struct, ValueType, { new() }, trait IComponent = this.Contains(T.GetId())
    internal RegisterInternal<T>(checkBuiltIn: bool): () where T: blittable, struct, ValueType, { new() }, trait IComponent = 
        let name = T.GetName()
        if (name == "EntityIndex")
            fail("Component name cannot be 'EntityIndex'.")
        if (checkBuiltIn && (name == "ServerSide"))
            fail("Component name cannot be 'ServerSide'.")
        if (checkBuiltIn && (name == "ClientSide"))
            fail("Component name cannot be 'ClientSide'.")

        let id = T.GetId()

        if (checkBuiltIn && id.ToIndex() < 16)
            fail("Component must have an index 16 or above.")

        this.Registered.Add(id, RegistryEntry(name, T.GetSize(), T.GetType(), T.GetIndex(), T.SerializeDeltaForNetwork, T.DeserializeDeltaForNetwork))
        this.NameToId.Add(name, id)
    Register<T>(): () where T: blittable, struct, ValueType, { new() }, trait IComponent = 
        this.RegisterInternal<T>(true)

    RegisterAttachment<T, TAttachment>(): () where T: blittable, struct, ValueType, { new() }, trait IComponent
                                             where TAttachment: blittable, struct, ValueType, { new() }, trait IComponent =
        let id = T.GetId()
        let mutable attachmentId = default
        if (this.AttachmentLookup.TryGetValue(id, &attachmentId))
            this.AttachmentLookup[id] <- attachmentId | TAttachment.GetId()
        else
            this.AttachmentLookup[id] <- TAttachment.GetId()

    RegisterJsonFieldWriteMapping(fieldNameEndsWith: string, write: (string, Type, ReadOnlySpan<byte>, writer: Utf8JsonWriter) -> ()): () =
        this.JsonFieldWriteMappings[fieldNameEndsWith] <- write

    RegisterJsonFieldReadMapping(fieldNameEndsWith: string, read: (string, Type, Span<byte>, reader: byref<Utf8JsonReader>) -> string): () =
        this.JsonFieldReadMappings[fieldNameEndsWith] <- read

/// Not concurrency safe.
abstract default class EntityDatabase =

    Kind: EntityDatabaseKind get

    field mutable depth: int32
    field mutable parallelDepth: int32

    internal IncrementDepth(): () =
        this.depth <- this.depth + 1

    internal DecrementDepth(): () =
        this.depth <- this.depth - 1

    private IncrementParallelDepth(): () =
        this.parallelDepth <- this.parallelDepth + 1

    private DecrementParallelDepth(): () =
        this.parallelDepth <- this.parallelDepth - 1

    protected Resubs: List<() -> ()> get

    #[DebuggerHidden]
    internal ThrowIfParallelDepth(): () =
        if (this.parallelDepth > 0)
            throw InvalidOperationException("Cannot perform operation in the middle of a parallel one.")

    #[DebuggerHidden]
    internal ThrowIfDepth(): () =
        if (this.depth > 0)
            throw InvalidOperationException("Cannot perform operation in the middle of exposing state.")

    internal Archetypes: ArchetypeManager get

    internal RegisterArchetype(archetypeId: ArchetypeId): int32 =
        if (this.Archetypes.Contains(archetypeId))
            fail("Archetype already registered")
        let result = this.Archetypes.Create(archetypeId, this.registry)
        let mutable i = 0
        while (i < this.GetArchetypeCount())
            let archetype = this.GetArchetype(i)
            ForEach(archetype.Buffers,
                buffer ->
                    buffer.ComponentAdded.ClearSubscribers()
                    buffer.ComponentRemoving.ClearSubscribers()
            )
            i <- i + 1
        ForEach(this.Resubs,
            resub ->
                resub()
        )
        result
        
    internal GetArchetype(index: int32): Archetype =
        this.Archetypes[index]

    internal GetArchetypeCount(): int32 =
        this.Archetypes.Count

    field lockObj: object
    internal GetArchetypedIndex(archetypeId: ArchetypeId): int32 =
        let mutable archetypedIndex = default
        if (this.Archetypes.TryGetValue(archetypeId, &archetypedIndex))
            archetypedIndex
        else
            lock(this.lockObj,
                () ->
                    if (this.Archetypes.TryGetValue(archetypeId, &archetypedIndex))
                        archetypedIndex
                    else
                        this.RegisterArchetype(archetypeId)
            )

    private TryGetValidEntityIdByIndex(index: int32): EntityId =
        if (index < 0 || index >= EntityDatabase.MaxNumberOfEntities)
            EntityId.Nil
        else
            let version = this.entityVersions[index]
            if (version == 0)
                EntityId.Nil
            else
                let mutable entId = EntityId()
                entId.Index <- index
                entId.Version <- version
                entId

    new(kind: EntityDatabaseKind, registry: ComponentRegistry) =
        if (EntityDatabase.MaxNumberOfEntities % 2 != 0)
            fail("MaxNumberOfEntities must be divisible by 2")

        let registryCopy = registry.Copy()
        registryCopy.RegisterInternal<BuiltInComponents.ServerSide>(false)
        registryCopy.RegisterInternal<BuiltInComponents.ClientSide>(false)
        {
            Kind = kind
            depth = 0
            parallelDepth = 0

            registry = registryCopy

            Archetypes = ArchetypeManager()

            // debug
            DebugDeletedEntities = Dictionary()

            // entity management
            lastCreatedEntity = EntityId.Nil
            entityCount = 0
            entityArchetypeIndicesClear = initMutableArray(EntityDatabase.MaxNumberOfEntities, i -> -1)
            entityArchetypeIndices = initMutableArray(EntityDatabase.MaxNumberOfEntities, i -> -1)
            entityIndexLookup = initMutableArray(EntityDatabase.MaxNumberOfEntities, i -> -1)
            entityVersions = zeroArray(EntityDatabase.MaxNumberOfEntities)

            lastCreatedLocalEntity = EntityId.Nil
            localEntityCount = 0
            Resubs = List()

            DeserializeArchetypeIdAdapterState = DeserializeArchetypeIdAdapterState.Create()

            lockObj = Object()
        }

    public static field MaxNumberOfEntities: int32 = 65536 // note: do not increase this

    private field registry: ComponentRegistry

    field DebugDeletedEntities: Dictionary<EntityId, ()> get

    internal GetTypedIndex<T>(archetypedIndex: int32): int32 where T: blittable, struct, ValueType, { new() }, trait IComponent =
        let key = T.GetId()
        let archetype = this.GetArchetype(archetypedIndex)
        archetype.BufferLookup[key]

    internal GetArchetypedIndices(archetypeId: ArchetypeId): int32[] =
        let indices = List<int32>()
        let mutable i = 0
        while (i < this.GetArchetypeCount())
            let archetype = this.GetArchetype(i)

            if (archetype.FullId.IsSupersetOf(archetypeId))
                indices.Add(i)
            
            i <- i + 1

        Unsafe.AsImmutable(indices.ToArray())

    private GetArchetypedIndices(archetypeId: ArchetypeId, filterNotId: ArchetypeId): int32[] =
        let indices = List<int32>()
        let mutable i = 0
        while (i < this.GetArchetypeCount())
            let archetype = this.GetArchetype(i)

            if ((archetype.FullId.IsSupersetOf(archetypeId) && (filterNotId.IsZero || !archetype.FullId.IsSupersetOf(filterNotId))))
                indices.Add(i)
            
            i <- i + 1

        Unsafe.AsImmutable(indices.ToArray())

    /* TODO-language-bug: cannot make this 'protected' as 'Archetype' is internal, but this should be allowed */
    internal AddCore(entId: EntityId, typeId: ComponentId, diff: byref<ArchetypeId>): Archetype =
        this.Check(entId)

        let srcArchetypedIndex = this.entityArchetypeIndices[entId.Index]
        let srcArchetype = this.GetArchetype(srcArchetypedIndex)
        let srcArchetypeId = srcArchetype.Id

        if (srcArchetypeId.IsSupersetOf(typeId))
            srcArchetype
        else
            let lookup = this.entityIndexLookup

            let dstArchetypeId = srcArchetypeId | typeId
            let dstArchetypedIndex = this.GetArchetypedIndex(dstArchetypeId)
            let dstArchetype = this.GetArchetype(dstArchetypedIndex)

            let srcIndex = lookup[entId.Index]
            let dstIndex = dstArchetype.Count

            // Copy components
            dstArchetype.Count <- dstIndex + 1
            srcArchetype.CopyOneTo(srcIndex, dstArchetype, dstIndex)
            dstArchetype.EntityIds.SetAs(dstIndex, entId)

            // Remove leftovers by swapping
            let lastSrcIndex = srcArchetype.Count - 1
            let lastEntId = srcArchetype.EntityIds.GetAs<EntityId>(lastSrcIndex)
            srcArchetype.CopyOneTo(lastSrcIndex, srcArchetype, srcIndex)
            lookup[lastEntId.Index] <- srcIndex
            lookup[entId.Index] <- dstIndex
            
            srcArchetype.EntityIds.SetAs(srcIndex, lastEntId)
            srcArchetype.Count <- lastSrcIndex    

            this.entityArchetypeIndices[entId.Index] <- dstArchetypedIndex

            diff <- dstArchetype.FullId & srcArchetype.FullId.BitwiseNot()

            dstArchetype

    protected DeleteCore(entId: EntityId): () =
        this.ThrowIfDepth()
        this.ThrowIfParallelDepth()
        
        let archetypedIndex = this.entityArchetypeIndices[entId.Index]
        let archetype = this.GetArchetype(archetypedIndex)
        if (archetype.Count == 0)
            fail("Archetype is in an invalid state, no entity count for deletion")

        // ---
        let lookup = this.entityIndexLookup
        let index = lookup[entId.Index]

        this.IncrementDepth()
        archetype.TriggerComponentRemoving(archetype.FullId, index)
        this.DecrementDepth()

        this.SwapRemoveEntityByLookupIndex(archetype, index)
        // ---

        this.DeleteEntityId(entId)

    internal SwapRemoveEntityByLookupIndex(archetype: Archetype, index: int32): () =
        let lastIndex = archetype.Count - 1
        let lastEntId = archetype.EntityIds.GetAs<EntityId>(lastIndex)

        let lookup = this.entityIndexLookup
        lookup[lastEntId.Index] <- index
        archetype.EntityIds.SetAs(index, lastEntId)

        let buffers = archetype.Buffers
        let mutable i = 0
        while (i < buffers.Length)
            let buffer = buffers[i].Store
            buffer.CopyOneTo(lastIndex, buffer, index)
            i <- i + 1

        archetype.Count <- archetype.Count - 1

    // ----------------------------------------------

    internal field mutable lastCreatedEntity: EntityId
    internal field mutable entityCount: int32
    private field entityArchetypeIndicesClear: mutable int32[]
    internal field entityArchetypeIndices: mutable int32[]
    internal field entityIndexLookup: mutable int32[]
    internal field entityVersions: mutable uint32[]

    internal field mutable lastCreatedLocalEntity: EntityId
    internal field mutable localEntityCount: int32

    internal NewEntityId(archetypedIndex: int32): EntityId =
        if (this.Archetypes[archetypedIndex].IsLocal)
            this.NewLocalEntityId(archetypedIndex)
        else
            ()
            if (!this.CanSpawnEntity)
                fail("Max entity count reached")
            let index =
                if (this.lastCreatedEntity.IsNil)
                    0
                else
                    let nextIndex = this.lastCreatedEntity.Index + 1
                    if (nextIndex == (EntityDatabase.MaxNumberOfEntities / 2))
                        0
                    else
                        nextIndex

            let version = 
                let version = this.entityVersions[index]
                if (version == 0)
                    version + 1 // first entity
                else
                    version // this is the next version
            this.entityVersions[index] <- version
            this.entityArchetypeIndices[index] <- archetypedIndex
            this.entityCount <- this.entityCount + 1

            let mutable entId = EntityId()
            entId.Index <- index
            entId.Version <- version
            this.lastCreatedEntity <- entId
            entId

    internal NewLocalEntityId(archetypedIndex: int32): EntityId =
        if (!this.CanSpawnLocalEntity)
            fail("Max local entity count reached")
        let index =
            if (this.lastCreatedLocalEntity.IsNil)
                EntityDatabase.MaxNumberOfEntities / 2
            else
                let nextIndex = this.lastCreatedLocalEntity.Index + 1
                if (nextIndex == EntityDatabase.MaxNumberOfEntities)
                    EntityDatabase.MaxNumberOfEntities / 2
                else
                    nextIndex

        let version = 
            let version = this.entityVersions[index]
            if (version == 0)
                version + 1 // first entity
            else
                version // this is the next version
        this.entityVersions[index] <- version
        this.entityArchetypeIndices[index] <- archetypedIndex
        this.localEntityCount <- this.localEntityCount + 1

        let mutable entId = EntityId()
        entId.Index <- index
        entId.Version <- version
        this.lastCreatedLocalEntity <- entId
        entId

    internal Check(entId: EntityId): () =
        if (!this.IsValid(entId))
            fail("Invalid entity.")

    private DeleteEntityId(entId: EntityId): () =
        this.entityVersions[entId.Index] <- this.entityVersions[entId.Index] + 1
        this.entityArchetypeIndices[entId.Index] <- -1

        if (this.IsLocal(entId))
            this.localEntityCount <- this.localEntityCount - 1
        else
            this.entityCount <- this.entityCount - 1

    IsValid(entId: EntityId): bool =
        this.entityArchetypeIndices[entId.Index] != -1 && this.entityVersions[entId.Index] == entId.Version

    IsLocal(entId: EntityId): bool =
        entId.Index >= (EntityDatabase.MaxNumberOfEntities / 2)

    CanSpawnEntity: bool get() = this.entityCount < (EntityDatabase.MaxNumberOfEntities / 2)

    CanSpawnLocalEntity: bool get() = this.localEntityCount < (EntityDatabase.MaxNumberOfEntities / 2)

    EntityCount: int32 get() = this.entityCount

    LocalEntityCount: int32 get() = this.localEntityCount

    protected DebugCheckIntegrity(): () =
#if DEBUG
        let lookup = Dictionary<EntityId, Archetype>()
        let mutable i = 0
        while (i < this.GetArchetypeCount())
            let archetype = this.GetArchetype(i)
            let mutable j = 0
            while (j < archetype.Count)
                let mutable entId = archetype.EntityIds.GetAs<EntityId>(j)
                if (!lookup.TryAdd(entId, archetype))
                    let prevArchetype = lookup[entId]
                    fail("Entity '" + entId.ToString() + "' is used in multiple archetypes.\nArchetype1: " + prevArchetype.ComponentListText + "\nArchetype2: " + archetype.ComponentListText)
                j <- j + 1
            i <- i + 1
#end
        ()

    CopyTo(dst: EntityDatabase): () =          
        if (this.GetArchetypeCount() > dst.GetArchetypeCount())
            let mutable i = 0
            while (i < this.GetArchetypeCount())
                let thisArchetype = this.GetArchetype(i)
                if (i >= dst.GetArchetypeCount())
                    let dstIndex = dst.RegisterArchetype(thisArchetype.Id)
                    if (i != dstIndex)
                        fail("Archetype integrity failed")
                let dstArchetype = dst.GetArchetype(i)
                if (thisArchetype.Id != dstArchetype.Id)
                    fail("Archetype integrity failed")
                i <- i + 1
        else if (this.GetArchetypeCount() < dst.GetArchetypeCount())
            let mutable i = this.GetArchetypeCount()
            while (i < dst.GetArchetypeCount())
                let dstArchetype = dst.GetArchetype(i)
                dstArchetype.Count <- 0
                i <- i + 1

#if DEBUG
        let mutable i = 0
        while (i < this.GetArchetypeCount())
            let thisArchetype = this.GetArchetype(i)
            let dstArchetype = dst.GetArchetype(i)
            if (thisArchetype.Id != dstArchetype.Id)
                fail("Archetype integrity failed")
            i <- i + 1
#end      

        this.DebugCheckIntegrity()

        Span(this.entityVersions).CopyTo(Span(dst.entityVersions))
        Span(this.entityArchetypeIndices).CopyTo(Span(dst.entityArchetypeIndices))
        Span(this.entityIndexLookup).CopyTo(Span(dst.entityIndexLookup))

        dst.lastCreatedEntity <- this.lastCreatedEntity
        dst.entityCount <- this.entityCount

        dst.lastCreatedLocalEntity <- this.lastCreatedLocalEntity
        dst.localEntityCount <- this.localEntityCount

        let mutable i = 0
        while (i < this.GetArchetypeCount())
            let archetype = this.GetArchetype(i)
            let dstArchetype = dst.GetArchetype(i)
            archetype.CopyTo(dstArchetype)
            i <- i + 1

        dst.DebugCheckIntegrity()

    static SerializeForNetwork(db: EntityDatabase, bstream: ByteStream): () =
        db.DebugCheckIntegrity()

        bstream.Write<uint16>(uint16(db.entityCount))

        let mutable i = 0
        while (i < db.GetArchetypeCount())
            let archetype = db.GetArchetype(i)
            if (!archetype.IsLocal)
                let count = archetype.Count
                let entIds = archetype.EntityIds
                let buffers = archetype.NonAttachmentBuffers

                bstream.Write<uint16>(uint16(i))
                bstream.Write<ArchetypeId>(archetype.Id)
                bstream.Write<uint16>(uint16(count))

                entIds.ForEachChunk(entIds.ItemSize * count,
                    (chunk, _count) ->
                        bstream.Write(Span<_>.op_Implicit(chunk))
                )

                let mutable bufferCount = 0
                let mutable bufferIndex = 0
                while (bufferIndex < buffers.Length)
                    let buffer = buffers[bufferIndex].Store

                    let length = buffer.ItemSize * count
                    buffer.ForEachChunk(length,
                        (rawBufferSpan, _count)  ->
                            bstream.Write(Span<_>.op_Implicit(rawBufferSpan))
                    )
                    bufferIndex <- bufferIndex + 1

            i <- i + 1

    static DeserializeForNetwork(bstream: ByteStream, db: EntityDatabase): () =
        let adapterState = db.DeserializeArchetypeIdAdapterState
        db.DebugCheckIntegrity()
        db.ClearEntities()

        db.entityCount <- int32(bstream.Read<uint16>())
        while (bstream.Position.Index < bstream.TotalCount)
            let senderArchetypedIndex = int32(bstream.Read<uint16>())
            let archetypeId = bstream.Read<ArchetypeId>()
            let count = int32(bstream.Read<uint16>())
            let archetypedIndex = db.GetArchetypedIndex(archetypeId)
            adapterState.Value[senderArchetypedIndex] <- archetypedIndex
            let archetype = db.GetArchetype(archetypedIndex)
            let buffers = archetype.NonAttachmentBuffers

            archetype.EnsureCapacity(count)

            let entIds = archetype.EntityIds
            entIds.ForEachChunk(entIds.ItemSize * count,
                (chunk, _count) ->
                    bstream.Read(chunk)
            )

            let bufferCount = buffers.Length
            let mutable bufferIndex = 0
            while (bufferIndex < bufferCount)
                let buffer = buffers[bufferIndex].Store
                let length = buffer.ItemSize * count
                buffer.ForEachChunk(length,
                    (rawBufferSpan, _count) ->
                        bstream.Read(rawBufferSpan)
                )
                bufferIndex <- bufferIndex + 1

            archetype.Count <- count

            // Fix-ups
            let lookup = db.entityIndexLookup
            let entVersions = db.entityVersions 
            let entArchetypeIndices = db.entityArchetypeIndices
            let mutable i = 0
            while (i < count)
                let entId = entIds.GetAs<EntityId>(i)
                let index = entId.Index
                entArchetypeIndices[index] <- archetypedIndex
                entVersions[index] <- entId.Version
                lookup[index] <- i
                i <- i + 1

        db.DebugCheckIntegrity()

    static SyncArchetypesIfNeccessary(prevDb: EntityDatabase, db: EntityDatabase): () =
        if (db.GetArchetypeCount() == 0)
            let mutable i = 0
            while (i < prevDb.GetArchetypeCount())
                let prevArchetype = prevDb.GetArchetype(i)
                let _ = db.RegisterArchetype(prevArchetype.Id)
                i <- i + 1

    static Reset(db: EntityDatabase): () =
        db.ClearEntities()
        db.ClearLocalEntities()
        db.Archetypes.Clear()
        db.DeserializeArchetypeIdAdapterState.Reset()

    static SerializeDeltaForNetwork(prevDb: EntityDatabase, db: EntityDatabase, bstream: ByteStream): () =
        let prevArchetypeCount = prevDb.GetArchetypeCount()

#if DEBUG
        if (prevArchetypeCount > db.GetArchetypeCount())       
            fail("Archetype integrity failed")

        let mutable i = 0
        while (i < prevDb.GetArchetypeCount())
            let prevArchetype = prevDb.GetArchetype(i)
            let archetype = db.GetArchetype(i)
            if (prevArchetype.Id != archetype.Id)
                fail("Archetype integrity failed")
            i <- i + 1
#end
        bstream.Write<uint16>(uint16(db.entityCount))

        let mutable i = 0
        while (i < db.GetArchetypeCount())
            let archetype = db.GetArchetype(i)
            if (!archetype.IsLocal)
                let count = archetype.Count
                let buffers = archetype.NonAttachmentBuffers

                let prevArchetypeOpt = 
                    if (i >= prevArchetypeCount)
                        None
                    else
                        Some(prevDb.GetArchetype(i))

                let mustSerialize =
                    match (prevArchetypeOpt)
                    | Some(prevArchetype) =>
#if DEBUG
                        if (archetype.Id != prevArchetype.Id)
                            fail("Archetypes are not in sync")
#end
                        prevArchetype.EnsureCapacity(count)
                        prevArchetype.Count != 0 || archetype.Count != 0
                    | _ =>
                        true

                archetype.EnsureCapacity(count)

                if (mustSerialize)
                    let nextArchetypeStatePosition = bstream.Position
                    let nextArchetypeStateCount = bstream.TotalCount
                    let mutable hasArchetypeData = false
                    bstream.WritePackedUInt16(uint16(i))

                    if (prevArchetypeOpt.IsSome)
                        bstream.WriteBit(false)
                    else
                        bstream.WriteBit(true)
                        bstream.Write(archetype.Id)

                    match (prevArchetypeOpt)
                    | Some(prevArchetype) =>
                        if (prevArchetype.Count == archetype.Count)
                            bstream.WriteBit(false)
                        else
                            hasArchetypeData <- true
                            bstream.WriteBit(true)
                            bstream.WritePackedUInt16(uint16(count))
                    | _ =>
                        hasArchetypeData <- true
                        bstream.WriteBit(true)
                        bstream.WritePackedUInt16(uint16(count))

                    let mutable entIds = archetype.EntityIds

                    let mutable k = 0
                    while (k < count)
                        let entId = entIds.GetAs<EntityId>(k)

                        match (prevArchetypeOpt)
                        | Some(prevArchetype) when (k < prevArchetype.Count) =>
                            let mutable prevEntIds = prevArchetype.EntityIds
                            let prevEntId = prevEntIds.GetAs<EntityId>(k)
                            if (prevEntId.Index == entId.Index && prevEntId.Version == entId.Version)
                                bstream.WriteBit(false)
                            else
                                hasArchetypeData <- true
                                bstream.WriteBit(true)
                                bstream.Write(entId)                           
                        | _ =>
                            hasArchetypeData <- true
                            bstream.WriteBit(true)
                            bstream.Write(entId)
                        k <- k + 1

                    let mutable bufferIndex = 0
                    while (bufferIndex < buffers.Length)
                        let buffer = buffers[bufferIndex]
                        let serializeDelta = buffer.SerializeDeltaForNetwork
                        let buffer = buffers[bufferIndex].Store
                        let length = buffer.ItemSize * count

                        match (prevArchetypeOpt)
                        | Some(prevArchetype) =>
                            let prevCount = prevArchetype.Count
                            let prevBuffers = prevArchetype.NonAttachmentBuffers
                            buffer.ForEachChunk2(prevBuffers[bufferIndex].Store, length,
                                (mutable rawBufferSpan, mutable prevRawBufferSpan, count) ->
                                    let mutable k = 0
                                    while (k < count)
                                        let slice = rawBufferSpan.Slice(buffer.ItemSize * k, buffer.ItemSize)

                                        // This ensures that if the data was moved, we will always write the data as to avoid stale data.
                                        if (k < prevCount)
                                            bstream.WriteBit(false)
                                            let prevSlice = prevRawBufferSpan.Slice(buffer.ItemSize * k, buffer.ItemSize)
                                            if (System.MemoryExtensions.SequenceEqual(prevSlice, Span<_>.op_Implicit(slice)))
                                                bstream.WriteBit(false)
                                            else
                                                hasArchetypeData <- true
                                                bstream.WriteBit(true)
                                                serializeDelta(Span<_>.op_Implicit(prevSlice), Span<_>.op_Implicit(slice), bstream)
                                        else
                                            hasArchetypeData <- true
                                            bstream.WriteBit(true)
                                            bstream.Write(slice)
                                        k <- k + 1
                            )
                        | _ =>
                            buffer.ForEachChunk(length,
                                (mutable rawBufferSpan, count) ->
                                    let mutable k = 0
                                    while (k < count)
                                        let slice = rawBufferSpan.Slice(buffer.ItemSize * k, buffer.ItemSize)
                                        hasArchetypeData <- true
                                        bstream.WriteBit(true)
                                        bstream.Write(slice)
                                        k <- k + 1                             
                            )

                        bufferIndex <- bufferIndex + 1
                    if (!hasArchetypeData)
                        bstream.Position <- nextArchetypeStatePosition
                        bstream.TotalCount <- nextArchetypeStateCount

            i <- i + 1

    private DeserializeArchetypeIdAdapterState: DeserializeArchetypeIdAdapterState get
    static DeserializeDeltaForNetwork(bstream: ByteStream, db: EntityDatabase): () =
        let adapterState = db.DeserializeArchetypeIdAdapterState
        db.DebugCheckIntegrity()
        db.ClearEntitiesExceptArchetypes()

        db.entityCount <- int32(bstream.Read<uint16>())

        while (bstream.Position.Index < bstream.TotalCount)
            let senderArchetypedIndex = int32(bstream.ReadPackedUInt16())
            let archetype = 
                if (bstream.ReadBit())
                    let archetypeId = bstream.Read<ArchetypeId>()
                    let archetypedIndex = db.GetArchetypedIndex(archetypeId)
                    adapterState.Value[senderArchetypedIndex] <- archetypedIndex
                    db.GetArchetype(archetypedIndex)
                else
                    db.GetArchetype(adapterState.Value[senderArchetypedIndex])
            let count = 
                if (bstream.ReadBit())
                    int32(bstream.ReadPackedUInt16())
                else
                    archetype.Count
            let buffers = archetype.NonAttachmentBuffers
            let entIds = archetype.EntityIds

            archetype.EnsureCapacity(count)
            
            let mutable k = 0
            while (k < count)
                if (bstream.ReadBit())
                    entIds.SetAs(k, bstream.Read<EntityId>())
                k <- k + 1

            let bufferCount = buffers.Length
            let mutable bufferIndex = 0
            while (bufferIndex < bufferCount)
                let buffer = buffers[bufferIndex]
                let deserializeDelta = buffer.DeserializeDeltaForNetwork
                let buffer = buffer.Store
                let length = buffer.ItemSize * count

                buffer.ForEachChunk(length,
                    (mutable rawBufferSpan, count) ->
                        let mutable k = 0
                        while (k < count)
                            if (bstream.ReadBit())
                                bstream.Read(rawBufferSpan.Slice(buffer.ItemSize * k, buffer.ItemSize))
                            else if (bstream.ReadBit())
                                deserializeDelta(bstream, rawBufferSpan.Slice(buffer.ItemSize * k, buffer.ItemSize))
                            k <- k + 1
                )
                bufferIndex <- bufferIndex + 1

            archetype.Count <- count

            // Fix-ups
            // let archetypedIndex = db.GetArchetypedIndex(archetype.Id)
            // let lookup = db.entityIndexLookup
            // let entVersions = db.entityVersions 
            // let entArchetypeIndices = db.entityArchetypeIndices
            // let mutable i = 0
            // while (i < count)
            //     let entId = entIds.GetAs<EntityId>(i)
            //     let index = entId.Index
            //     entArchetypeIndices[index] <- archetypedIndex
            //     entVersions[index] <- entId.Version
            //     lookup[index] <- i
            //     i <- i + 1

        // -- Full fixups --
        // We have to do this since we clear out the entity tables when deserializing deltas.
        // This is to handle entity deletions in deltas. If the archetypes are synced with the exact EntityIds, then we know what entities were deleted.
        // REVIEW: Perhaps there is a better way to handle it? If so, then we can use the old approach that is commented above.
        // REVIEW: This should not be a perf issue, but something to keep in mind.
        //         We are iterating over all archetypes and updating the entity tables based on each archetype's information.
        let lookup = db.entityIndexLookup
        let entVersions = db.entityVersions 
        let entArchetypeIndices = db.entityArchetypeIndices
        let numOfArchetypes = db.Archetypes.Count
        let mutable archetypedIndex = 0
        while (archetypedIndex < numOfArchetypes)
            let archetype = db.Archetypes[archetypedIndex]
            if (!archetype.IsLocal)
                let count = archetype.Count
                if (count > 0)
                    // Fix-ups
                    let entIds = archetype.EntityIds

                    let mutable i = 0
                    while (i < count)
                        let entId = entIds.GetAs<EntityId>(i)
                        let index = entId.Index
                        entArchetypeIndices[index] <- archetypedIndex
                        entVersions[index] <- entId.Version
                        lookup[index] <- i
                        i <- i + 1
            archetypedIndex <- archetypedIndex + 1

        db.DebugCheckIntegrity()

    ClearEntities(): () =
        this.lastCreatedEntity <- EntityId.Nil
        this.entityCount <- 0
        Span(this.entityArchetypeIndicesClear, 0, EntityDatabase.MaxNumberOfEntities / 2).CopyTo(Span(this.entityArchetypeIndices))
        Span(this.entityVersions, 0, EntityDatabase.MaxNumberOfEntities / 2).Clear()

        // Archetype counts should also be zero.
        let mutable i = 0
        while (i < this.GetArchetypeCount())
            let archetype = this.GetArchetype(i)
            if (!archetype.IsLocal)
                archetype.Count <- 0
            i <- i + 1

    ClearLocalEntities(): () =
        this.lastCreatedLocalEntity <- EntityId.Nil
        this.localEntityCount <- 0
        Span(this.entityArchetypeIndicesClear, EntityDatabase.MaxNumberOfEntities / 2, EntityDatabase.MaxNumberOfEntities / 2).CopyTo(Span(this.entityArchetypeIndices))
        Span(this.entityVersions, EntityDatabase.MaxNumberOfEntities / 2, EntityDatabase.MaxNumberOfEntities / 2).Clear()

        // Archetype counts should also be zero.
        let mutable i = 0
        while (i < this.GetArchetypeCount())
            let archetype = this.GetArchetype(i)
            if (archetype.IsLocal)
                archetype.Count <- 0
            i <- i + 1

    private ClearEntitiesExceptArchetypes(): () =
        this.lastCreatedEntity <- EntityId.Nil
        this.entityCount <- 0
        Span(this.entityArchetypeIndicesClear, 0, EntityDatabase.MaxNumberOfEntities / 2).CopyTo(Span(this.entityArchetypeIndices))
        Span(this.entityVersions, 0, EntityDatabase.MaxNumberOfEntities / 2).Clear()

    internal struct CreatedEntityInfo =
        public field mutable EntityId: EntityId = default
        public field mutable ArchetypeId: ArchetypeId = default

    #[DebuggerDisplay("{EntityId}")]
    internal struct DeletingEntityInfo =
        public field mutable EntityId: EntityId = default

    internal struct ArchetypeChangedEntityInfo =
        public field mutable EntityIndex: int32 = default
        public field mutable PreviousIndex: int32 = default
        public field mutable Index: int32 = default
        public field mutable PreviousArchetypeId: ArchetypeId = default
        public field mutable ArchetypeId: ArchetypeId = default

    struct ReplicatingEvents =
        internal field CreatedEntities: List<CreatedEntityInfo> = List()
        internal field DeletingEntities: List<DeletingEntityInfo> = List()
        internal field ArchetypeChangedEntities: List<ArchetypeChangedEntityInfo> = List()

    GetReplicatingEvents(prevDb: EntityDatabase, nonLocalOnly: bool): ReplicatingEvents =
        let verboseLogging = false

        let events = ReplicatingEvents()
        // --
        let prevLookup = prevDb.entityIndexLookup
        let lookup = this.entityIndexLookup
        let prevVersions = prevDb.entityVersions
        let versions = this.entityVersions

        let maxNumber = 
            if (nonLocalOnly)
                MaxNumberOfEntities / 2
            else
                MaxNumberOfEntities

        let mutable i = 0
        while (i < maxNumber)
            let prevVersion = prevVersions[i]
            let version = versions[i]

            let prevArchetypeIndex = prevDb.entityArchetypeIndices[i]
            let archetypeIndex = this.entityArchetypeIndices[i]

            if (prevVersion != version)
                if (prevArchetypeIndex != -1 && archetypeIndex != -1)
                    fail("zoot")
                if (prevArchetypeIndex != -1)
                    let mutable entId = EntityId()
                    entId.Index <- i
                    entId.Version <- prevVersion
                    let mutable info = DeletingEntityInfo()
                    info.EntityId <- entId
                    events.DeletingEntities.Add(info)

                if (archetypeIndex != -1)
                    let mutable entId = EntityId()
                    entId.Index <- i
                    entId.Version <- version
                    let mutable info = CreatedEntityInfo()
                    info.EntityId <- entId
                    info.ArchetypeId <- this.GetArchetype(archetypeIndex).Id
                    events.CreatedEntities.Add(info)

            else if (prevArchetypeIndex != -1 && archetypeIndex != -1)
                let prevIndex = prevLookup[i]
                let index = lookup[i]

                let prevArchetypeId = prevDb.GetArchetype(prevArchetypeIndex).Id
                let archetypeId = this.GetArchetype(archetypeIndex).Id
                
                if (prevIndex != index || (prevArchetypeId != archetypeId))
                    let mutable info = ArchetypeChangedEntityInfo()
                    info.EntityIndex <- i
                    info.PreviousIndex <- prevIndex
                    info.Index <- index
                    info.PreviousArchetypeId <- prevArchetypeId
                    info.ArchetypeId <- archetypeId
                    events.ArchetypeChangedEntities.Add(info)

            i <- i + 1
        // --
        events

    SerializeReplication(prevDb: EntityDatabase, nonLocalOnly: bool, dstStream: ByteStream): () =
        let prevLookup = prevDb.entityIndexLookup
        let lookup = this.entityIndexLookup
        let prevVersions = prevDb.entityVersions
        let versions = this.entityVersions

        let maxNumber = 
            if (nonLocalOnly)
                MaxNumberOfEntities / 2
            else
                MaxNumberOfEntities

        // TODO: Make this non-allocating if it makes sense to.
        let deletingEntities = Queue()

        // TODO: Make this non-allocating if it makes sense to.
        let createdEntities = Queue()

        // TODO: Make this non-allocating if it makes sense to.
        let archetypeChanged = Queue()

        let mutable i = 0
        while (i < maxNumber)
            let prevVersion = prevVersions[i]
            let version = versions[i]

            let prevArchetypeIndex = prevDb.entityArchetypeIndices[i]
            let archetypeIndex = this.entityArchetypeIndices[i]

            if (prevVersion != version)
                if (prevArchetypeIndex != -1 && archetypeIndex != -1)
                    fail("doot")
                if (prevArchetypeIndex != -1)
                    let mutable entId = EntityId()
                    entId.Index <- i
                    entId.Version <- prevVersion
                    deletingEntities.Enqueue(entId)

                if (archetypeIndex != -1)
                    let mutable entId = EntityId()
                    entId.Index <- i
                    entId.Version <- version
                    createdEntities.Enqueue((entId, this.GetArchetype(archetypeIndex).Id))

            else if (prevArchetypeIndex != -1 && archetypeIndex != -1)
                let prevIndex = prevLookup[i]
                let index = lookup[i]

                let prevArchetypeId = prevDb.GetArchetype(prevArchetypeIndex).Id
                let archetypeId = this.GetArchetype(archetypeIndex).Id
                
                if (prevIndex != index || (prevArchetypeId != archetypeId))
                    archetypeChanged.Enqueue((i, prevIndex, index, prevArchetypeId, archetypeId))

            i <- i + 1

        dstStream.WriteInt32(deletingEntities.Count)
        let mutable result = default
        while (deletingEntities.TryDequeue(&result))
            let entId = result
            dstStream.Write(entId)

        dstStream.WriteInt32(archetypeChanged.Count)
        let mutable result = default
        while (archetypeChanged.TryDequeue(&result))
            let (entIndex, prevIndex, index, prevArchetypeId, archetypeId) = result
            dstStream.WriteInt32(entIndex)
            dstStream.WriteInt32(prevIndex)
            dstStream.WriteInt32(index)
            dstStream.Write(prevArchetypeId)
            dstStream.Write(archetypeId)

        dstStream.WriteInt32(createdEntities.Count)
        let mutable result = default
        while (createdEntities.TryDequeue(&result))
            let (entId, archetypeId) = result
            dstStream.Write(entId)
            dstStream.Write(archetypeId)

    static SerializeJsonForEntity(db: EntityDatabase, entId: EntityId, utf8Stream: Stream): () =
        if (!db.IsValid(entId))
            // TODO: better message
            fail("entity not valid")

        let archetype = db.GetArchetype(db.entityArchetypeIndices[entId.Index])
        let buffers = archetype.Buffers
        let entIds = archetype.EntityIds
        let i = db.entityIndexLookup[entId.Index]

        let mutable options = default: JsonWriterOptions
        options.Indented <- true
        let json = Utf8JsonWriter(utf8Stream, options)

        json.WriteStartObject()

        json.WritePropertyName("EntityIndex")
        json.WriteNumberValue(entIds.GetAs<EntityId>(i).Index)

        let bufferCount = buffers.Length
        let mutable bufferIndex = 0
        while (bufferIndex < bufferCount)
            let buffer = buffers[bufferIndex]

            if (archetype.AttachmentId & buffer.ComponentId != buffer.ComponentId)
                let span = Span<_>.op_Implicit(buffer.Store.Get(i))
                json.WritePropertyName(buffer.ComponentName)
                TypeHelpers.Write(db.registry.JsonFieldWriteMappings, buffer.Type, span, json)

            bufferIndex <- bufferIndex + 1

        json.WriteEndObject()

        json.Flush()
        json.Dispose()

    static SerializeJson(db: EntityDatabase, utf8Stream: Stream): () =
        if (db.Kind == EntityDatabaseKind.Client)
            fail("Cannot serialize a client database")

        let mutable options = default: JsonWriterOptions
        options.Indented <- true
        let mutable json = Utf8JsonWriter(utf8Stream, options)

        db.DebugCheckIntegrity()

        json.WriteStartObject()

        json.WritePropertyName("LastCreatedEntity")
        TypeHelpers.WriteEntity(&json, db.lastCreatedEntity)

        json.WritePropertyName("LastCreatedLocalEntity")
        TypeHelpers.WriteEntity(&json, db.lastCreatedLocalEntity)

        json.WritePropertyName("Entities")
        json.WriteStartArray()

        let mutable i = 0
        while (i < db.GetArchetypeCount())
            let archetype = db.GetArchetype(i)
            let count = archetype.Count
            let buffers = archetype.Buffers
            let entIds = archetype.EntityIds

            For(count,
                i ->
                    json.WriteStartObject()

                    json.WritePropertyName("EntityIndex")
                    json.WriteNumberValue(entIds.GetAs<EntityId>(i).Index)

                    let bufferCount = buffers.Length
                    let mutable bufferIndex = 0
                    while (bufferIndex < bufferCount)
                        let buffer = buffers[bufferIndex]

                        if (archetype.AttachmentId & buffer.ComponentId != buffer.ComponentId)
                            let span = Span<_>.op_Implicit(buffer.Store.Get(i))
                            json.WritePropertyName(buffer.ComponentName)
                            TypeHelpers.Write(db.registry.JsonFieldWriteMappings, buffer.Type, span, json)

                        bufferIndex <- bufferIndex + 1

                    json.WriteEndObject()
            )

            i <- i + 1

        json.WriteEndArray()
        json.WriteEndObject()

        json.Flush()
        json.Dispose()

    private static PreDeserializeJsonForEntityCoreFinished(reader: byref<Utf8JsonReader>, db: EntityDatabase, i: int32, lookup: mutable int32[], iterLookup: mutable EntityId[], nameToIndex: Dictionary<string, int32>, compIds: List<ComponentId>, count: byref<int32>, localCount: byref<int32>, entIndex: byref<int32>, entName: byref<string>, isUsingEntityIndices: bool): () =
        let mutable archetypeId = default: ArchetypeId
        For(compIds.Count,
                i ->
                    archetypeId <- archetypeId | compIds[i]
            )
        let archetypedIndex = db.GetArchetypedIndex(archetypeId)
        let archetype = db.GetArchetype(archetypedIndex)

        if (!(db.Kind == EntityDatabaseKind.Client && !archetype.IsClientSide))
            let mutable entId = EntityId.Nil
            if (!isUsingEntityIndices)
                if (archetype.IsLocal)
                    entId <- db.NewLocalEntityId(archetypedIndex)
                else
                    entId <- db.NewEntityId(archetypedIndex)
                if (!string.IsNullOrWhiteSpace(entName))
                    nameToIndex.Add(entName, entId.Index)
                entName <- string.Empty
            else
                entId.Index <- entIndex
                entId.Version <- db.entityVersions[entId.Index]

            db.entityArchetypeIndices[entId.Index] <- archetypedIndex

            let index = archetype.Count
            archetype.Count <- index + 1
            archetype.EntityIds.SetAs(index, entId)
            lookup[entId.Index] <- index
            iterLookup[i] <- entId

            if (db.IsLocal(entId))
                localCount <- localCount + 1
            else
                count <- count + 1
        compIds.Clear()

    private static PreDeserializeJsonForEntityCore(reader: byref<Utf8JsonReader>, db: EntityDatabase, compIds: List<ComponentId>, entIndex: byref<int32>, entName: byref<string>, isUsingEntityIndices: bool): bool =
        match (reader.TokenType)
        | JsonTokenType.StartObject =>
            let _ = reader.Read()
            true               
        | JsonTokenType.EndObject =>
            TypeHelpers.ReadEndObject(&reader)
            false
        | JsonTokenType.PropertyName =>
            let propName = reader.GetString()
            let _ = reader.Read()

            if (propName == "EntityIndex")
                if (!isUsingEntityIndices)
                    fail("Malformed json")
                entIndex <- reader.GetInt32()
                let _ = reader.Read()
            else if (propName == "EntityName")
                if (isUsingEntityIndices)
                    fail("Malformed json")
                entName <- reader.GetString()
                let _ = reader.Read()
            else
                // Component
                let componentId = db.registry.NameToId[propName]
                compIds.Add(componentId)
                reader.Skip()
                TypeHelpers.ReadEndObject(&reader)           
            true
        | _ =>
            fail("Unhandled json token type")

    private static DeserializeJsonForEntityCore(visitedComps: HashSet<string>, reader: byref<Utf8JsonReader>, db: EntityDatabase, i: int32, lookup: mutable int32[], iterLookup: mutable EntityId[], nameToIndex: Dictionary<string, int32>): bool =
        match (reader.TokenType)
        | JsonTokenType.StartObject =>
            let _ = reader.Read()
            true               
        | JsonTokenType.EndObject =>
            TypeHelpers.ReadEndObject(&reader)
            false
        | JsonTokenType.PropertyName =>
            let propName = reader.GetString()
            let _ = reader.Read()

            if (propName == "EntityIndex")
                let _ = reader.Read()

            else if (propName == "EntityName")
                let _ = reader.Read()

            else
                // Component
                let componentId = db.registry.NameToId[propName]
                let componentTy = db.registry.GetType(componentId)

                let entId = iterLookup[i]

                if (entId.IsNil)
                    reader.Skip()
                    TypeHelpers.ReadEndObject(&reader)
                else
                    let archetypedIndex = db.entityArchetypeIndices[entId.Index]

                    if (archetypedIndex != -1)
                        let archetype = db.GetArchetype(archetypedIndex)

                        let buffer = archetype.Buffers[archetype.BufferLookup[componentId]]
                        let index = lookup[entId.Index]
                        let mutable span = buffer.Store.Get(index)

                        // First time we visit a component, it must be provided all fields.
                        let isStrict = visitedComps.Add(propName)
                        TypeHelpers.Read(isStrict, nameToIndex, db.registry.JsonFieldReadMappings, componentTy, span, &reader)
                    else
                        reader.Skip()
                        TypeHelpers.ReadEndObject(&reader)   
            true
        | _ =>
            fail("Unhandled json token type")

    static DeserializeJson(utf8Stream: Stream, db: EntityDatabase): () =
        db.DebugCheckIntegrity()
        db.ClearEntities()
        db.ClearLocalEntities()

        // Clear archetype buffers.
        let mutable i = 0
        while (i < db.GetArchetypeCount())
            let archetype = db.GetArchetype(i)
            archetype.ClearAll()
            i <- i + 1

        let length = int32(utf8Stream.Length - utf8Stream.Position)
        let buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(length)
        let length = utf8Stream.Read(buffer, 0, length)
        let json = ReadOnlySpan(buffer, 0, length)

        let mutable options = default: JsonReaderOptions
        let mutable reader = Utf8JsonReader(json, options)

        let _ = reader.Read()

        TypeHelpers.ReadStartObject(&reader)

        if (reader.GetString() == "$schema")
            let _ = reader.Read()

            if (reader.TokenType != JsonTokenType.String)
                fail("Expected type 'string' for '$schema'.")
            let _ = reader.Read()

        let mutable isUsingEntityIndices = false
        if (TypeHelpers.TryReadPropertyEntityId("LastCreatedEntity", &reader, &db.lastCreatedEntity))
            isUsingEntityIndices <- true

            if (db.Kind != EntityDatabaseKind.Client)
                if (db.lastCreatedEntity.Version > 1)
                    For(EntityDatabase.MaxNumberOfEntities / 2,
                        i ->
                            db.entityVersions[i] <- db.lastCreatedEntity.Version - 1
                    )
                For(db.lastCreatedEntity.Index + 1,
                    i ->
                        db.entityVersions[i] <- db.lastCreatedEntity.Version
                )
            else
                db.lastCreatedEntity <- EntityId.Nil

            if (!TypeHelpers.TryReadPropertyEntityId("LastCreatedLocalEntity", &reader, &db.lastCreatedLocalEntity))
                fail("Missing 'LastCreatedLocalEntity' after 'LastCreatedEntity'.")

            if (db.lastCreatedLocalEntity.Version > 1)
                For(EntityDatabase.MaxNumberOfEntities / 2,
                    i ->
                        db.entityVersions[i + (EntityDatabase.MaxNumberOfEntities / 2)] <- db.lastCreatedLocalEntity.Version - 1
                )
            For(db.lastCreatedLocalEntity.Index + 1 - (EntityDatabase.MaxNumberOfEntities / 2),
                i ->
                    db.entityVersions[i + (EntityDatabase.MaxNumberOfEntities / 2)] <- db.lastCreatedLocalEntity.Version
            )

        if (reader.TokenType != JsonTokenType.PropertyName)
            fail("Expected PropertyName")

        let _ = reader.Read()
        if (reader.TokenType != JsonTokenType.StartArray)
            fail("Expected StartArray")
        let _ = reader.Read()


        let mutable count = 0
        let mutable localCount = 0

        let nameToIndex = Dictionary<string, int32>()

        let start = reader

        let compIds = List()
        let lookup = db.entityIndexLookup      
        let mutable entIndex = -1
        let mutable entName = string.Empty
        
        let iterLookup = initMutableArray(EntityDatabase.MaxNumberOfEntities, i -> EntityId.Nil)

        let mutable i = 0
        while (reader.TokenType != JsonTokenType.EndArray)
            match (reader.TokenType)
            | JsonTokenType.PropertyName when (reader.GetString() == "#") =>
                let _ = reader.Read()
                let utf8Stream = File.Open(reader.GetString(), FileMode.Open) // TODO:
                let _ = reader.Read()
                let length = int32(utf8Stream.Length - utf8Stream.Position)
                let buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(length)
                let length = utf8Stream.Read(buffer, 0, length)
                utf8Stream.Dispose()
                let json = ReadOnlySpan(buffer, 0, length)
        
                let mutable options = default: JsonReaderOptions
                let mutable innerReader = Utf8JsonReader(json, options)
                let _ = innerReader.Read()

                let mutable willContinue = true
                while (willContinue)
                    willContinue <-
                        PreDeserializeJsonForEntityCore(
                            &innerReader,
                            db,
                            compIds,
                            &entIndex,
                            &entName,
                            isUsingEntityIndices
                        )
                
                willContinue <- reader.TokenType != JsonTokenType.EndObject
                if (!willContinue)
                    PreDeserializeJsonForEntityCoreFinished(
                        &innerReader,
                        db,
                        i,
                        lookup,
                        iterLookup,
                        nameToIndex,
                        compIds,
                        &count,
                        &localCount,
                        &entIndex,
                        &entName,
                        isUsingEntityIndices
                    )
                    i <- i + 1

                System.Buffers.ArrayPool<byte>.Shared.Return(buffer, true)        
            | _ =>
                let willContinue = 
                    PreDeserializeJsonForEntityCore(
                        &reader,
                        db,
                        compIds,
                        &entIndex,
                        &entName,
                        isUsingEntityIndices
                    )
                if (!willContinue)
                    PreDeserializeJsonForEntityCoreFinished(
                        &reader,
                        db,
                        i,
                        lookup,
                        iterLookup,
                        nameToIndex,
                        compIds,
                        &count,
                        &localCount,
                        &entIndex,
                        &entName,
                        isUsingEntityIndices
                    )
                    i <- i + 1

        reader <- start

        let visitedComps = HashSet<string>()

        let mutable i = 0
        while (reader.TokenType != JsonTokenType.EndArray)
            match (reader.TokenType)
            | JsonTokenType.PropertyName when (reader.GetString() == "#") =>
                let _ = reader.Read()
                let utf8Stream = File.Open(reader.GetString(), FileMode.Open) // TODO:
                let _ = reader.Read()
                let length = int32(utf8Stream.Length - utf8Stream.Position)
                let buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(length)
                let length = utf8Stream.Read(buffer, 0, length)
                utf8Stream.Dispose()
                let json = ReadOnlySpan(buffer, 0, length)
        
                let mutable options = default: JsonReaderOptions
                let mutable innerReader = Utf8JsonReader(json, options)
                let _ = innerReader.Read()

                let mutable willContinue = true
                while (willContinue)
                    willContinue <-
                        DeserializeJsonForEntityCore(
                            visitedComps,
                            &innerReader,
                            db,
                            i,
                            lookup,
                            iterLookup,
                            nameToIndex
                        )

                willContinue <- reader.TokenType != JsonTokenType.EndObject
                if (!willContinue)
                    visitedComps.Clear()
                    i <- i + 1

                System.Buffers.ArrayPool<byte>.Shared.Return(buffer, true) 
            | _ =>
                let willContinue =
                    DeserializeJsonForEntityCore(
                        visitedComps,
                        &reader,
                        db,
                        i,
                        lookup,
                        iterLookup,
                        nameToIndex               
                    )
                if (!willContinue)
                    visitedComps.Clear()
                    i <- i + 1

        let _ = reader.Read()

        TypeHelpers.ReadEndObject(&reader)

        db.entityCount <- count
        db.localEntityCount <- localCount

        db.DebugCheckIntegrity()

        System.Buffers.ArrayPool<byte>.Shared.Return(buffer, true)

    GetEntityAsJsonByIndex(index: int32): string =
        let entId = this.TryGetValidEntityIdByIndex(index)
        if (entId.IsNil)
            string.Empty
        else
            let ms = System.IO.MemoryStream()
            EntityDatabase.SerializeJsonForEntity(this, entId, ms)
            let json = System.Text.Encoding.UTF8.GetString(ReadOnlySpan(ms.GetBuffer(), 0, int32(ms.Length)))
            ms.Dispose()
            json

class UnlockedEntityDatabase =
    inherits EntityDatabase

    static SubAdded<T, TMatch>(db: UnlockedEntityDatabase, f: (EntityId, byref<T>, byref<TMatch>) -> ()): ()
        where T: blittable, struct, ValueType, { new() }, trait IComponent 
        where TMatch: blittable, struct, ValueType, { new() }, trait IComponent
        =
        let lookup = db.entityIndexLookup
        let indices = db.GetArchetypedIndices(GetArchetypeId<T, TMatch>())
        let mutable i = 0
        while (i < indices.Length)
            let archetype = db.GetArchetype(indices[i])
            let entIds = archetype.EntityIds
            let buffer = archetype.Buffers[archetype.BufferLookup[T.GetId()]]
            let buffer1 = archetype.Buffers[archetype.BufferLookup[TMatch.GetId()]]
            let store = buffer.Store
            let store1 = buffer1.Store
            buffer.ComponentAdded.Add(
                index -> f(entIds.GetAs(index), &store.GetAs<T>(index), &store1.GetAs<TMatch>(index))                       
            )
            i <- i + 1

    static SubAdded<T, TMatch1, TMatch2>(db: UnlockedEntityDatabase, f: (EntityId, byref<T>, byref<TMatch1>, byref<TMatch2>) -> ()): ()
        where T: blittable, struct, ValueType, { new() }, trait IComponent 
        where TMatch1: blittable, struct, ValueType, { new() }, trait IComponent
        where TMatch2: blittable, struct, ValueType, { new() }, trait IComponent
        =
        let lookup = db.entityIndexLookup
        let indices = db.GetArchetypedIndices(GetArchetypeId<T, TMatch1, TMatch2>())
        let mutable i = 0
        while (i < indices.Length)
            let archetype = db.GetArchetype(indices[i])
            let entIds = archetype.EntityIds
            let buffer = archetype.Buffers[archetype.BufferLookup[T.GetId()]]
            let buffer1 = archetype.Buffers[archetype.BufferLookup[TMatch1.GetId()]]
            let buffer2 = archetype.Buffers[archetype.BufferLookup[TMatch2.GetId()]]
            let store = buffer.Store
            let store1 = buffer1.Store
            let store2 = buffer2.Store
            buffer.ComponentAdded.Add(
                index -> f(entIds.GetAs(index), &store.GetAs<T>(index), &store1.GetAs<TMatch1>(index), &store2.GetAs<TMatch2>(index))                       
            )
            i <- i + 1

    static SubAdded<T, TMatch1, TMatch2, TMatch3>(db: UnlockedEntityDatabase, f: (EntityId, byref<T>, byref<TMatch1>, byref<TMatch2>, byref<TMatch3>) -> ()): ()
        where T: blittable, struct, ValueType, { new() }, trait IComponent 
        where TMatch1: blittable, struct, ValueType, { new() }, trait IComponent
        where TMatch2: blittable, struct, ValueType, { new() }, trait IComponent
        where TMatch3: blittable, struct, ValueType, { new() }, trait IComponent
        =
        let lookup = db.entityIndexLookup
        let indices = db.GetArchetypedIndices(GetArchetypeId<T, TMatch1, TMatch2, TMatch3>())
        let mutable i = 0
        while (i < indices.Length)
            let archetype = db.GetArchetype(indices[i])
            let entIds = archetype.EntityIds
            let buffer = archetype.Buffers[archetype.BufferLookup[T.GetId()]]
            let buffer1 = archetype.Buffers[archetype.BufferLookup[TMatch1.GetId()]]
            let buffer2 = archetype.Buffers[archetype.BufferLookup[TMatch2.GetId()]]
            let buffer3 = archetype.Buffers[archetype.BufferLookup[TMatch3.GetId()]]
            let store = buffer.Store
            let store1 = buffer1.Store
            let store2 = buffer2.Store
            let store3 = buffer3.Store
            buffer.ComponentAdded.Add(
                index -> f(entIds.GetAs(index), &store.GetAs<T>(index), &store1.GetAs<TMatch1>(index), &store2.GetAs<TMatch2>(index), &store3.GetAs<TMatch3>(index))                       
            )
            i <- i + 1

    static SubRemoving<T>(db: UnlockedEntityDatabase, f: (EntityId, byref<T>) -> ()): ()
        where T: blittable, struct, ValueType, { new() }, trait IComponent 
        =
        let lookup = db.entityIndexLookup
        let indices = db.GetArchetypedIndices(GetArchetypeId<T>())
        let mutable i = 0
        while (i < indices.Length)
            let archetype = db.GetArchetype(indices[i])
            let entIds = archetype.EntityIds
            let buffer = archetype.Buffers[archetype.BufferLookup[T.GetId()]]
            let store = buffer.Store
            buffer.ComponentRemoving.Add(
                index -> f(entIds.GetAs(index), &store.GetAs<T>(index))                       
            )
            i <- i + 1

    static SubRemoving<T, TMatch>(db: UnlockedEntityDatabase, f: (EntityId, byref<T>, byref<TMatch>) -> ()): ()
        where T: blittable, struct, ValueType, { new() }, trait IComponent 
        where TMatch: blittable, struct, ValueType, { new() }, trait IComponent
        =
        let lookup = db.entityIndexLookup
        let indices = db.GetArchetypedIndices(GetArchetypeId<T, TMatch>())
        let mutable i = 0
        while (i < indices.Length)
            let archetype = db.GetArchetype(indices[i])
            let entIds = archetype.EntityIds
            let buffer = archetype.Buffers[archetype.BufferLookup[T.GetId()]]
            let buffer1 = archetype.Buffers[archetype.BufferLookup[TMatch.GetId()]]
            let store = buffer.Store
            let store1 = buffer1.Store
            buffer.ComponentRemoving.Add(
                index -> f(entIds.GetAs(index), &store.GetAs<T>(index), &store1.GetAs<TMatch>(index))                       
            )
            i <- i + 1

    static SubRemoving<T, TMatch1, TMatch2>(db: UnlockedEntityDatabase, f: (EntityId, byref<T>, byref<TMatch1>, byref<TMatch2>) -> ()): ()
        where T: blittable, struct, ValueType, { new() }, trait IComponent 
        where TMatch1: blittable, struct, ValueType, { new() }, trait IComponent
        where TMatch2: blittable, struct, ValueType, { new() }, trait IComponent
        =
        let lookup = db.entityIndexLookup
        let indices = db.GetArchetypedIndices(GetArchetypeId<T, TMatch1, TMatch2>())
        let mutable i = 0
        while (i < indices.Length)
            let archetype = db.GetArchetype(indices[i])
            let entIds = archetype.EntityIds
            let buffer = archetype.Buffers[archetype.BufferLookup[T.GetId()]]
            let buffer1 = archetype.Buffers[archetype.BufferLookup[TMatch1.GetId()]]
            let buffer2 = archetype.Buffers[archetype.BufferLookup[TMatch2.GetId()]]
            let store = buffer.Store
            let store1 = buffer1.Store
            let store2 = buffer2.Store
            buffer.ComponentRemoving.Add(
                index -> f(entIds.GetAs(index), &store.GetAs<T>(index), &store1.GetAs<TMatch1>(index), &store2.GetAs<TMatch2>(index))                       
            )
            i <- i + 1

    static SubRemoving<T, TMatch1, TMatch2, TMatch3>(db: UnlockedEntityDatabase, f: (EntityId, byref<T>, byref<TMatch1>, byref<TMatch2>, byref<TMatch3>) -> ()): ()
        where T: blittable, struct, ValueType, { new() }, trait IComponent 
        where TMatch1: blittable, struct, ValueType, { new() }, trait IComponent
        where TMatch2: blittable, struct, ValueType, { new() }, trait IComponent
        where TMatch3: blittable, struct, ValueType, { new() }, trait IComponent
        =
        let lookup = db.entityIndexLookup
        let indices = db.GetArchetypedIndices(GetArchetypeId<T, TMatch1, TMatch2, TMatch3>())
        let mutable i = 0
        while (i < indices.Length)
            let archetype = db.GetArchetype(indices[i])
            let entIds = archetype.EntityIds
            let buffer = archetype.Buffers[archetype.BufferLookup[T.GetId()]]
            let buffer1 = archetype.Buffers[archetype.BufferLookup[TMatch1.GetId()]]
            let buffer2 = archetype.Buffers[archetype.BufferLookup[TMatch2.GetId()]]
            let buffer3 = archetype.Buffers[archetype.BufferLookup[TMatch3.GetId()]]
            let store = buffer.Store
            let store1 = buffer1.Store
            let store2 = buffer2.Store
            let store3 = buffer3.Store
            buffer.ComponentRemoving.Add(
                index -> f(entIds.GetAs(index), &store.GetAs<T>(index), &store1.GetAs<TMatch1>(index), &store2.GetAs<TMatch2>(index), &store3.GetAs<TMatch3>(index))                       
            )
            i <- i + 1  

    new(kind: EntityDatabaseKind, registry: ComponentRegistry) = base(kind, registry)

    HandleComponentAdded<T>(f: (EntityId, byref<T>) -> ()): () where T: blittable, struct, ValueType, { new() }, trait IComponent =
        static let sub(db: UnlockedEntityDatabase, f: (EntityId, byref<T>) -> ()): () =
            let lookup = db.entityIndexLookup
            let indices = db.GetArchetypedIndices(GetArchetypeId<T>())
            let mutable i = 0
            while (i < indices.Length)
                let archetype = db.GetArchetype(indices[i])
                let entIds = archetype.EntityIds
                let buffer = archetype.Buffers[archetype.BufferLookup[T.GetId()]]
                let store = buffer.Store
                buffer.ComponentAdded.Add(
                    index -> f(entIds.GetAs(index), &store.GetAs<T>(index))                       
                )
                i <- i + 1
        this.Resubs.Add(() -> sub(this, f))
        sub(this, f)

    HandleComponentAdded<T, TMatch>(f: (EntityId, byref<T>, byref<TMatch>) -> ()): () 
            where T: blittable, struct, ValueType, { new() }, trait IComponent 
            where TMatch: blittable, struct, ValueType, { new() }, trait IComponent
            =
        this.Resubs.Add(() -> SubAdded(this, f))
        SubAdded(this, f)

    HandleComponentAdded<T, TMatch1, TMatch2>(f: (EntityId, byref<T>, byref<TMatch1>, byref<TMatch2>) -> ()): () 
            where T: blittable, struct, ValueType, { new() }, trait IComponent 
            where TMatch1: blittable, struct, ValueType, { new() }, trait IComponent
            where TMatch2: blittable, struct, ValueType, { new() }, trait IComponent
            =
        this.Resubs.Add(() -> SubAdded(this, f))
        SubAdded(this, f)

    HandleComponentAdded<T, TMatch1, TMatch2, TMatch3>(f: (EntityId, byref<T>, byref<TMatch1>, byref<TMatch2>, byref<TMatch3>) -> ()): () 
            where T: blittable, struct, ValueType, { new() }, trait IComponent 
            where TMatch1: blittable, struct, ValueType, { new() }, trait IComponent
            where TMatch2: blittable, struct, ValueType, { new() }, trait IComponent
            where TMatch3: blittable, struct, ValueType, { new() }, trait IComponent
            =
        this.Resubs.Add(() -> SubAdded(this, f))
        SubAdded(this, f)

    HandleComponentRemoving<T>(f: (EntityId, byref<T>) -> ()): () where T: blittable, struct, ValueType, { new() }, trait IComponent =
        this.Resubs.Add(() -> SubRemoving(this, f))
        SubRemoving(this, f)

    HandleComponentRemoving<T, TMatch>(f: (EntityId, byref<T>, byref<TMatch>) -> ()): () 
            where T: blittable, struct, ValueType, { new() }, trait IComponent 
            where TMatch: blittable, struct, ValueType, { new() }, trait IComponent
            =
        this.Resubs.Add(() -> SubRemoving(this, f))
        SubRemoving(this, f)

    HandleComponentRemoving<T, TMatch1, TMatch2>(f: (EntityId, byref<T>, byref<TMatch1>, byref<TMatch2>) -> ()): () 
            where T: blittable, struct, ValueType, { new() }, trait IComponent 
            where TMatch1: blittable, struct, ValueType, { new() }, trait IComponent
            where TMatch2: blittable, struct, ValueType, { new() }, trait IComponent
            =
        this.Resubs.Add(() -> SubRemoving(this, f))
        SubRemoving(this, f)

    HandleComponentRemoving<T, TMatch1, TMatch2, TMatch3>(f: (EntityId, byref<T>, byref<TMatch1>, byref<TMatch2>, byref<TMatch3>) -> ()): () 
            where T: blittable, struct, ValueType, { new() }, trait IComponent 
            where TMatch1: blittable, struct, ValueType, { new() }, trait IComponent
            where TMatch2: blittable, struct, ValueType, { new() }, trait IComponent
            where TMatch3: blittable, struct, ValueType, { new() }, trait IComponent
            =        
        this.Resubs.Add(() -> SubRemoving(this, f))
        SubRemoving(this, f)

    HandleComponentCycle<T>(
        added: (EntityId, byref<T>) -> (),
        removing: (EntityId, byref<T>) -> ()): ()
        where T: blittable, struct, ValueType, { new() }, trait IComponent 
        =
        this.HandleComponentAdded(added)
        this.HandleComponentRemoving(removing)

    HandleComponentCycle<T, TMatch>(
        added: (EntityId, byref<T>, byref<TMatch>) -> (),
        removing: (EntityId, byref<T>, byref<TMatch>) -> ()): ()
        where T: blittable, struct, ValueType, { new() }, trait IComponent 
        where TMatch: blittable, struct, ValueType, { new() }, trait IComponent
        =
        this.HandleComponentAdded(added)
        this.HandleComponentRemoving(removing)

    HandleComponentCycle<T, TMatch1, TMatch2>(
        added: (EntityId, byref<T>, byref<TMatch1>, byref<TMatch2>) -> (),
        removing: (EntityId, byref<T>, byref<TMatch1>, byref<TMatch2>) -> ()): ()
        where T: blittable, struct, ValueType, { new() }, trait IComponent 
        where TMatch1: blittable, struct, ValueType, { new() }, trait IComponent
        where TMatch2: blittable, struct, ValueType, { new() }, trait IComponent
        =
        this.HandleComponentAdded(added)
        this.HandleComponentRemoving(removing)

    HandleComponentCycle<T, TMatch1, TMatch2, TMatch3>(
        added: (EntityId, byref<T>, byref<TMatch1>, byref<TMatch2>, byref<TMatch3>) -> (),
        removing: (EntityId, byref<T>, byref<TMatch1>, byref<TMatch2>, byref<TMatch3>) -> ()): ()
        where T: blittable, struct, ValueType, { new() }, trait IComponent 
        where TMatch1: blittable, struct, ValueType, { new() }, trait IComponent
        where TMatch2: blittable, struct, ValueType, { new() }, trait IComponent
        where TMatch3: blittable, struct, ValueType, { new() }, trait IComponent
        =
        this.HandleComponentAdded(added)
        this.HandleComponentRemoving(removing)

    TryAddOrUpdate<T>(entId: EntityId, value: T): () where T: blittable, struct, ValueType, { new() }, trait IComponent =
        this.TryAddOrUpdate(entId, &value)
    TryAddOrUpdate<T>(mutable entId: EntityId, value: inref<T>): () where T: blittable, struct, ValueType, { new() }, trait IComponent =
        this.ThrowIfDepth()
        this.ThrowIfParallelDepth()
        if (this.IsValid(entId))
            let lookup = this.entityIndexLookup
            let tyId: ComponentId = T.GetId()

            let mutable diff = default
            let archetype = this.AddCore(entId, tyId, &diff)
            if (archetype !== unchecked default)
                let index = lookup[entId.Index]
                archetype.Set(archetype.BufferLookup[tyId], index, value)

                if (!diff.IsZero)
                    archetype.TriggerComponentAdded(diff, index)
            else
                let currentArchetype = this.GetArchetype(this.entityArchetypeIndices[entId.Index])
#if DEBUG
                fail("Cannot add component '" + T.GetName() + "' to entity '" + entId.ToString() + "'. The resulting archetype is not registered:\n\t" + currentArchetype.ComponentListNoAttachmentsText + T.GetName() + ",")
#end
                LogError("Cannot add component '" + T.GetName() + "' to entity '" + entId.ToString() + "'. The resulting archetype is not registered:\n\t" + currentArchetype.ComponentListNoAttachmentsText + T.GetName() + ",")

    TryRemove<T>(entId: EntityId): () where T: blittable, struct, ValueType, { new() }, trait IComponent =
        this.ThrowIfDepth()
        this.ThrowIfParallelDepth()
        if (this.IsValid(entId))
            let archetypeIndex = this.entityArchetypeIndices[entId.Index]
            if (archetypeIndex != -1)
                let archetype = this.GetArchetype(archetypeIndex)
                if (archetype.Id.IsSet(T.GetIndex()))
                    let compId: ComponentId = T.GetId()
                    let lookupIndex = this.entityIndexLookup[entId.Index]

                    archetype.TriggerComponentRemoving(compId, lookupIndex)

                    let newArchetypeId = archetype.Id & compId.BitwiseNot()
                    let newArchetypeIndex = this.GetArchetypedIndex(newArchetypeId)
                    let newArchetype = this.GetArchetype(newArchetypeIndex)
                    let newLookupIndex = newArchetype.Count
                    newArchetype.Count <- newArchetype.Count + 1
                    newArchetype.EntityIds.SetAs(newLookupIndex, entId)

                    archetype.CopyOneTo(lookupIndex, newArchetype, newLookupIndex)
                    this.entityArchetypeIndices[entId.Index] <- newArchetypeIndex
                    this.entityIndexLookup[entId.Index] <- newLookupIndex
                    this.SwapRemoveEntityByLookupIndex(archetype, lookupIndex)
                    
                    this.DebugCheckIntegrity()

    Delete(entId: EntityId): () =
        this.Check(entId)
        this.DeleteCore(entId)

    TryDelete(entId: EntityId): bool =
        if (this.IsValid(entId))
            this.DeleteCore(entId)
            true
        else
            false

    DeleteAll(): () =
        let queue = Queue<EntityId>()

        let mutable i = 0
        while (i < this.GetArchetypeCount())
            let archetype = this.GetArchetype(i)
            let count = archetype.Count
            let entIds = archetype.EntityIds
            For(count,
                i ->
                    queue.Enqueue(entIds.GetAs(i))
            )
            i <- i + 1

        let mutable entId = default
        while (queue.TryDequeue(&entId))
            let _ = this.Delete(entId)

        if (this.entityCount != 0)
            fail("Integrity has failed")

        if (this.localEntityCount != 0)
            fail("Integrity has failed")

#[open]
extension EntityDatabaseExtensions =
    inherits EntityDatabase

    Replicate(dstCopy: EntityDatabase, dst: UnlockedEntityDatabase, events: EntityDatabase.ReplicatingEvents, nonLocalOnly: bool): () =
        let mutable i = 0
        while (i < events.DeletingEntities.Count)
            let info = events.DeletingEntities[i]

#if DEBUG
            if (nonLocalOnly && info.EntityId.Index >= (EntityDatabase.MaxNumberOfEntities / 2))
                fail("Cannot delete local entity in a non-local context")
#end

            dst.Delete(info.EntityId)
            i <- i + 1

        dst.IncrementDepth()

        // TODO: Make this non-allocating if it makes sense to.
        let queue = Queue()

        let mutable i = 0
        while (i < events.ArchetypeChangedEntities.Count)
            let result = events.ArchetypeChangedEntities[i]
            let entIndex = result.EntityIndex

#if DEBUG
            if (nonLocalOnly && entIndex >= (EntityDatabase.MaxNumberOfEntities / 2))
                fail("Cannot change local entity in a non-local context")
#end

            let prevArchetypeCopy = dstCopy.GetArchetype(dstCopy.GetArchetypedIndex(result.PreviousArchetypeId))
            let prevArchetype = dst.GetArchetype(dst.GetArchetypedIndex(result.PreviousArchetypeId))
            let archetypedIndex = dst.GetArchetypedIndex(result.ArchetypeId)
            let dstArchetype = dst.GetArchetype(archetypedIndex)

#if DEBUG
            if (prevArchetypeCopy.Id != prevArchetype.Id)
                fail("Archetype integrity failed in replication")
#end

            let diff = prevArchetype.FullId & dstArchetype.FullId.BitwiseNot()
            if (!diff.IsZero)
                prevArchetype.TriggerComponentRemoving(diff, result.PreviousIndex)

            dstArchetype.EnsureCapacity(dstArchetype.Count + 1)

            prevArchetypeCopy.CopyOneTo(result.PreviousIndex, dstArchetype, result.Index)
            dst.entityArchetypeIndices[entIndex] <- archetypedIndex

            let diff = dstArchetype.FullId & prevArchetype.FullId.BitwiseNot()
            if (!diff.IsZero)
                queue.Enqueue(
                    () ->
                        dstArchetype.TriggerComponentAdded(diff, result.Index)
                )

            i <- i + 1

        if (nonLocalOnly)
            Span(this.entityVersions, 0, this.entityVersions.Length / 2).CopyTo(Span(dst.entityVersions))
            Span(this.entityIndexLookup, 0, this.entityIndexLookup.Length / 2).CopyTo(Span(dst.entityIndexLookup))
        else
            Span(this.entityVersions).CopyTo(Span(dst.entityVersions))
            Span(this.entityIndexLookup).CopyTo(Span(dst.entityIndexLookup))

        dst.lastCreatedEntity <- this.lastCreatedEntity
        dst.entityCount <- this.entityCount

        if (!nonLocalOnly)
            dst.lastCreatedLocalEntity <- this.lastCreatedLocalEntity
            dst.localEntityCount <- this.localEntityCount

        // Archetype counts should also be zero.
        let mutable i = 0
        while (i < dst.GetArchetypeCount())
            let archetype = dst.GetArchetype(i)
            if (nonLocalOnly)
                if (!archetype.IsLocal)
                    archetype.Count <- 0
            else
                archetype.Count <- 0
            i <- i + 1

        let mutable i = 0
        while (i < this.GetArchetypeCount())     
            let archetype = this.GetArchetype(i)
            if (nonLocalOnly)
                if (!archetype.IsLocal)
                    archetype.CopyTo(dst.GetArchetype(dst.GetArchetypedIndex(archetype.Id)))
            else
                archetype.CopyTo(dst.GetArchetype(dst.GetArchetypedIndex(archetype.Id)))
            i <- i + 1

        let mutable f = unchecked default
        while (queue.TryDequeue(&f))
            f()

        let mutable i = 0
        while (i < events.CreatedEntities.Count)
            let result = events.CreatedEntities[i]
            let entId = result.EntityId
            let entIndex = entId.Index
#if DEBUG
            if (nonLocalOnly && entIndex >= (EntityDatabase.MaxNumberOfEntities / 2))
                fail("Cannot create local entity in a non-local context")
#end
            let archetypedIndex = dst.GetArchetypedIndex(result.ArchetypeId)
            dst.entityVersions[entIndex] <- entId.Version
            dst.entityArchetypeIndices[entIndex] <- archetypedIndex

            let archetype = dst.GetArchetype(archetypedIndex)
            archetype.TriggerComponentAdded(archetype.FullId, dst.entityIndexLookup[entIndex])

            i <- i + 1

        dst.DecrementDepth()

    DeserializeReplication(srcStream: ByteStream, dstCopy: EntityDatabase, dst: UnlockedEntityDatabase, nonLocalOnly: bool): () =
        let deletingEntityCount = srcStream.ReadInt32()

        let mutable i = 0
        while (i < deletingEntityCount)
            let entId = srcStream.Read<EntityId>()

#if DEBUG
            if (nonLocalOnly && entId.Index >= (EntityDatabase.MaxNumberOfEntities / 2))
                fail("Cannot delete local entity in a non-local context")
#end

            dst.Delete(entId)
            i <- i + 1

        dst.IncrementDepth()

        // TODO: Make this non-allocating if it makes sense to.
        let queue = Queue()

        let archetypeChangedEntityCount = srcStream.ReadInt32()

        let mutable i = 0
        while (i < archetypeChangedEntityCount)
            let entIndex = srcStream.ReadInt32()
            let prevIndex = srcStream.ReadInt32()
            let index = srcStream.ReadInt32()
            let prevArchetypeId = srcStream.Read<ArchetypeId>()
            let archetypeId = srcStream.Read<ArchetypeId>()

#if DEBUG
            if (nonLocalOnly && entIndex >= (EntityDatabase.MaxNumberOfEntities / 2))
                fail("Cannot change local entity in a non-local context")
#end

            let prevArchetypeCopy = dstCopy.GetArchetype(dstCopy.GetArchetypedIndex(prevArchetypeId))
            let prevArchetype = dst.GetArchetype(dst.GetArchetypedIndex(prevArchetypeId))
            let archetypedIndex = dst.GetArchetypedIndex(archetypeId)
            let dstArchetype = dst.GetArchetype(archetypedIndex)

#if DEBUG
            if (prevArchetypeCopy.Id != prevArchetype.Id)
                fail("Archetype integrity failed in replication")
#end

            let diff = prevArchetype.FullId & dstArchetype.FullId.BitwiseNot()
            if (!diff.IsZero)
                prevArchetype.TriggerComponentRemoving(diff, prevIndex)

            dstArchetype.EnsureCapacity(dstArchetype.Count + 1)

            prevArchetypeCopy.CopyOneTo(prevIndex, dstArchetype, index)
            dst.entityArchetypeIndices[entIndex] <- archetypedIndex

            let diff = dstArchetype.FullId & prevArchetype.FullId.BitwiseNot()
            if (!diff.IsZero)
                queue.Enqueue(
                    () ->
                        dstArchetype.TriggerComponentAdded(diff, index)
                )

            i <- i + 1

        if (nonLocalOnly)
            Span(this.entityVersions, 0, this.entityVersions.Length / 2).CopyTo(Span(dst.entityVersions))
            Span(this.entityIndexLookup, 0, this.entityIndexLookup.Length / 2).CopyTo(Span(dst.entityIndexLookup))
        else
            Span(this.entityVersions).CopyTo(Span(dst.entityVersions))
            Span(this.entityIndexLookup).CopyTo(Span(dst.entityIndexLookup))

        dst.lastCreatedEntity <- this.lastCreatedEntity
        dst.entityCount <- this.entityCount

        if (!nonLocalOnly)
            dst.lastCreatedLocalEntity <- this.lastCreatedLocalEntity
            dst.localEntityCount <- this.localEntityCount

        // Archetype counts should also be zero.
        let mutable i = 0
        while (i < dst.GetArchetypeCount())
            let archetype = dst.GetArchetype(i)
            if (nonLocalOnly)
                if (!archetype.IsLocal)
                    archetype.Count <- 0
            else
                archetype.Count <- 0
            i <- i + 1

        let mutable i = 0
        while (i < this.GetArchetypeCount())     
            let archetype = this.GetArchetype(i)
            if (nonLocalOnly)
                if (!archetype.IsLocal)
                    archetype.CopyTo(dst.GetArchetype(dst.GetArchetypedIndex(archetype.Id)))
            else
                archetype.CopyTo(dst.GetArchetype(dst.GetArchetypedIndex(archetype.Id)))
            i <- i + 1

        let mutable f = unchecked default
        while (queue.TryDequeue(&f))
            f()

        let createdEntityCount = srcStream.ReadInt32()

        let mutable i = 0
        while (i < createdEntityCount)
            let entId = srcStream.Read<EntityId>()
            let archetypeId = srcStream.Read<ArchetypeId>()

            let entIndex = entId.Index
#if DEBUG
            if (nonLocalOnly && entIndex >= (EntityDatabase.MaxNumberOfEntities / 2))
                fail("Cannot create local entity in a non-local context")
#end
            let archetypedIndex = dst.GetArchetypedIndex(archetypeId)
            dst.entityVersions[entIndex] <- entId.Version
            dst.entityArchetypeIndices[entIndex] <- archetypedIndex

            let archetype = dst.GetArchetype(archetypedIndex)
            archetype.TriggerComponentAdded(archetype.FullId, dst.entityIndexLookup[entIndex])

            i <- i + 1

        dst.DecrementDepth()