namespace Game.Client

open System
open System.Numerics
open System.Text
open System.Collections.Generic
open System.Collections.Concurrent
open System.Runtime.InteropServices

open Evergreen.Utilities
open Evergreen.Collections
open Evergreen.Graphics
open Evergreen.Physics
open Evergreen.Network
open Evergreen.Graphics.Rendering
open Evergreen.Window

open Game.Shared
open static Game.Shared.Types
open static Game.Shared.Components
open static Game.Shared.World

open Game.Client.Systems
open static Game.Client.Types
open static Game.Client.Components

class ClientReceivedWorld =
    inherits World

    new(genv: GameEnv) =
        let registry = ComponentRegistry()

        World.RegisterComponents(registry)

        registry.Register<CharacterInput>()
        registry.RegisterAttachment<Player, CharacterInput>()

        World.RegisterFieldMappings(genv, registry)

        base(EntityDatabase(EntityDatabaseKind.Client, registry))

class ClientStagingWorld =
    inherits World
    
    new(genv: GameEnv) =
        base(EntityDatabase(EntityDatabaseKind.Client, ClientWorld.CreateRegistry(genv)))

    protected new(db: EntityDatabase) = base(db)

class ClientWorld =
    inherits World
    implements IDisposable, IUnlockedWorld

    static CreateRegistry(genv: GameEnv): ComponentRegistry =
        let registry = ComponentRegistry()

        World.RegisterComponents(registry)

        registry.Register<CharacterInput>()
        registry.RegisterAttachment<Player, CharacterInput>()

        registry.Register<CharacterId>()
        registry.Register<VirtualCharacterId>()
        registry.RegisterAttachment<Character, CharacterId>()
        registry.RegisterAttachment<VirtualCharacter, VirtualCharacterId>()

        registry.Register<StaticObjectId>()
        registry.Register<DynamicObjectId>()
        registry.RegisterAttachment<StaticRigidBody, StaticObjectId>()
        registry.RegisterAttachment<RigidBody, DynamicObjectId>()

        registry.Register<PredictiveInfo>()
        registry.RegisterAttachment<RigidBody, PredictiveInfo>()

        registry.Register<CameraLerp>()
        registry.RegisterAttachment<Camera, CameraLerp>()

        registry.Register<TransformLerp>()
        registry.RegisterAttachment<Transform, TransformLerp>()

        World.RegisterFieldMappings(genv, registry)

        registry

    UnlockedDatabase: UnlockedEntityDatabase get

    new(genv: GameEnv) =
        let db = UnlockedEntityDatabase(EntityDatabaseKind.Client, ClientWorld.CreateRegistry(genv))
        base(db) with {
            Physics = 
                // This registers the events in the physics system first.
                let physicsSystem = ClientPhysicsSystem.Create(db, genv)

                db.HandleComponentAdded<PredictiveInfo, /**/ Transform>(
                    (entId, predictiveInfo, transform) ->
                        predictiveInfo.EntityId <- entId
                        predictiveInfo.TransitionDuration <- 2
                        predictiveInfo.LerpToPredictTransitionTime <- 0
                        predictiveInfo.PredictToLerpTransitionTime <- 0
                        predictiveInfo.Position <- transform.Position
                        predictiveInfo.Rotation <- transform.Rotation
                        predictiveInfo.Status <- PredictionStatus.NotPredicting                      
                )    

                db.HandleComponentAdded<TransformLerp, /**/ Transform>(
                    (entId, transformLerp, transform) ->
                        transformLerp.Value <- transform
                )

                db.HandleComponentAdded<CameraLerp, /**/ Camera>(
                    (entId, cameraLerp, camera) ->
                        cameraLerp.Value <- camera
                )

                db.HandleComponentAdded<CharacterInput, /**/ Camera>(
                    (entId, input, camera) ->
                        // TODO: This doesn't actually set the input. We need to solve this.
                        input.Yaw <- camera.Yaw
                        input.Pitch <- camera.Pitch                         
                )

                db.HandleComponentAdded<Editor, Camera, Transform, CharacterInput>(
                    (entId, editor, camera, transform, input) ->
                        // TODO: This doesn't actually set the input. We need to solve this.
                        editor.Camera.LookAt(editor.Transform.Position, transform.Position)
                        input.Yaw <- editor.Camera.Yaw
                        input.Pitch <- editor.Camera.Pitch
                )

                physicsSystem
            UnlockedDatabase = db
        }
    
    public field Physics: ClientPhysicsSystem

    PredictionEnabled: bool
        get() = this.Physics.PredictionEnabled
        set(value) = this.Physics.PredictionEnabled <- value

    PredictUpdate(time: GameTime, entId: EntityId): () =
        if (this.PredictionEnabled)
            this.Physics.Update(time)

    ResetPredictions(): () =
        this.Physics.ResetPredictions()

    RecordPlayerPredictions(deltaTime: float32, entId: EntityId): () =
        if (this.PredictionEnabled)
            this.Physics.RecordPlayerPredictions(deltaTime, entId)

    SetPhysicsState(): () =
        this.Physics.SetState()

    UpdateTransforms(): () =
        this.Physics.UpdateTransforms()

    RollbackCorrections(time: GameTime, entId: EntityId): () =
        this.Physics.RollbackCorrections(time, entId)

    SetInterpolationState(): () =
        this.Database.CreateQuery<TransformLerp, Transform>().ForEach(
            (entId, transformLerp, transform) ->
                transformLerp <- TransformLerp(transform)
        )
        this.Database.CreateQuery<CameraLerp, Camera>().ForEach(
            (entId, cameraLerp, camera) ->
                cameraLerp <- CameraLerp(camera)
        )

    OptimizeStaticEnvironment(): () =
        this.Physics.OptimizeBroadPhase()

    Dispose(): () =
        this.Physics.Dispose()
